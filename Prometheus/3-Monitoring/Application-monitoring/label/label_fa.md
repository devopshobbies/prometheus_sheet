

‏label‌ها  بخش کلیدی پرومتئوس هستند و یکی از عواملی که آن را قدرتمند می‌کند. در این فصل، شما یاد خواهید گرفت که ‏‏label‌ها چه هستند، از کجا می‌آیند و چگونه می‌توانید آن‌ها را به متریک‌های خود اضافه کنید.

### ‏‏label‌ها چه هستند؟

‏‏label‌ها، جفت‌های کلید-مقدار مرتبط با سری‌های زمانی هستند که علاوه بر نام متریک، آن‌ها را به طور منحصر به فرد شناسایی می‌کنند. این کمی پیچیده به نظر می‌رسد، پس بیایید به یک مثال نگاه کنیم. اگر یک متریک برای درخواست‌های HTTP داشتید که بر اساس مسیر تقسیم شده بود، ممکن است مانند گرافیت (Graphite) رایج، سعی کنید مسیر را در نام متریک قرار دهید:

```
http_requests_login_total

http_requests_logout_total

http_requests_adduser_total

http_requests_comment_total

http_requests_view_total
```

کار با این متریک‌ها در PromQL برای شما دشوار خواهد بود. برای محاسبه مجموع درخواست‌ها، باید یا تمام مسیرهای HTTP ممکن را بدانید یا نوعی تطبیق (matching) بالقوه پرهزینه را در تمام نام‌های متریک انجام دهید. بر این اساس، این یک الگوی نامناسب است که باید از آن اجتناب کنید. در عوض، برای رسیدگی به این مورد استفاده رایج، پرومتئوس ‏label‌ها را دارد. در مثال قبلی، می‌توانید از ‏label مسیر (path ‏label) استفاده کنید:

```
http_requests_total{path="/login"}

http_requests_total{path="/logout"}

http_requests_total{path="/adduser"}

http_requests_total{path="/comment"}

http_requests_total{path="/view"}
```

سپس می‌توانید با متریک `http_requests_total` با تمام ‏label‌های مسیر آن، به عنوان یک واحد کار کنید. با PromQL می‌توانید نرخ کلی درخواست‌های تجمیع شده، نرخ فقط یکی از مسیرها یا نسبت هر درخواست به کل را بدست آورید.

همچنین می‌توانید متریک‌هایی با بیش از یک ‏label داشته باشید. ‏label‌ها ترتیب ندارند، بنابراین می‌توانید بر اساس هر ‏label معین، در حالی که بقیه را نادیده می‌گیرید، یا حتی بر اساس چندین ‏label به طور همزمان، تجمیع کنید.

### ‏label‌های Instrumentation و Target

‏label‌ها از دو منبع می‌آیند: ‏label‌های ابزار دقیق (Instrumentation ‏labels) و ‏label‌های هدف (Target ‏labels). وقتی در PromQL کار می‌کنید، تفاوتی بین این دو وجود ندارد، اما برای بهره‌مندی حداکثری از ‏label‌ها، تمایز بین آن‌ها مهم است.

‏label‌های ابزار دقیق، همانطور که از نامشان پیداست، از ابزار دقیق شما می‌آیند. آن‌ها در مورد چیزهایی هستند که در داخل برنامه یا کتابخانه شما شناخته شده‌اند، مانند نوع درخواست‌های HTTP که دریافت می‌کند، با کدام پایگاه‌های داده صحبت می‌کند و سایر جزئیات داخلی.

‏label‌های هدف، یک هدف نظارتی خاص را شناسایی می‌کنند؛ یعنی هدفی که پرومتئوس آن را جمع‌آوری می‌کند. ‏label هدف بیشتر به معماری شما مربوط می‌شود و ممکن است شامل این باشد که کدام برنامه است، در کدام مرکز داده قرار دارد، در محیط توسعه یا تولید است، کدام تیم مالک آن است و البته دقیقاً کدام نمونه از برنامه است. ‏label‌های هدف توسط پرومتئوس به عنوان بخشی از فرآیند جمع‌آوری متریک‌ها پیوست می‌شوند.

سرورهای مختلف پرومتئوس که توسط تیم‌های مختلف اجرا می‌شوند، ممکن است دیدگاه‌های متفاوتی در مورد اینکه "تیم"، "منطقه" یا "سرویس" چیست، داشته باشند، بنابراین یک برنامه ابزار دقیق نباید سعی کند چنین ‏label‌هایی را خودش ارائه دهد. بر این اساس، هیچ ویژگی‌ای در کتابخانه‌های client برای افزودن ‏label‌ها در تمام متریک‌های یک هدف پیدا نخواهید کرد. ‏label‌های هدف از service discovery و ‏label‌گذاری مجدد (relabling) می‌آیند.

+++++++



### ابزار دقیق (Instrumentation)

بیایید مثالی را برای استفاده از ‏label گسترش دهیم. در مثال ۱، می‌توانید `‏labelnames=['path']` را در تعریف ببینید، که نشان می‌دهد متریک شما یک ‏label به نام `path` دارد. هنگام استفاده از متریک در ابزار دقیق، باید یک فراخوانی به متد `‏labels` با آرگومان برای مقدار ‏label اضافه کنید.

مثال ۱. یک برنامه پایتون که از ‏label برای یک متریک شمارنده (counter) استفاده می‌کند.



```Python
import http.server
from prometheus_client import start_http_server, Counter

REQUESTS = Counter('hello_worlds_total','Hello Worlds requested.',
‏labelnames=['path'])

class MyHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        REQUESTS.‏labels(self.path).inc()
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"Hello World")

if __name__ == "__main__":
    start_http_server(8000)
    server = http.server.HTTPServer(('localhost', 8001), MyHandler)
    server.serve_forever()
```

اگر از `http://localhost:8001/` و `http://localhost:8001/foo` بازدید کنید، در صفحه `/metrics` در `http://localhost:8000/metrics`، سری‌های زمانی را برای هر یک از مسیرها خواهید دید:

```
# HELP hello_worlds_total Hello Worlds requested.
# TYPE hello_worlds_total counter
hello_worlds_total{path="/favicon.ico"} 6.0
hello_worlds_total{path="/"} 4.0
hello_worlds_total{path="/foo"} 1.0
```

نام‌های ‏label از نظر کاراکترهایی که می‌توانید استفاده کنید، محدود هستند. آن‌ها باید با یک حرف (a-z یا A-Z) شروع شوند و با حروف، اعداد و زیرخط‌ها دنبال شوند. این همانند نام‌های متریک است، با این تفاوت که کولون (:) ندارد.

بر خلاف نام‌های متریک، نام‌های ‏label عموماً فضای نام (namespace) ندارند. با این حال، هنگام تعریف ‏label‌های ابزار دقیق، باید مراقب باشید تا از ‏label‌هایی که احتمالاً به عنوان ‏label‌های هدف استفاده می‌شوند، مانند `env`، `cluster`، `service`، `team`، `zone` و `region`، اجتناب کنید. همچنین توصیه می‌کنیم از `type` به عنوان نام ‏label اجتناب کنید، زیرا بسیار عمومی است. قرارداد نام‌گذاری برای نام‌های ‏label، snake case است.

نام‌های ‏label `instance` و `job` به طور بومی توسط پرومتئوس استفاده می‌شوند، بنابراین ما آن‌ها را نیز توصیه نمی‌کنیم، زیرا با ‏label‌های هدف تداخل پیدا می‌کنند. مقادیر ‏label می‌توانند هر کاراکتر UTF-8 باشند. همچنین می‌توانید یک مقدار ‏label خالی داشته باشید، اما این می‌تواند در سرور پرومتئوس کمی گیج‌کننده باشد، زیرا در نگاه اول، شبیه به نداشتن آن ‏label به نظر می‌رسد.

---

#### ‏label‌های رزرو شده و `__name__`

‏label‌ها می‌توانند با زیرخط شروع شوند، اما باید از چنین ‏label‌هایی اجتناب کنید. نام‌های ‏labelی که با دو زیرخط (`__`) شروع می‌شوند، رزرو شده هستند.

در Prometheus، برخی از **label**‌ها به صورت رزرو شده (Reserved) هستند و معانی خاصی دارند. این label‌ها معمولاً توسط سیستم یا client libraryها استفاده می‌شوند و بهتر است از استفادهٔ دلخواه از آنها خودداری کنید. در ادامه برخی از مهم‌ترین label‌های رزرو شده در Prometheus آورده شده است:

### ‏**1. Label‌های عمومی رزرو شده**
‏- **`job`**: نام شغل (Job) که متریک را تولید می‌کند (مثلاً `api-server`).
‏- **`instance`**: شناسهٔ نمونه (Instance) که متریک از آن جمع‌آوری شده است (معمولاً به صورت `host:port`).

### ‏**2. Label‌های مربوط به متادیتا**
‏- **`__meta_`**: این label‌ها توسط **Service Discovery** استفاده می‌شوند و اطلاعاتی دربارهٔ منبع کشف سرویس ارائه می‌دهند (مثلاً `__meta_kubernetes_pod_name` در کشف سرویس Kubernetes).
‏- **`__address__`**: آدرس هدف (Target) که باید اسکرپ شود (معمولاً `host:port`).
‏- **`__scheme__`**: پروتکل مورد استفاده برای اسکرپ (`http` یا `https`).
‏- **`__metrics_path__`**: مسیر endpoint متریک‌ها (پیش‌فرض `/metrics`).
‏- **`__param_<name>`**: پارامترهای پرس‌وجوی HTTP که به endpoint اسکرپ اضافه می‌شوند.

‏### **3. Label‌های موقت (در حین پردازش)**
‏- **`__name__`**: نام متریک (مثلاً `http_requests_total`).
‏- **`__tmp_*`**: این label‌ها موقت هستند و در پردازش نهایی حذف می‌شوند.

‏### **4. Label‌های مربوط به Relabeling**
‏- **`__relabel__*`**: در برخی تنظیمات relabeling استفاده می‌شوند.

### **نکات مهم:**
- **هر label که با `__` (دو underline) شروع و پایان می‌یابد، به صورت داخلی استفاده می‌شود** و معمولاً پس از پردازش حذف می‌شود.
- **استفاده از label‌های رزرو شده برای مقاصد دلخواه ممکن است باعث رفتار غیرمنتظره شود**.
- در **Alertmanager** نیز برخی label‌ها مانند `alertname` رزرو شده هستند.

اگر قصد اضافه کردن label دلخواه دارید، بهتر است از نام‌هایی استفاده کنید که با `__` شروع و پایان نمی‌یابند تا با label‌های سیستمی تداخل نداشته باشند.




در نهایت در داخل پرومتئوس، نام متریک فقط یک ‏label دیگر به نام `__name__` است. عبارت `up` یک مدل نحوی (syntactic sugar) برای ` {name__="upــ"} ` است و همچنین معناشناسی خاصی با عملگرهای PromQL وجود دارد، همانطور که در "تطبیق برداری (Vector Matching)" بحث شده است.

---

در **Prometheus**، مفهوم **"Vector Matching"** (تطبیق بردارها) به روشی اشاره دارد که دو بردار (vectors) با هم مقایسه یا ترکیب میشوند هنگام انجام عملیات پرسوجو (query). این موضوع زمانی مهم میشود که میخواهید دو مجموعه داده (مثلاً دو بردار از متریکها) را بر اساس ‏labelهایشان با هم تطبیق دهید.

### انواع **Vector Matching** در Prometheus:
۱. **One-to-One Matching** (تطبیق یک به یک):  
   - هر نمونه در یک بردار با نمونه متناظر در بردار دیگر مطابقت داده میشود.  
   - از کلیدواژه `ignoring` برای نادیده گرفتن برخی ‏labelها یا `on` برای تطبیق فقط روی ‏labelهای خاص استفاده میشود.  

   **مثال:**  
   ```promql
   metric1 + on(instance) metric2
   ```
   (فقط ‏label `instance` برای تطبیق استفاده میشود.)

۲. **Many-to-One / One-to-Many Matching** (تطبیق چند به یک یا یک به چند):  
   - یک طرف عملیات (بردار) میتواند چندین نمونه با ‏labelهای یکسان داشته باشد.  
   - از کلیدواژه `group_left` یا `group_right` برای مشخص کردن جهت تطبیق استفاده میشود.  

   **مثال:**  
   ```promql
   metric1 * on(instance) group_left(service) metric2
   ```
   (در اینجا، `metric2` ممکن است چندین مقدار برای یک `instance` داشته باشد، و `group_left` مشخص میکند که ‏label `service` از `metric2` حفظ شود.)

### کاربردهای رایج:
- ترکیب متریکهای مختلف با ‏labelهای مشترک (مثلاً جمع کردن درخواستها و خطاها برای محاسبه نرخ خطا).  
- مقایسه دادهها از دو منبع متفاوت (مثلاً مقایسه درخواستهای ورودی با خروجی).  

### نکته مهم:
- اگر ‏labelها بهدرستی تطبیق داده نشوند، ممکن است نتایج نادرست یا خالی برگردانده شود.  
- برای اشکالزدایی، میتوانید از توابع مثل `‏label_join()` یا `‏label_replace()` برای اصلاح ‏labelها استفاده کنید.  

اگر مثال یا سناریوی خاصی مدنظر دارید، خوشحال میشوم کمک کنم!

---

## متریک (Metric)

همانطور که ممکن است متوجه شده باشید، کلمه "متریک" کمی مبهم است و بسته به زمینه، معانی مختلفی دارد. می‌تواند به یک خانواده متریک (metric family)، یک child (child) یا یک سری زمانی (time series) اشاره کند:

```
# HELP latency_seconds Latency in seconds.
# TYPE latency_seconds summary
latency_seconds_sum{path="/foo"} 1.0
latency_seconds_count{path="/foo"} 2.0
latency_seconds_sum{path="/bar"} 3.0
latency_seconds_count{path="/bar"} 4.0
```

‏`latency_seconds_sum{path="/bar"}` یک سری زمانی است که با نام و ‏label‌ها متمایز می‌شود. این همان چیزی است که PromQL با آن کار می‌کند.

‏`latency_seconds{path="/bar"}` یک child است و مقداری است که مقدار بازگشتی `‏labels()` در کلاینت پایتون نشان می‌دهد.
برای یک summary، هم سری‌های زمانی `_sum` و هم `_count` را با آن ‏label‌ها شامل می‌شود.

‏`latency_seconds` یک خانواده متریک است. این فقط نام متریک و نوع مرتبط آن است. این تعریف متریک هنگام استفاده از یک کتابخانه کلاینت است.
برای یک gauge بدون ‏label، خانواده متریک، child و سری زمانی یکسان هستند.

---

###  بررسی ‏label‌های متعدد

هنگام تعریف یک متریک می‌توانید هر تعداد ‏label را مشخص کنید و سپس مقادیر را به همان ترتیب در فراخوانی `‏labels` قرار دهید (مثال ۲).

مثال ۲. `hello_worlds_total` دارای ‏label‌های `path` و `method` است.



```Python
REQUESTS = Counter('hello_worlds_total',
'Hello Worlds requested.',
‏labelnames=['path', 'method'])

class MyHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        REQUESTS.‏labels(self.path, self.command).inc()
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"Hello World")
```

پایتون و گو (Go) همچنین به شما اجازه می‌دهند یک map با هر دو نام و مقدار ‏label ارائه دهید، اگرچه نام‌های ‏label همچنان باید با موارد موجود در تعاریف متریک مطابقت داشته باشند. این می‌تواند مخلوط کردن ترتیب آرگومان‌های شما را دشوارتر کند، اما اگر این یک خطر واقعی است، ممکن است ‏label‌های زیادی داشته باشید.

داشتن نام‌های ‏label متغیر برای یک متریک امکان‌پذیر نیست و کتابخانه‌های کلاینت از آن جلوگیری می‌کنند. هنگام کار با متریک‌ها، مهم است که بدانید چه ‏label‌هایی در حال استفاده هستند، بنابراین هنگام انجام ابزار دقیق مستقیم باید نام‌های ‏label خود را از قبل بدانید. اگر ‏label‌های خود را نمی‌دانید، احتمالاً به جای آن، یک ابزار نظارت مبتنی بر لاگ (logs-based monitoring tool) برای آن مورد استفاده خاص نیاز دارید.

ابزارهای **Logs-Based Monitoring** (مانند **Loki**، **ELK Stack**، **Graylog** و ...) برای جمع‌آوری، ذخیره‌سازی، تحلیل و نظارت بر **لاگ‌های سیستم‌ها و برنامه‌ها** استفاده می‌شوند. این ابزارها به جای متریک‌های عددی (مانند Prometheus)، روی **تحلیل متن لاگ‌ها** تمرکز دارند و کمک می‌کنند تا مشکلات عملیاتی، خطاها و الگوهای رفتاری سیستم را شناسایی کنید.



++++++++++


## child (Child)



**برچسب‌های child در پرومتئوس** به سری‌های زمانی خاصی اشاره دارند که هنگام مرتبط شدن یک متریک با یک یا چند برچسب ایجاد می‌شوند.

در اینجا یک تفکیک آورده شده است:

**۱. متریک‌ها و برچسب‌ها:**

- **متریک:** نام یک متریک، کمیت قابل اندازه‌گیری را توصیف می‌کند (به عنوان مثال، `http_requests_total`، `cpu_usage_seconds_total`).
- **برچسب‌ها:** برچسب‌ها جفت‌های کلید-مقدار هستند که **ابعادی** را به یک متریک اضافه می‌کنند و به شما امکان می‌دهند داده‌ها را تفکیک و دسته‌بندی کنید. برای مثال، متریک `http_requests_total` ممکن است برچسب‌هایی مانند `method="GET"`، `path="/api/users"` و `instance="server-1"` داشته باشد.

**۲. سری‌های زمانی child:**

- هر ترکیب منحصربه‌فرد از مقادیر برچسب برای یک متریک معین، یک **سری زمانی** جداگانه ایجاد می‌کند. این سری‌های زمانی منفرد اغلب به عنوان "child" متریک اصلی شناخته می‌شوند.

**مثال:**

فرض کنید یک متریک شمارنده به نام `http_requests_total` با برچسب `method` دارید. اگر برنامه شما درخواست‌های `GET` و `POST` را دریافت کند، پرومتئوس دو سری زمانی جداگانه را ذخیره می‌کند:

- `http_requests_total{method="GET"}`
- `http_requests_total{method="POST"}`

هر یک از این‌ها یک "child" از متریک `http_requests_total` است که توسط مقدار برچسب `method` از هم متمایز می‌شوند.

**چرا برچسب‌های child مهم هستند؟**

- **مانیتورینگ دقیق:** برچسب‌ها به شما امکان می‌دهند متریک‌ها را به دسته‌های خاص تقسیم کنید و بینش‌های بسیار دقیق‌تری نسبت به یک عدد کلی ارائه دهید. شما می‌توانید نرخ درخواست‌ها را بر اساس متد HTTP، نرخ خطاها را بر اساس سرویس، میزان استفاده از CPU را بر اساس نمونه و غیره تجزیه و تحلیل کنید.
- **پرس و جوی قدرتمند (PromQL):** زبان پرس و جوی پرومتئوس، PromQL، به شدت به برچسب‌ها برای فیلتر کردن، تجمیع و انجام محاسبات بر روی زیرمجموعه‌های خاصی از متریک‌های شما متکی است.
- **هشداردهی هدفمند:** می‌توانید هشدارهایی ایجاد کنید که بر اساس ترکیبات خاصی از برچسب‌ها فعال می‌شوند و امکان اعلان‌های دقیق‌تر و قابل اقدام‌تری را فراهم می‌کنند. برای مثال، ممکن است بخواهید فقط زمانی هشدار دهید که نرخ خطا برای یک نقطه پایانی API خاص بالا باشد.
- **چندبعدی بودن:** برچسب‌ها ابعاد را به متریک‌های شما معرفی می‌کنند و داده‌های مانیتورینگ شما را بسیار غنی‌تر و برای تجزیه و تحلیل و عیب‌یابی مفیدتر می‌سازند.

**در زمینه کتابخانه‌های کلاینت پرومتئوس:**

هنگامی که برنامه خود را با یک کتابخانه کلاینت پرومتئوس (به عنوان مثال، برای پایتون، جاوا، گو) ابزاربندی می‌کنید، اغلب با متریک‌ها به گونه‌ای تعامل دارید که شامل تعیین مقادیر برچسب می‌شود. سپس کتابخانه کلاینت ایجاد و به‌روزرسانی سری‌های زمانی child مربوطه را مدیریت می‌کند.

برای مثال، در برخی از کتابخانه‌های کلاینت، ممکن است الگویی مشابه زیر داشته باشید:



```Python
requests_total = Counter('http_requests_total', 'Total number of HTTP requests', ['method', 'path'])
requests_total.‏labels(method='GET', path='/api/users').inc()
requests_total.‏labels(method='POST', path='/api/users').inc()
```

در اینجا، `requests_total.‏labels(...)` یک شیء "child" خاص برای مقادیر برچسب داده شده برمی‌گرداند، و سپس می‌توانید بر روی آن سری زمانی خاص عمل کنید.

**نکته کلیدی:**

برچسب‌های child، سری‌های زمانی منفردی هستند که در نتیجه اعمال برچسب‌ها به یک متریک پرومتئوس ایجاد می‌شوند. آن‌ها اساسی برای مدل داده چندبعدی پرومتئوس هستند و مانیتورینگ، پرس و جو و هشداردهی قدرتمند و دقیق را امکان‌پذیر می‌کنند. درک نحوه استفاده مؤثر از برچسب‌ها برای بهره‌برداری کامل از قابلیت‌های پرومتئوس بسیار مهم است.

----

مقداری که توسط متد `‏labels` در پایتون به شما بازگردانده می‌شود، child  نامیده می‌شود. می‌توانید این child را برای استفاده بعدی ذخیره کنید، که شما را از جستجوی آن در هر رویداد ابزار دقیق (instrumentation event) نجات می‌دهد و در کدهای حساس به عملکرد که صدها هزار بار در ثانیه فراخوانی می‌شوند، در زمان صرفه‌جویی می‌کند. در بنچمارک‌های کلاینت جاوا، متوجه شدیم که بدون رقابت، جستجوی child  حدود 30 نانوثانیه طول کشید، در حالی که inc واقعی 12 نانوثانیه طول کشید.

(به همین دلیل، شما باید در برابر وسوسه نوشتن یک facade یا wrapper در اطراف یک کتابخانه کلاینت پرومتئوس که نام متریک را به عنوان آرگومان می‌گیرد، مقاومت کنید، زیرا این کار نیز هزینه جستجو را به همراه خواهد داشت. داشتن یک متغیر در سطح فایل برای ردیابی آدرس شی متریک، به جای جستجوی مداوم آن، ارزان‌تر، ساده‌تر و از نظر معنایی بهتر است.)

یک الگوی رایج، زمانی که یک شیء فقط به یک child از یک متریک اشاره می‌کند، فراخوانی `‏labels` یک بار و سپس ذخیره آن در شیء است، همانطور که در مثال ۳ نشان داده شده است.

مثال ۳. یک کش (cache) ساده پایتون که child را در هر کش نام‌گذاری شده ذخیره می‌کند.



```Python
from prometheus_client import Counter

FETCHES = Counter('cache_fetches_total','Fetches from the cache.',
‏labelnames=['cache'])

class MyCache(object):
    def __init__(self, name):
        self._fetches = FETCHES.‏labels(name)
        self._cache = {}

    def fetch(self, item):
        self._fetches.inc()
        return self._cache.get(item)

    def store(self, item, value):
        self._cache[item] = value
```

مکان دیگری که با childها روبرو خواهید شد، در مقداردهی اولیه آن‌ها است. childها فقط پس از فراخوانی `‏labels` در صفحه `/metrics` ظاهر می‌شوند. این می‌تواند مشکلاتی را در PromQL ایجاد کند، زیرا کار با سری‌های زمانی که ظاهر و ناپدید می‌شوند، می‌تواند بسیار چالش‌برانگیز باشد. بر این اساس، در صورت امکان، باید childها را در زمان راه‌اندازی مقداردهی اولیه کنید، مانند مثال ۴، اگرچه اگر از الگوی مثال ۳ پیروی کنید، این کار را به صورت ساده‌تری دریافت می‌کنید.

مثال ۴. مقداردهی اولیه child یک متریک در زمان راه‌اندازی برنامه.



```Python
from prometheus_client import Counter

REQUESTS = Counter('http_requests_total',
'HTTP requests.',
‏labelnames=['path'])

REQUESTS.‏labels('/foo')
REQUESTS.‏labels('/bar')
```

هنگام استفاده از دکوراتورهای پایتون، می‌توانید از `‏labels` بدون فراخوانی فوری یک متد در مقدار بازگشتی استفاده کنید، همانطور که در مثال ۵ نشان داده شده است.

مثال ۵. استفاده از دکوراتور با `‏labels` در پایتون.



```Python
from prometheus_client import Summary

LATENCY = Summary('http_requests_latency_seconds',
'HTTP request latency.',
‏labelnames=['path'])

foo = LATENCY.‏labels('/foo')

@foo.time()
def foo_handler(params):
    pass
```

کتابخانه‌های کلاینت معمولاً متدهایی را برای حذف child  از یک متریک ارائه می‌دهند. شما فقط باید استفاده از این‌ها را برای تست‌های واحد (unit tests) در نظر بگیرید. از منظر معنایی PromQL، هنگامی که یک child وجود دارد، باید تا زمانی که فرآیند از بین می‌رود به وجود خود ادامه دهد، در غیر این صورت توابعی مانند `rate` ممکن است نتایج نامطلوبی را برگردانند. این متدها همچنین مقادیر قبلی بازگردانده شده از `‏labels` را نامعتبر می‌کنند.


++++++++




## تجمیع (Aggregating)

اکنون که ابزار دقیق شما با ‏label‌ها پر شده است، بیایید واقعاً از آنها در PromQL استفاده کنیم. ما آینده به جزئیات بیشتری در مورد عملگرهای تجمیع خواهیم پرداخت، اما می‌خواهیم اکنون طعم قدرت ‏label‌ها را به شما نشان دهیم. در مثال زیر، `hello_worlds_total` دارای ‏label‌های `path` و `method` است. از آنجایی که `hello_worlds_total` یک شمارنده (counter) است، ابتدا باید از تابع `rate` استفاده کنید. جدول ۱  یک خروجی احتمالی است که نتایج را برای دو نمونه برنامه با مسیرها و روش‌های HTTP مختلف نشان می‌دهد.

```
جدول 1. خروجی rate(hello_worlds_total[5m])

{job="myjob", instance="localhost:1234", path="/foo", method="GET"} 1

{job="myjob", instance="localhost:1234", path="/foo", method="POST"} 2

{job="myjob", instance="localhost:1234", path="/bar", method="GET"} 4

{job="myjob", instance="localhost:5678", path="/foo", method="GET"} 8

{job="myjob", instance="localhost:5678", path="/foo", method="POST"} 16

{job="myjob", instance="localhost:5678", path="/bar", method="GET"} 32
```

این می‌تواند برای شما کمی دشوار باشد، به خصوص اگر سری‌های زمانی بسیار بیشتری نسبت به این مثال ساده داشته باشید. بیایید با تجمیع ‏label `path` شروع کنیم. شما این کار را با استفاده از تجمیع `sum` انجام می‌دهید، زیرا می‌خواهید نمونه‌ها را با هم جمع کنید. بند `without` نشان می‌دهد که کدام ‏label را می‌خواهید حذف کنید. این عبارت `sum without(path)(rate(hello_worlds_total[5m]))` را به شما می‌دهد که خروجی جدول ۲ را تولید می‌کند.

جدول ۲. خروجی
`sum without(path)(rate(hello_worlds_total[5m]))`

```
{job="myjob", instance="localhost:1234", method="GET"} 5

{job="myjob", instance="localhost:1234", method="POST"} 2

{job="myjob", instance="localhost:5678", method="GET"} 40

{job="myjob", instance="localhost:5678", method="POST"} 16
```

داشتن ده‌ها یا صدها نمونه برای شما غیرمعمول نیست و طبق تجربه ما، نگاه کردن به نمونه‌های فردی در داشبوردها در حدود سه تا پنج نمونه از هم می‌پاشد. می‌توانید بند `without` را برای شامل کردن ‏label `instance` گسترش دهید، که خروجی نشان داده شده در جدول ۳ را ارائه می‌دهد. همانطور که از مقادیر جدول ۱ انتظار دارید، 1 + 4 + 8 + 32 = 45 درخواست در ثانیه برای GET و 2 + 16 = 18 درخواست در ثانیه برای POST است.

جدول ۳. خروجی
`sum without(path, instance)(rate(hello_worlds_total[5m]))`

```
{job="myjob", method="GET"} 45

{job="myjob", method="POST"} 18
```

‏label‌ها به هیچ وجه مرتب نشده‌اند، بنابراین همانطور که می‌توانید `path` را حذف کنید، می‌توانید `method` را نیز حذف کنید، همانطور که در جدول ۴ مشاهده می‌شود.

جدول ۴. خروجی
`sum without(method, instance)(rate(hello_worlds_total[5m]))`

```
{job="myjob", path="/foo"} 27

{job="myjob", path="/bar"} 36
```

همچنین یک بند `by` وجود دارد که فقط ‏label‌هایی را که مشخص می‌کنید نگه می‌دارد. `without` ترجیح داده می‌شود زیرا اگر ‏label‌های اضافی مانند `env` یا `region` در سراسر یک کار وجود داشته باشد، از بین نمی‌روند. این به شما کمک می‌کند وقتی قوانین خود را با دیگران به اشتراک می‌گذارید.

### الگوهای ‏label (‏label Patterns)

پرومتئوس فقط اعداد ممیز شناور 64 بیتی را به عنوان مقادیر سری زمانی پشتیبانی می‌کند، نه هیچ نوع داده دیگری مانند رشته‌ها. اما مقادیر ‏label رشته هستند و موارد استفاده محدود خاصی وجود دارد که در آن استفاده (سوء استفاده) از آنها بدون اینکه خیلی به نظارت مبتنی بر لاگ (logs-based monitoring) نزدیک شویم، اشکالی ندارد.

## شمارش (Enum)

اولین مورد رایج برای رشته‌ها، شمارش‌ها (enums) است. به عنوان مثال، ممکن است منبعی داشته باشید که دقیقاً می‌تواند در یکی از حالت‌های `STARTING`، `RUNNING`، `STOPPING` یا `TERMINATED` باشد.

می‌توانید این را به عنوان یک گیج (gauge) با `STARTING` بودن 0، `RUNNING` بودن 1، `STOPPING` بودن 2 و `TERMINATED` بودن 3 ارائه دهید. اما کار با این در PromQL کمی دشوار است. اعداد 0-3 کمی مبهم هستند و هیچ عبارت واحدی وجود ندارد که بتوانید برای گفتن اینکه منبع شما چه نسبتی از زمان را در `STARTING` گذرانده است، بنویسید.

راه حل این است که یک ‏label برای حالت به گیج اضافه کنید، به طوری که هر حالت بالقوه یک child شود. هنگام ارائه یک مقدار بولی در پرومتئوس، باید از 1 برای درست (true) و 0 برای نادرست (false) استفاده کنید. بر این اساس، یکی از childان مقدار 1 و بقیه 0 را خواهند داشت، که متریک‌هایی مانند مثال 6 را تولید می‌کند.

مثال ۶. یک مثال شمارشگر؛ منبع `blaa` در حالت `RUNNING` است.

```
# HELP gauge The current state of resources.
# TYPE gauge resource_state
resource_state{resource_state="STARTING", resource="blaa"} 0
resource_state{resource_state="RUNNING", resource="blaa"} 1
resource_state{resource_state="STOPPING", resource="blaa"} 0
resource_state{resource_state="TERMINATED", resource="blaa"} 0
```

از آنجا که 0 ها همیشه وجود دارند، عبارت PromQL `avg_over_time(resource_state[1h])` نسبت زمان صرف شده در هر حالت را به شما می‌دهد. همچنین می‌توانید با استفاده از `sum without(resource)(resource_state)` بر اساس `resource_state` تجمیع کنید تا ببینید چند منبع در هر حالت هستند. برای تولید چنین متریک‌هایی، می‌توانید از `set` در یک gauge استفاده کنید، اما این شرایط رقابتی (race conditions) را به همراه خواهد داشت. یک scrape ممکن است بسته به اینکه دقیقاً چه زمانی اتفاق افتاده است، 1 را در صفر یا دو حالت ببیند. شما به نوعی جداسازی نیاز دارید تا gauge در وسط یک به‌روزرسانی ارائه نشود. راه حل این است که از یک جمع‌آورنده سفارشی (custom collector) استفاده کنید، که در «جمع‌آورنده‌های سفارشی» است.
مثال ۷. یک جمع‌آورنده سفارشی برای یک gauge که به عنوان شمارش استفاده می‌شود.



```Python
from threading import Lock

from prometheus_client.core import GaugeMetricFamily, REGISTRY

  

class StateMetric(object):

	def __init__(self):
	
		self._resource_states = {}
		
		self._STATES = ["STARTING", "RUNNING", "STOPPING", "TERMINATED",]
		
		self._mutex = Lock()

  

	def set_state(self, resource, state):
	
		with self._mutex:
	
			self._resource_states[resource] = state
	
	  
	
	def collect(self):
	
		family = GaugeMetricFamily("resource_state", "The current state of resources.", labels=["resource_state", "resource"])
	
	with self._mutex:
	
		for resource, state in self._resource_states.items():
		
			for s in self._STATES:
			
				family.add_metric([s, resource], 1 if s == state else 0)
		
		yield family

sm = StateMetric()
REGISTRY.register(sm)
# Use the StateMetric.
sm.set_state("blaa", "RUNNING")

```

+++++



### اطلاعات (Info)

دومین مورد رایج برای رشته‌ها، متریک‌های اطلاعاتی (info metrics) هستند، که ممکن است به دلایل تاریخی، رویکرد نقش‌های ماشین (machine roles approach) نیز نامیده شوند. متریک‌های اطلاعاتی برای حاشیه‌نویسی‌هایی مانند شماره نسخه و سایر اطلاعات ساخت که پرس‌وجو در مورد آنها مفید است، کاربرد دارند، اما استفاده از آنها به عنوان ‏label‌های هدف منطقی نیست، زیرا ‏label‌های هدف به تمام متریک‌های یک هدف اعمال می‌شوند. قراردادی که پدید آمده است، استفاده از یک گیج (gauge) با مقدار 1 و تمام رشته‌هایی است که می‌خواهید هدف را به عنوان ‏label حاشیه‌نویسی کنید. گیج باید پسوند `_info` داشته باشد. این در حالت زیر با متریک `python_info` نشان داده شد، که هنگام ارائه شدن چیزی شبیه مثال ۸ خواهد بود.

مثال ۸. متریک `python_info` که کلاینت پایتون به طور پیش‌فرض ارائه می‌دهد.

```
# HELP python_info Python platform information
# TYPE python_info gauge
python_info{implementation="CPython", major="3", minor="5", patchlevel="2", version="3.5.2"} 1.0
```

برای تولید این در پایتون، می‌توانید از ابزار دقیق مستقیم (direct instrumentation) یا یک جمع‌آورنده سفارشی (custom collector) استفاده کنید. مثال ۹ مسیر ابزار دقیق مستقیم را طی می‌کند و همچنین از قابلیت ارسال ‏label‌ها به عنوان آرگومان‌های کلیدواژه‌ای با کلاینت پایتون بهره می‌برد.

مثال ۹. یک متریک اطلاعاتی با استفاده از ابزار دقیق مستقیم.



```Python
from prometheus_client import Info

version_info = {
    "implementation": "CPython",
    "major": "3",
    "minor": "5",
    "patchlevel": "2",
    "version": "3.5.2",
}

INFO = Info("my_python", "Python platform information")
INFO.‏labels(version_info)
```

یک متریک اطلاعاتی را می‌توان با استفاده از عملگر ضرب و اصلاح‌کننده `group_left` به هر متریک دیگری پیوند داد. هر عملگری را می‌توان برای پیوند دادن متریک‌ها استفاده کرد، اما از آنجا که مقدار متریک اطلاعاتی 1 است، ضرب مقدار متریک دیگر را تغییر نمی‌دهد.

مقدار 1 توسط نوع متریک استنباط می‌شود، در این مورد Info. برای افزودن ‏label نسخه از `python_info` به تمام متریک‌های `up`، از عبارت PromQL زیر استفاده می‌کنید:

```
up
* on (instance, job) group_left(version)
python_info
```

‏`group_left(version)` نشان می‌دهد که این یک تطابق چند به یک (many-to-one match) است و ‏label نسخه باید از `python_info` به تمام متریک‌های `up` که دارای ‏label‌های `job` و `instance` یکسان هستند، کپی شود. ما `group_left` را با جزئیات بیشتر در "چند به یک و group_left" در فصل‌های آینده  بررسی خواهیم کرد.

با نگاه کردن به این عبارت می‌توانید تشخیص دهید که خروجی دارای ‏label‌های متریک `up`، با یک ‏label نسخه اضافه شده، خواهد بود. افزودن تمام ‏label‌ها از `python_info` امکان‌پذیر نیست، زیرا به طور بالقوه می‌توانید ‏label‌های ناشناخته از هر دو طرف عبارت داشته باشید، که از نظر معنایی قابل اجرا نیست. مهم است که همیشه بدانید چه ‏label‌هایی در حال استفاده هستند.







#### تغییرات ناسازگار و ‏label‌ها (Breaking Changes and ‏labels)

اگر ‏labelی را از ابزار دقیق اضافه یا حذف کنید، همیشه یک تغییر ناسازگار (breaking change) است. حذف یک ‏label، تمایزی را که کاربر ممکن است به آن وابسته بوده باشد، از بین می‌برد. افزودن یک ‏label، تجمیعی را که از بند `without` استفاده می‌کند، خراب می‌کند.

تنها استثنا برای این مورد، متریک‌های اطلاعاتی (info metrics) است. برای آنها، عبارات PromQL به گونه‌ای ساخته می‌شوند که ‏label‌های اضافی مشکلی ایجاد نمی‌کنند، بنابراین افزودن ‏label به متریک‌های اطلاعاتی بی‌خطر است.

---

متریک‌های اطلاعاتی همچنین دارای مقدار 1 هستند، بنابراین محاسبه تعداد سری‌های زمانی که هر مقدار ‏label را دارند با استفاده از `sum` آسان است. تعداد نمونه‌های برنامه که هر نسخه از پایتون را اجرا می‌کنند، `sum by (version)(python_info)` خواهد بود. اگر مقدار دیگری مانند 0 بود، ترکیبی از `sum` و `count` در سلسله مراتب تجمیع شما لازم بود، که هم پیچیده‌تر و هم مستعد خطا خواهد بود.

### چه زمانی از ‏label‌ها استفاده کنیم

برای اینکه یک متریک مفید باشد، باید بتوانید آن را به نوعی تجمیع کنید. قانون سرانگشتی این است که جمع یا میانگین‌گیری در یک متریک باید نتیجه‌ای معنادار تولید کند. برای شمارنده درخواست‌های HTTP که بر اساس مسیر و روش تقسیم شده‌اند، جمع، تعداد کل درخواست‌ها است. برای یک صف (queue)، ترکیب آیتم‌های موجود در آن و محدودیت اندازه آن در یک متریک منطقی نیست، زیرا نه جمع و نه میانگین‌گیری آن چیزی مفید تولید نمی‌کند.

یک نشانه مبنی بر اینکه یک ‏label ابزار دقیق مفید نیست، این است که هر زمان که از متریک استفاده می‌کنید، نیاز به مشخص کردن آن ‏label در PromQL پیدا می‌کنید. در چنین مواردی، احتمالاً باید ‏label را به جای آن به نام متریک منتقل کنید.

مورد دیگری که باید از آن اجتناب کرد، داشتن یک سری زمانی است که مجموع بقیه متریک باشد، مانند:

```
some_metric{‏label="foo"} 7
some_metric{‏label="bar"} 13
some_metric{‏label="total"} 20
```

یا:

```
some_metric{‏label="foo"} 7
some_metric{‏label="bar"} 13
some_metric{} 20
```

هر دوی اینها تجمیع با `sum` را در PromQL خراب می‌کنند، زیرا شما دو بار شمارش می‌کنید. PromQL قبلاً توانایی محاسبه این تجمیع را به شما ارائه می‌دهد.

---

#### استثنای جدول (Table Exception)

 احتمالاً متوجه شده‌اید که summary metric quantiles قانون مربوط به معنادار بودن جمع یا میانگین را نقض می‌کنند، زیرا نمی‌توانید روی کوانتیل‌ها ریاضی انجام دهید. این همان چیزی است که ما آن را استثنای جدول (Table Exception) می‌نامیم، جایی که حتی اگر نمی‌توانید روی یک متریک عملیات ریاضی انجام دهید، استفاده (سوء استفاده) از یک ‏label بهتر از این است که مجبور به انجام regexها در برابر نام متریک باشید. regexها در نام‌های متریک بوی بسیار بدی دارند و هرگز نباید در نمودارها یا هشدارها استفاده شوند.

برای شما، این استثنا فقط هنگام نوشتن صادرکننده‌ها (exporters) پیش می‌آید، نه برای ابزار دقیق مستقیم. به عنوان مثال، ممکن است ترکیبی ناشناخته از ولتاژها، سرعت فن‌ها و دماها از سنسورهای سخت‌افزاری داشته باشید. از آنجا که اطلاعات لازم برای تقسیم آنها به متریک‌های مختلف را ندارید، تنها کاری که واقعاً می‌توانید انجام دهید این است که همه آنها را در یک متریک قرار دهید و تفسیر آن را به عهده شخصی بگذارید که متریک را مصرف می‌کند.



---

نام‌های ‏label مورد استفاده برای یک متریک نباید در طول عمر فرآیند برنامه تغییر کنند. اگر احساس نیاز به این کار دارید، احتمالاً یک راه حل نظارت مبتنی بر لاگ (logs-based monitoring solution) برای آن مورد استفاده خاص می‌خواهید.



+++++++++++++



### کاردینالیتی (Cardinality)

هنگام استفاده از ‏label‌ها زیاده‌روی نکنید. monitoring وسیله‌ای برای رسیدن به هدفی است، بنابراین سری‌های زمانی بیشتر و نظارت بیشتر همیشه بهتر نیستند. برای یک سیستم monitoring، چه خودتان آن را در محل اجرا کنید و چه به شرکتی پول بدهید تا آن را برای شما در ابر اجرا کند، هر سری زمانی و نمونه هم هزینه منابع و هم هزینه انسانی از نظر عملیات مداوم برای حفظ و اجرای سیستم نظارت دارد. در این زمینه می‌خواهیم در مورد کاردینالیتی صحبت کنیم، که در پرومتئوس برابر با تعداد سری‌های زمانی شما است. اگر پرومتئوس شما برای مدیریت، مثلاً ۱۰ میلیون سری زمانی، تهیه شده است، چگونه می‌توانید از آنها به بهترین شکل استفاده کنید؟ در چه نقطه‌ای موارد استفاده خاص را به جای آن به نظارت مبتنی بر لاگ (logs-based monitoring) منتقل می‌کنید؟ روشی که ما به آن نگاه می‌کنیم این است که فرض کنیم کسی که کد شما را اجرا می‌کند، یک تنظیمات بزرگ با هزار نمونه از یک برنامه خاص دارد. افزودن یک متریک شمارنده ساده به یک زیرسیستم مبهم، هزار سری زمانی به پرومتئوس شما اضافه می‌کند، که 0.01٪ از ظرفیت آن است. این اساساً رایگان است و ممکن است روزی به شما در اشکال‌زدایی یک مشکل عجیب کمک کند. در سراسر برنامه و کتابخانه‌های آن، ممکن است صد مورد از این متریک‌های مبهم داشته باشید، که در مجموع 1٪ از ظرفیت نظارت شما را تشکیل می‌دهند و حتی با توجه به نادر بودن استفاده شما از هر یک از آنها، هنوز بسیار ارزان است. اکنون یک متریک با ‏labelی با ۱۰ مقدار را در نظر بگیرید که علاوه بر آن یک هیستوگرام بود که به طور پیش‌فرض ۱۲ سری زمانی دارد. این ۱۲۰ سری یا ۱.۲٪ از ظرفیت نظارت شما است. اینکه این یک معامله خوب است، کمتر واضح است. ممکن است داشتن چند مورد از اینها خوب باشد، اما همچنین می‌توانید به جای آن به یک متریک summery بدون کوانتیل (quantile-less summary metric) تغییر دهید. مرحله بعدی جایی است که اوضاع کمی مشکل‌ساز می‌شود. اگر یک ‏label از قبل کاردینالیتی ۱۰ داشته باشد، احتمال زیادی وجود دارد که با معرفی ویژگی‌های جدید به برنامه شما، فقط با گذشت زمان افزایش یابد. کاردینالیتی ۱۰ امروز ممکن است سال آینده ۱۵ و ۲۰۰ ممکن است به 3۳۰۰ تغییر کند. افزایش ترافیک کاربران معمولاً به معنای نمونه‌های برنامه بیشتر است. اگر بیش از یکی از این ‏label‌های در حال گسترش را در یک متریک داشته باشید، تأثیر آن تشدید می‌شود و منجر به انفجار ترکیبی سری‌های زمانی می‌شود. و این فقط یکی از برنامه‌های همیشه در حال رشد است که پرومتئوس در حال نظارت بر آن است. به این ترتیب کاردینالیتی می‌تواند به طور پنهانی به شما نزدیک شود. معمولاً آشکار است که آدرس‌های ایمیل، مشتریان و آدرس‌های IP به دلایل کاردینالیتی انتخاب‌های ضعیفی برای مقادیر ‏label هستند. کمتر واضح است که مسیر HTTP مشکل‌ساز خواهد بود. با توجه به اینکه متریک درخواست HTTP به طور منظم استفاده می‌شود، حذف ‏label‌ها از آن، تغییر از هیستوگرام یا حتی کاهش تعداد سطل‌ها در هیستوگرام می‌تواند از نظر سیاسی چالش‌برانگیز باشد. قانون سرانگشتی که ما استفاده می‌کنیم این است که کاردینالیتی یک متریک دلخواه در یک نمونه برنامه باید زیر 10 نگه داشته شود. همچنین خوب است که چند متریک داشته باشیم که کاردینالیتی حدود 100 دارند، اما باید آماده کاهش کاردینالیتی متریک و تکیه بر لاگ‌ها با افزایش کاردینالیتی باشید.

چند متریک با کاردینالیتی صد در هر پرومتئوس، هزار نمونه‌ای را فرض می‌کند که چنین کاردینالیتی را ارائه می‌دهند. اگر 100٪ مطمئن هستید که به این اعداد نخواهید رسید، مانند برنامه‌هایی که دقیقاً یک مورد از آنها را اجرا خواهید کرد، می‌توانید قانون سرانگشتی را بر این اساس تنظیم کنید.

یک الگوی رایج وجود دارد که هنگام معرفی پرومتئوس به یک سازمان دیده‌ایم. معمولاً سازمان‌ها هنگام معرفی پرومتئوس منحنی یادگیری را تجربه می‌کنند. در نقطه‌ای کلیک می‌کند و آنها شروع به درک قدرت ‏label‌ها می‌کنند. معمولاً به سرعت دنبال می‌شود که پرومتئوس شما به دلیل کاردینالیتی ‏label، مشکلات عملکردی دارد. توصیه می‌کنیم در مورد محدودیت‌های کاردینالیتی با کاربران خود در اوایل کار صحبت کنید و همچنین استفاده از `sample_limit` را به عنوان یک شیر اطمینان اضطراری در نظر بگیرید. ۱۰ متریک بزرگ در یک پرومتئوس معمولاً بیش از نیمی از مصرف منابع آن را تشکیل می‌دهند و این تقریباً همیشه به دلیل کاردینالیتی ‏label است. گاهی اوقات این سردرگمی وجود دارد که اگر مشکل تعداد مقادیر ‏label است، آیا انتقال مقدار ‏label به نام متریک مشکل را حل نمی‌کند؟ از آنجا که محدودیت منابع اساسی در واقع کاردینالیتی سری‌های زمانی است (که به دلیل مقادیر ‏label آشکار می‌شود)، انتقال مقادیر ‏label به نام متریک کاردینالیتی را تغییر نمی‌دهد، فقط استفاده از متریک‌ها را دشوارتر می‌کند. اکنون که می‌توانید متریک‌ها را به برنامه‌های خود اضافه کنید و برخی از عبارات اساسی PromQL را می‌دانید، در فصل بعد به شما نشان خواهیم داد که چگونه می‌توانید داشبوردها را در Grafana ایجاد کنید.


------

در **پروتئوس (Prometheus)**، مفهوم **Cardinality** (کاردینالیتی) به تعداد **ترکیب‌های منحصر به فرد (unique combinations)** از مقادیر **‏label‌ها (‏labels)** در یک **متریک (metric)** اشاره می‌کند. این مفهوم به‌ویژه در زمینه **مانیتورینگ و ذخیره‌سازی داده‌های سری‌زمانی (time series data)** اهمیت زیادی دارد.

### 🔹 **کاردینالیتی در Prometheus چگونه کار می‌کند؟**
هر **متریک** در Prometheus می‌تواند چندین **‏label (‏label)** داشته باشد. برای مثال:
```promql
http_requests_total{method="GET", endpoint="/api", status="200"}
```
در اینجا، `http_requests_total` یک متریک است و `method`، `endpoint` و `status` ‏label‌های آن هستند.  

- **هر ترکیب منحصر به فرد از مقادیر ‏label‌ها** یک **سری زمانی (time series)** جدید ایجاد می‌کند.  
- **کاردینالیتی** این متریک، تعداد کل این ترکیب‌های منحصر به فرد است.  

📌 **مثال:**  
اگر `http_requests_total` دارای مقادیر زیر باشد:
- `{method="GET", endpoint="/api", status="200"}`  
- `{method="GET", endpoint="/api", status="404"}`  
- `{method="POST", endpoint="/login", status="200"}`  

✅ **کاردینالیتی این متریک = 3** (چون ۳ ترکیب منحصر به فرد وجود دارد).

---

### 🔥 **چرا کاردینالیتی مهم است؟**
در Prometheus هر سری زمانی را به‌صورت جداگانه ذخیره و پردازش می‌کند. اگر کاردینالیتی خیلی بالا برود، مشکلات زیر پیش می‌آید:
1. **مصرف حافظه (RAM) افزایش می‌یابد** (هر سری زمانی جدید حافظه مصرف می‌کند).  
2. **پرفورمنس Prometheus کاهش می‌یابد** (پردازش کوئری‌ها کند می‌شود).  
3. **ذخیره‌سازی داده‌ها (Storage) سریع‌تر پر می‌شود**.  

📉 **مثال خطرناک:**  
اگر یک ‏label مانند `user_id` داشته باشید که مقادیر نامحدودی دارد (مثلاً `user_id="123"`, `user_id="456"`, ...)، کاردینالیتی متریک شما می‌تواند **به میلیون‌ها برسد** و Prometheus را دچار **کرش** کند!

---

### 🛑 **چگونه کاردینالیتی را مدیریت کنیم؟**
1. **از ‏label‌هایی با مقادیر محدود استفاده کنید** (مثلاً `status="200"` به جای `user_id="..."`).  
2. **از توابعی مثل `rate()` و `sum()` برای کاهش حجم داده‌ها استفاده کنید**.  
3. **از `recording rules` برای پیش‌پردازش داده‌ها با کاردینالیتی بالا استفاده کنید**.  
4. **اگر نیاز به ذخیره‌سازی داده‌های پرکاردینالیتی دارید، از سیستم‌هایی مثل **VictoriaMetrics** یا **Thanos** استفاده کنید که برای این سناریوها بهینه‌تر هستند**.  

---
### ✅ **جمع‌بندی**
- **کاردینالیتی = تعداد ترکیب‌های منحصر به فرد مقادیر ‏label‌ها در یک متریک**.  
- **کاردینالیتی بالا = مصرف منابع بیشتر + کاهش عملکرد Prometheus**.  
- **برای جلوگیری از مشکلات، ‏label‌های با مقادیر نامحدود (مثل ID کاربران) را در متریک‌ها استفاده نکنید**.  




-----


