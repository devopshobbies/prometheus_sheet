

برچسب‌ها (Labels) بخش کلیدی پرومتئوس هستند و یکی از عواملی که آن را قدرتمند می‌کند. در این فصل، شما یاد خواهید گرفت که برچسب‌ها چه هستند، از کجا می‌آیند و چگونه می‌توانید آن‌ها را به متریک‌های خود اضافه کنید.

### برچسب‌ها چه هستند؟

برچسب‌ها، جفت‌های کلید-مقدار مرتبط با سری‌های زمانی هستند که علاوه بر نام متریک، آن‌ها را به طور منحصر به فرد شناسایی می‌کنند. این کمی پیچیده به نظر می‌رسد، پس بیایید به یک مثال نگاه کنیم. اگر یک متریک برای درخواست‌های HTTP داشتید که بر اساس مسیر تقسیم شده بود، ممکن است مانند گرافیت (Graphite) رایج، سعی کنید مسیر را در نام متریک قرار دهید:

```
http_requests_login_total

http_requests_logout_total

http_requests_adduser_total

http_requests_comment_total

http_requests_view_total
```

کار با این متریک‌ها در PromQL برای شما دشوار خواهد بود. برای محاسبه مجموع درخواست‌ها، باید یا تمام مسیرهای HTTP ممکن را بدانید یا نوعی تطبیق (matching) بالقوه پرهزینه را در تمام نام‌های متریک انجام دهید. بر این اساس، این یک الگوی نامناسب است که باید از آن اجتناب کنید. در عوض، برای رسیدگی به این مورد استفاده رایج، پرومتئوس برچسب‌ها را دارد. در مثال قبلی، می‌توانید از برچسب مسیر (path label) استفاده کنید:

```
http_requests_total{path="/login"}

http_requests_total{path="/logout"}

http_requests_total{path="/adduser"}

http_requests_total{path="/comment"}

http_requests_total{path="/view"}
```

سپس می‌توانید با متریک `http_requests_total` با تمام برچسب‌های مسیر آن، به عنوان یک واحد کار کنید. با PromQL می‌توانید نرخ کلی درخواست‌های تجمیع شده، نرخ فقط یکی از مسیرها یا نسبت هر درخواست به کل را بدست آورید.

همچنین می‌توانید متریک‌هایی با بیش از یک برچسب داشته باشید. برچسب‌ها ترتیب ندارند، بنابراین می‌توانید بر اساس هر برچسب معین، در حالی که بقیه را نادیده می‌گیرید، یا حتی بر اساس چندین برچسب به طور همزمان، تجمیع کنید.

### برچسب‌های Instrumentation و Target

برچسب‌ها از دو منبع می‌آیند: برچسب‌های ابزار دقیق (Instrumentation labels) و برچسب‌های هدف (Target labels). وقتی در PromQL کار می‌کنید، تفاوتی بین این دو وجود ندارد، اما برای بهره‌مندی حداکثری از برچسب‌ها، تمایز بین آن‌ها مهم است.

برچسب‌های ابزار دقیق، همانطور که از نامشان پیداست، از ابزار دقیق شما می‌آیند. آن‌ها در مورد چیزهایی هستند که در داخل برنامه یا کتابخانه شما شناخته شده‌اند، مانند نوع درخواست‌های HTTP که دریافت می‌کند، با کدام پایگاه‌های داده صحبت می‌کند و سایر جزئیات داخلی.

برچسب‌های هدف، یک هدف نظارتی خاص را شناسایی می‌کنند؛ یعنی هدفی که پرومتئوس آن را جمع‌آوری می‌کند. برچسب هدف بیشتر به معماری شما مربوط می‌شود و ممکن است شامل این باشد که کدام برنامه است، در کدام مرکز داده قرار دارد، در محیط توسعه یا تولید است، کدام تیم مالک آن است و البته دقیقاً کدام نمونه از برنامه است. برچسب‌های هدف توسط پرومتئوس به عنوان بخشی از فرآیند جمع‌آوری متریک‌ها پیوست می‌شوند.

سرورهای مختلف پرومتئوس که توسط تیم‌های مختلف اجرا می‌شوند، ممکن است دیدگاه‌های متفاوتی در مورد اینکه "تیم"، "منطقه" یا "سرویس" چیست، داشته باشند، بنابراین یک برنامه ابزار دقیق نباید سعی کند چنین برچسب‌هایی را خودش ارائه دهد. بر این اساس، هیچ ویژگی‌ای در کتابخانه‌های مشتری برای افزودن برچسب‌ها در تمام متریک‌های یک هدف پیدا نخواهید کرد. برچسب‌های هدف از کشف سرویس و برچسب‌گذاری مجدد (relabeling) می‌آیند.

+++++++



### ابزار دقیق (Instrumentation)

بیایید مثالی را برای استفاده از برچسب گسترش دهیم. در مثال ۱، می‌توانید `labelnames=['path']` را در تعریف ببینید، که نشان می‌دهد متریک شما یک برچسب به نام `path` دارد. هنگام استفاده از متریک در ابزار دقیق، باید یک فراخوانی به متد `labels` با آرگومان برای مقدار برچسب اضافه کنید.

مثال ۱. یک برنامه پایتون که از برچسب برای یک متریک شمارنده (counter) استفاده می‌کند.



```Python
import http.server
from prometheus_client import start_http_server, Counter

REQUESTS = Counter('hello_worlds_total','Hello Worlds requested.',
labelnames=['path'])

class MyHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        REQUESTS.labels(self.path).inc()
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"Hello World")

if __name__ == "__main__":
    start_http_server(8000)
    server = http.server.HTTPServer(('localhost', 8001), MyHandler)
    server.serve_forever()
```

اگر از `http://localhost:8001/` و `http://localhost:8001/foo` بازدید کنید، در صفحه `/metrics` در `http://localhost:8000/metrics`، سری‌های زمانی را برای هر یک از مسیرها خواهید دید:

```
# HELP hello_worlds_total Hello Worlds requested.
# TYPE hello_worlds_total counter
hello_worlds_total{path="/favicon.ico"} 6.0
hello_worlds_total{path="/"} 4.0
hello_worlds_total{path="/foo"} 1.0
```

نام‌های برچسب از نظر کاراکترهایی که می‌توانید استفاده کنید، محدود هستند. آن‌ها باید با یک حرف (a-z یا A-Z) شروع شوند و با حروف، اعداد و زیرخط‌ها دنبال شوند. این همانند نام‌های متریک است، با این تفاوت که کولون (:) ندارد.

بر خلاف نام‌های متریک، نام‌های برچسب عموماً فضای نام (namespace) ندارند. با این حال، هنگام تعریف برچسب‌های ابزار دقیق، باید مراقب باشید تا از برچسب‌هایی که احتمالاً به عنوان برچسب‌های هدف استفاده می‌شوند، مانند `env`، `cluster`، `service`، `team`، `zone` و `region`، اجتناب کنید. همچنین توصیه می‌کنیم از `type` به عنوان نام برچسب اجتناب کنید، زیرا بسیار عمومی است. قرارداد نام‌گذاری برای نام‌های برچسب، snake case است.

نام‌های برچسب `instance` و `job` به طور بومی توسط پرومتئوس استفاده می‌شوند، بنابراین ما آن‌ها را نیز توصیه نمی‌کنیم، زیرا با برچسب‌های هدف تداخل پیدا می‌کنند. مقادیر برچسب می‌توانند هر کاراکتر UTF-8 باشند. همچنین می‌توانید یک مقدار برچسب خالی داشته باشید، اما این می‌تواند در سرور پرومتئوس کمی گیج‌کننده باشد، زیرا در نگاه اول، شبیه به نداشتن آن برچسب به نظر می‌رسد.

---

#### برچسب‌های رزرو شده و `__name__`

برچسب‌ها می‌توانند با زیرخط شروع شوند، اما باید از چنین برچسب‌هایی اجتناب کنید. نام‌های برچسبی که با دو زیرخط (`__`) شروع می‌شوند، رزرو شده هستند.

در داخل پرومتئوس، نام متریک فقط یک برچسب دیگر به نام `__name__` است. عبارت `up` یک مدل نحوی (syntactic sugar) برای ` {name__="upــ"} ` است و همچنین معناشناسی خاصی با عملگرهای PromQL وجود دارد، همانطور که در "تطبیق برداری (Vector Matching)" بحث شده است.

---

در **Prometheus**، مفهوم **"Vector Matching"** (تطبیق بردارها) به روشی اشاره دارد که دو بردار (vectors) با هم مقایسه یا ترکیب میشوند هنگام انجام عملیات پرسوجو (query). این موضوع زمانی مهم میشود که میخواهید دو مجموعه داده (مثلاً دو بردار از متریکها) را بر اساس برچسبهایشان (labels) با هم تطبیق دهید.

### انواع **Vector Matching** در Prometheus:
۱. **One-to-One Matching** (تطبیق یک به یک):  
   - هر نمونه در یک بردار با نمونه متناظر در بردار دیگر مطابقت داده میشود.  
   - از کلیدواژه `ignoring` برای نادیده گرفتن برخی برچسبها یا `on` برای تطبیق فقط روی برچسبهای خاص استفاده میشود.  

   **مثال:**  
   ```promql
   metric1 + on(instance) metric2
   ```
   (فقط برچسب `instance` برای تطبیق استفاده میشود.)

۲. **Many-to-One / One-to-Many Matching** (تطبیق چند به یک یا یک به چند):  
   - یک طرف عملیات (بردار) میتواند چندین نمونه با برچسبهای یکسان داشته باشد.  
   - از کلیدواژه `group_left` یا `group_right` برای مشخص کردن جهت تطبیق استفاده میشود.  

   **مثال:**  
   ```promql
   metric1 * on(instance) group_left(service) metric2
   ```
   (در اینجا، `metric2` ممکن است چندین مقدار برای یک `instance` داشته باشد، و `group_left` مشخص میکند که برچسب `service` از `metric2` حفظ شود.)

### کاربردهای رایج:
- ترکیب متریکهای مختلف با برچسبهای مشترک (مثلاً جمع کردن درخواستها و خطاها برای محاسبه نرخ خطا).  
- مقایسه دادهها از دو منبع متفاوت (مثلاً مقایسه درخواستهای ورودی با خروجی).  

### نکته مهم:
- اگر برچسبها بهدرستی تطبیق داده نشوند، ممکن است نتایج نادرست یا خالی برگردانده شود.  
- برای اشکالزدایی، میتوانید از توابع مثل `label_join()` یا `label_replace()` برای اصلاح برچسبها استفاده کنید.  

اگر مثال یا سناریوی خاصی مدنظر دارید، خوشحال میشوم کمک کنم!

---

## متریک (Metric)

همانطور که ممکن است متوجه شده باشید، کلمه "متریک" کمی مبهم است و بسته به زمینه، معانی مختلفی دارد. می‌تواند به یک خانواده متریک (metric family)، یک فرزند (child) یا یک سری زمانی (time series) اشاره کند:

```
# HELP latency_seconds Latency in seconds.
# TYPE latency_seconds summary
latency_seconds_sum{path="/foo"} 1.0
latency_seconds_count{path="/foo"} 2.0
latency_seconds_sum{path="/bar"} 3.0
latency_seconds_count{path="/bar"} 4.0
```

‏`latency_seconds_sum{path="/bar"}` یک سری زمانی است که با نام و برچسب‌ها متمایز می‌شود. این همان چیزی است که PromQL با آن کار می‌کند.

‏`latency_seconds{path="/bar"}` یک فرزند است و مقداری است که مقدار بازگشتی `labels()` در کلاینت پایتون نشان می‌دهد.
برای یک summary، هم سری‌های زمانی `_sum` و هم `_count` را با آن برچسب‌ها شامل می‌شود.

‏`latency_seconds` یک خانواده متریک است. این فقط نام متریک و نوع مرتبط آن است. این تعریف متریک هنگام استفاده از یک کتابخانه کلاینت است.
برای یک gauge بدون برچسب، خانواده متریک، فرزند و سری زمانی یکسان هستند.

---

### برچسب‌های متعدد

هنگام تعریف یک متریک می‌توانید هر تعداد برچسب را مشخص کنید و سپس مقادیر را به همان ترتیب در فراخوانی `labels` قرار دهید (مثال ۲).

مثال ۲. `hello_worlds_total` دارای برچسب‌های `path` و `method` است.



```Python
REQUESTS = Counter('hello_worlds_total',
'Hello Worlds requested.',
labelnames=['path', 'method'])

class MyHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        REQUESTS.labels(self.path, self.command).inc()
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"Hello World")
```

پایتون و گو (Go) همچنین به شما اجازه می‌دهند یک map با هر دو نام و مقدار برچسب ارائه دهید، اگرچه نام‌های برچسب همچنان باید با موارد موجود در تعاریف متریک مطابقت داشته باشند. این می‌تواند مخلوط کردن ترتیب آرگومان‌های شما را دشوارتر کند، اما اگر این یک خطر واقعی است، ممکن است برچسب‌های زیادی داشته باشید.

داشتن نام‌های برچسب متغیر برای یک متریک امکان‌پذیر نیست و کتابخانه‌های کلاینت از آن جلوگیری می‌کنند. هنگام کار با متریک‌ها، مهم است که بدانید چه برچسب‌هایی در حال استفاده هستند، بنابراین هنگام انجام ابزار دقیق مستقیم باید نام‌های برچسب خود را از قبل بدانید. اگر برچسب‌های خود را نمی‌دانید، احتمالاً به جای آن، یک ابزار نظارت مبتنی بر لاگ (logs-based monitoring tool) برای آن مورد استفاده خاص نیاز دارید.

++++++++++


## فرزند (Child)

مقداری که توسط متد `labels` در پایتون به شما بازگردانده می‌شود، فرزند (child) نامیده می‌شود. می‌توانید این فرزند را برای استفاده بعدی ذخیره کنید، که شما را از جستجوی آن در هر رویداد ابزار دقیق (instrumentation event) نجات می‌دهد و در کدهای حساس به عملکرد که صدها هزار بار در ثانیه فراخوانی می‌شوند، در زمان صرفه‌جویی می‌کند. در بنچمارک‌های کلاینت جاوا، متوجه شدیم که بدون رقابت، جستجوی فرزند 30 نانوثانیه طول کشید، در حالی که افزایش واقعی 12 نانوثانیه طول کشید.

(به همین دلیل، شما باید در برابر وسوسه نوشتن یک facade یا wrapper در اطراف یک کتابخانه کلاینت پرومتئوس که نام متریک را به عنوان آرگومان می‌گیرد، مقاومت کنید، زیرا این کار نیز هزینه جستجو را به همراه خواهد داشت. داشتن یک متغیر در سطح فایل برای ردیابی آدرس شی متریک، به جای جستجوی مداوم آن، ارزان‌تر، ساده‌تر و از نظر معنایی بهتر است.)

یک الگوی رایج، زمانی که یک شیء فقط به یک فرزند از یک متریک اشاره می‌کند، فراخوانی `labels` یک بار و سپس ذخیره آن در شیء است، همانطور که در مثال ۳ نشان داده شده است.

مثال ۳. یک کش (cache) ساده پایتون که فرزند را در هر کش نام‌گذاری شده ذخیره می‌کند.



```Python
from prometheus_client import Counter

FETCHES = Counter('cache_fetches_total','Fetches from the cache.',
labelnames=['cache'])

class MyCache(object):
    def __init__(self, name):
        self._fetches = FETCHES.labels(name)
        self._cache = {}

    def fetch(self, item):
        self._fetches.inc()
        return self._cache.get(item)

    def store(self, item, value):
        self._cache[item] = value
```

مکان دیگری که با فرزندان روبرو خواهید شد، در مقداردهی اولیه آن‌ها است. فرزندان فقط پس از فراخوانی `labels` در صفحه `/metrics` ظاهر می‌شوند. این می‌تواند مشکلاتی را در PromQL ایجاد کند، زیرا کار با سری‌های زمانی که ظاهر و ناپدید می‌شوند، می‌تواند بسیار چالش‌برانگیز باشد. بر این اساس، در صورت امکان، باید فرزندان را در زمان راه‌اندازی مقداردهی اولیه کنید، مانند مثال ۴، اگرچه اگر از الگوی مثال ۳ پیروی کنید، این کار را به صورت ساده‌تری دریافت می‌کنید.

مثال ۴. مقداردهی اولیه فرزندان یک متریک در زمان راه‌اندازی برنامه.



```Python
from prometheus_client import Counter

REQUESTS = Counter('http_requests_total',
'HTTP requests.',
labelnames=['path'])

REQUESTS.labels('/foo')
REQUESTS.labels('/bar')
```

هنگام استفاده از دکوراتورهای پایتون، می‌توانید از `labels` بدون فراخوانی فوری یک متد در مقدار بازگشتی استفاده کنید، همانطور که در مثال ۵ نشان داده شده است.

مثال ۵. استفاده از دکوراتور با `labels` در پایتون.



```Python
from prometheus_client import Summary

LATENCY = Summary('http_requests_latency_seconds',
'HTTP request latency.',
labelnames=['path'])

foo = LATENCY.labels('/foo')

@foo.time()
def foo_handler(params):
    pass
```

کتابخانه‌های کلاینت معمولاً متدهایی را برای حذف فرزندان از یک متریک ارائه می‌دهند. شما فقط باید استفاده از این‌ها را برای تست‌های واحد (unit tests) در نظر بگیرید. از منظر معنایی PromQL، هنگامی که یک فرزند وجود دارد، باید تا زمانی که فرآیند از بین می‌رود به وجود خود ادامه دهد، در غیر این صورت توابعی مانند `rate` ممکن است نتایج نامطلوبی را برگردانند. این متدها همچنین مقادیر قبلی بازگردانده شده از `labels` را نامعتبر می‌کنند.


++++++++




## تجمیع (Aggregating)

اکنون که ابزار دقیق شما با برچسب‌ها پر شده است، بیایید واقعاً از آنها در PromQL استفاده کنیم. ما در فصل 14 به جزئیات بیشتری در مورد عملگرهای تجمیع خواهیم پرداخت، اما می‌خواهیم اکنون طعم قدرت برچسب‌ها را به شما نشان دهیم. در مثال 5-2، `hello_worlds_total` دارای برچسب‌های `path` و `method` است. از آنجایی که `hello_worlds_total` یک شمارنده (counter) است، ابتدا باید از تابع `rate` استفاده کنید. جدول 5-1 یک خروجی احتمالی است که نتایج را برای دو نمونه برنامه با مسیرها و روش‌های HTTP مختلف نشان می‌دهد.

```
جدول 5-1. خروجی rate(hello_worlds_total[5m])

{job="myjob", instance="localhost:1234", path="/foo", method="GET"} 1

{job="myjob", instance="localhost:1234", path="/foo", method="POST"} 2

{job="myjob", instance="localhost:1234", path="/bar", method="GET"} 4

{job="myjob", instance="localhost:5678", path="/foo", method="GET"} 8

{job="myjob", instance="localhost:5678", path="/foo", method="POST"} 16

{job="myjob", instance="localhost:5678", path="/bar", method="GET"} 32
```

این می‌تواند برای شما کمی دشوار باشد، به خصوص اگر سری‌های زمانی بسیار بیشتری نسبت به این مثال ساده داشته باشید. بیایید با تجمیع برچسب `path` شروع کنیم. شما این کار را با استفاده از تجمیع `sum` انجام می‌دهید، زیرا می‌خواهید نمونه‌ها را با هم جمع کنید. بند `without` نشان می‌دهد که کدام برچسب را می‌خواهید حذف کنید. این عبارت `sum without(path)(rate(hello_worlds_total[5m]))` را به شما می‌دهد که خروجی جدول 5-2 را تولید می‌کند.

جدول 5-2. خروجی sum without(path)(rate(hello_worlds_total[5m]))

```
{job="myjob", instance="localhost:1234", method="GET"} 5

{job="myjob", instance="localhost:1234", method="POST"} 2

{job="myjob", instance="localhost:5678", method="GET"} 40

{job="myjob", instance="localhost:5678", method="POST"} 16
```

داشتن ده‌ها یا صدها نمونه برای شما غیرمعمول نیست و طبق تجربه ما، نگاه کردن به نمونه‌های فردی در داشبوردها در حدود سه تا پنج نمونه از هم می‌پاشد. می‌توانید بند `without` را برای شامل کردن برچسب `instance` گسترش دهید، که خروجی نشان داده شده در جدول 5-3 را ارائه می‌دهد. همانطور که از مقادیر جدول 5-1 انتظار دارید، 1 + 4 + 8 + 32 = 45 درخواست در ثانیه برای GET و 2 + 16 = 18 درخواست در ثانیه برای POST است.

جدول 5-3. خروجی sum without(path, instance)(rate(hello_worlds_total[5m]))

```
{job="myjob", method="GET"} 45

{job="myjob", method="POST"} 18
```

برچسب‌ها به هیچ وجه مرتب نشده‌اند، بنابراین همانطور که می‌توانید `path` را حذف کنید، می‌توانید `method` را نیز حذف کنید، همانطور که در جدول 5-4 مشاهده می‌شود.

جدول 5-4. خروجی sum without(method, instance)(rate(hello_worlds_total[5m]))

```
{job="myjob", path="/foo"} 27

{job="myjob", path="/bar"} 36
```

همچنین یک بند `by` وجود دارد که فقط برچسب‌هایی را که مشخص می‌کنید نگه می‌دارد. `without` ترجیح داده می‌شود زیرا اگر برچسب‌های اضافی مانند `env` یا `region` در سراسر یک کار وجود داشته باشد، از بین نمی‌روند. این به شما کمک می‌کند وقتی قوانین خود را با دیگران به اشتراک می‌گذارید.

### الگوهای برچسب (Label Patterns)

پرومتئوس فقط اعداد ممیز شناور 64 بیتی را به عنوان مقادیر سری زمانی پشتیبانی می‌کند، نه هیچ نوع داده دیگری مانند رشته‌ها. اما مقادیر برچسب رشته هستند و موارد استفاده محدود خاصی وجود دارد که در آن استفاده (سوء استفاده) از آنها بدون اینکه خیلی به نظارت مبتنی بر لاگ (logs-based monitoring) نزدیک شویم، اشکالی ندارد.

## شمارش (Enum)

اولین مورد رایج برای رشته‌ها، شمارش‌ها (enums) است. به عنوان مثال، ممکن است منبعی داشته باشید که دقیقاً می‌تواند در یکی از حالت‌های `STARTING`، `RUNNING`، `STOPPING` یا `TERMINATED` باشد.

می‌توانید این را به عنوان یک گیج (gauge) با `STARTING` بودن 0، `RUNNING` بودن 1، `STOPPING` بودن 2 و `TERMINATED` بودن 3 ارائه دهید. اما کار با این در PromQL کمی دشوار است. اعداد 0-3 کمی مبهم هستند و هیچ عبارت واحدی وجود ندارد که بتوانید برای گفتن اینکه منبع شما چه نسبتی از زمان را در `STARTING` گذرانده است، بنویسید.

راه حل این است که یک برچسب برای حالت به گیج اضافه کنید، به طوری که هر حالت بالقوه یک فرزند شود. هنگام ارائه یک مقدار بولی در پرومتئوس، باید از 1 برای درست (true) و 0 برای نادرست (false) استفاده کنید. بر این اساس، یکی از فرزندان مقدار 1 و بقیه 0 را خواهند داشت، که متریک‌هایی مانند مثال 5-6 را تولید می‌کند.

مثال 5-6. یک مثال شمارش؛ منبع `blaa` در حالت `RUNNING` است.

```
# HELP gauge The current state of resources.
# TYPE gauge resource_state
resource_state{resource_state="STARTING", resource="blaa"} 0
resource_state{resource_state="RUNNING", resource="blaa"} 1
resource_state{resource_state="STOPPING", resource="blaa"} 0
resource_state{resource_state="TERMINATED", resource="blaa"} 0
```

از آنجا که 0 ها همیشه وجود دارند، عبارت PromQL `avg_over_time(resource_state[1h])` نسبت زمان صرف شده در هر حالت را به شما می‌دهد. همچنین می‌توانید با استفاده از `sum without(resource)(resource_state)` بر اساس `resource_state` تجمیع کنید تا ببینید چند منبع در هر حالت هستند. برای تولید چنین متریک‌هایی، می‌توانید از `set` در یک گیج استفاده کنید، اما این شرایط مسابقه (race conditions) را به همراه خواهد داشت. یک scrape ممکن است بسته به اینکه دقیقاً چه زمانی اتفاق افتاده است، 1 را در صفر یا دو حالت ببیند. شما به نوعی جداسازی نیاز دارید تا گیج در وسط یک به‌روزرسانی ارائه نشود. راه حل این است که از یک جمع‌آورنده سفارشی (custom collector) استفاده کنید، که در "جمع‌آورنده‌های سفارشی" در صفحه 219 بیشتر مورد بحث قرار خواهد گرفت. برای اینکه ایده‌ای از نحوه انجام این کار به شما بدهیم، می‌توانید یک پیاده‌سازی اساسی را در مثال 5-7 پیدا کنید. در واقعیت، شما معمولاً کدی مانند این را به جای داشتن یک کلاس مستقل، به یک کلاس موجود اضافه می‌کنید.

مثال 5-7. یک جمع‌آورنده سفارشی برای یک گیج که به عنوان شمارش استفاده می‌شود.

Python

```
from threading import Lock
from prometheus_client.core import GaugeMetricFamily, REGISTRY

class StateMetric(object):
    def __init__(self):
        self._resource_states = {}
        self._STATES = ["STARTING", "RUNNING", "STOPPING", "TERMINATED",]
        self._mutex = Lock()

    def set_state(self, resource, state):
        with self._mutex:
            self._resource_states[resource] = state

    def collect(self):
        family = GaugeMetricFamily("resource_state",
```

+++++



### اطلاعات (Info)

دومین مورد رایج برای رشته‌ها، متریک‌های اطلاعاتی (info metrics) هستند، که ممکن است به دلایل تاریخی، رویکرد نقش‌های ماشین (machine roles approach) نیز نامیده شوند. متریک‌های اطلاعاتی برای حاشیه‌نویسی‌هایی مانند شماره نسخه و سایر اطلاعات ساخت که پرس‌وجو در مورد آنها مفید است، کاربرد دارند، اما استفاده از آنها به عنوان برچسب‌های هدف منطقی نیست، زیرا برچسب‌های هدف به تمام متریک‌های یک هدف اعمال می‌شوند (در "برچسب‌های هدف" در صفحه 153 بحث شده است) که به هر متریک از یک هدف اعمال می‌شود. قراردادی که پدید آمده است، استفاده از یک گیج (gauge) با مقدار 1 و تمام رشته‌هایی است که می‌خواهید هدف را به عنوان برچسب حاشیه‌نویسی کنید. گیج باید پسوند `_info` داشته باشد. این در شکل 3-2 با متریک `python_info` نشان داده شد، که هنگام ارائه شدن چیزی شبیه مثال 5-8 خواهد بود.

مثال 5-8. متریک `python_info` که کلاینت پایتون به طور پیش‌فرض ارائه می‌دهد.

```
# HELP python_info Python platform information
# TYPE python_info gauge
python_info{implementation="CPython", major="3", minor="5", patchlevel="2", version="3.5.2"} 1.0
```

برای تولید این در پایتون، می‌توانید از ابزار دقیق مستقیم (direct instrumentation) یا یک جمع‌آورنده سفارشی (custom collector) استفاده کنید. مثال 5-9 مسیر ابزار دقیق مستقیم را طی می‌کند و همچنین از قابلیت ارسال برچسب‌ها به عنوان آرگومان‌های کلیدواژه‌ای با کلاینت پایتون بهره می‌برد.

مثال 5-9. یک متریک اطلاعاتی با استفاده از ابزار دقیق مستقیم.

Python

```
from prometheus_client import Info

version_info = {
    "implementation": "CPython",
    "major": "3",
    "minor": "5",
    "patchlevel": "2",
    "version": "3.5.2",
}

INFO = Info("my_python", "Python platform information")
INFO.labels(version_info)
```

یک متریک اطلاعاتی را می‌توان با استفاده از عملگر ضرب و اصلاح‌کننده `group_left` به هر متریک دیگری پیوند داد. هر عملگری را می‌توان برای پیوند دادن متریک‌ها استفاده کرد، اما از آنجا که مقدار متریک اطلاعاتی 1 است، ضرب مقدار متریک دیگر را تغییر نمی‌دهد.

مقدار 1 توسط نوع متریک استنباط می‌شود، در این مورد Info. برای افزودن برچسب نسخه از `python_info` به تمام متریک‌های `up`، از عبارت PromQL زیر استفاده می‌کنید:

```
up
* on (instance, job) group_left(version)
python_info
```

`group_left(version)` نشان می‌دهد که این یک تطابق چند به یک (many-to-one match) است و برچسب نسخه باید از `python_info` به تمام متریک‌های `up` که دارای برچسب‌های `job` و `instance` یکسان هستند، کپی شود. ما `group_left` را با جزئیات بیشتر در "چند به یک و group_left" در صفحه 268 بررسی خواهیم کرد.

با نگاه کردن به این عبارت می‌توانید تشخیص دهید که خروجی دارای برچسب‌های متریک `up`، با یک برچسب نسخه اضافه شده، خواهد بود. افزودن تمام برچسب‌ها از `python_info` امکان‌پذیر نیست، زیرا به طور بالقوه می‌توانید برچسب‌های ناشناخته از هر دو طرف عبارت داشته باشید، که از نظر معنایی قابل اجرا نیست. مهم است که همیشه بدانید چه برچسب‌هایی در حال استفاده هستند.


++++++++++




#### تغییرات ناسازگار و برچسب‌ها (Breaking Changes and Labels)

اگر برچسبی را از ابزار دقیق اضافه یا حذف کنید، همیشه یک تغییر ناسازگار (breaking change) است. حذف یک برچسب، تمایزی را که کاربر ممکن است به آن وابسته بوده باشد، از بین می‌برد. افزودن یک برچسب، تجمیعی را که از بند `without` استفاده می‌کند، خراب می‌کند.

تنها استثنا برای این مورد، متریک‌های اطلاعاتی (info metrics) است. برای آنها، عبارات PromQL به گونه‌ای ساخته می‌شوند که برچسب‌های اضافی مشکلی ایجاد نمی‌کنند، بنابراین افزودن برچسب به متریک‌های اطلاعاتی بی‌خطر است.

---

متریک‌های اطلاعاتی همچنین دارای مقدار 1 هستند، بنابراین محاسبه تعداد سری‌های زمانی که هر مقدار برچسب را دارند با استفاده از `sum` آسان است. تعداد نمونه‌های برنامه که هر نسخه از پایتون را اجرا می‌کنند، `sum by (version)(python_info)` خواهد بود. اگر مقدار دیگری مانند 0 بود، ترکیبی از `sum` و `count` در سلسله مراتب تجمیع شما لازم بود، که هم پیچیده‌تر و هم مستعد خطا خواهد بود.

### چه زمانی از برچسب‌ها استفاده کنیم

برای اینکه یک متریک مفید باشد، باید بتوانید آن را به نوعی تجمیع کنید. قانون سرانگشتی این است که جمع یا میانگین‌گیری در یک متریک باید نتیجه‌ای معنادار تولید کند. برای شمارنده درخواست‌های HTTP که بر اساس مسیر و روش تقسیم شده‌اند، جمع، تعداد کل درخواست‌ها است. برای یک صف (queue)، ترکیب آیتم‌های موجود در آن و محدودیت اندازه آن در یک متریک منطقی نیست، زیرا نه جمع و نه میانگین‌گیری آن چیزی مفید تولید نمی‌کند.

یک نشانه مبنی بر اینکه یک برچسب ابزار دقیق مفید نیست، این است که هر زمان که از متریک استفاده می‌کنید، نیاز به مشخص کردن آن برچسب در PromQL پیدا می‌کنید. در چنین مواردی، احتمالاً باید برچسب را به جای آن به نام متریک منتقل کنید.

مورد دیگری که باید از آن اجتناب کرد، داشتن یک سری زمانی است که مجموع بقیه متریک باشد، مانند:

```
some_metric{label="foo"} 7
some_metric{label="bar"} 13
some_metric{label="total"} 20
```

یا:

```
some_metric{label="foo"} 7
some_metric{label="bar"} 13
some_metric{} 20
```

هر دوی اینها تجمیع با `sum` را در PromQL خراب می‌کنند، زیرا شما دو بار شمارش می‌کنید. PromQL قبلاً توانایی محاسبه این تجمیع را به شما ارائه می‌دهد.

---

#### استثنای جدول (Table Exception)

خوانندگان باهوش احتمالاً متوجه شده‌اند که کوانتیل‌های متریک خلاصه (summary metric quantiles) قانون مربوط به معنادار بودن جمع یا میانگین را نقض می‌کنند، زیرا نمی‌توانید روی کوانتیل‌ها ریاضی انجام دهید. این همان چیزی است که ما آن را استثنای جدول می‌نامیم، جایی که حتی اگر نمی‌توانید روی یک متریک ریاضی انجام دهید، استفاده (سوء استفاده) از یک برچسب بهتر از این است که مجبور به انجام regexها در برابر نام متریک باشید. regexها در نام‌های متریک بوی بسیار بدی دارند و هرگز نباید در نمودارها یا هشدارها استفاده شوند.

برای شما، این استثنا فقط هنگام نوشتن صادرکننده‌ها (exporters) پیش می‌آید، نه برای ابزار دقیق مستقیم. به عنوان مثال، ممکن است ترکیبی ناشناخته از ولتاژها، سرعت فن‌ها و دماها از سنسورهای سخت‌افزاری داشته باشید. از آنجا که اطلاعات لازم برای تقسیم آنها به متریک‌های مختلف را ندارید، تنها کاری که واقعاً می‌توانید انجام دهید این است که همه آنها را در یک متریک قرار دهید و تفسیر آن را به عهده شخصی بگذارید که متریک را مصرف می‌کند.

---

نام‌های برچسب مورد استفاده برای یک متریک نباید در طول عمر فرآیند برنامه تغییر کنند. اگر احساس نیاز به این کار دارید، احتمالاً یک راه حل نظارت مبتنی بر لاگ (logs-based monitoring solution) برای آن مورد استفاده خاص می‌خواهید.


+++++++++++++



### کاردینالیتی (Cardinality)

هنگام استفاده از برچسب‌ها زیاده‌روی نکنید. نظارت وسیله‌ای برای رسیدن به هدف است، بنابراین سری‌های زمانی بیشتر و نظارت بیشتر همیشه بهتر نیستند. برای یک سیستم نظارت، چه خودتان آن را در محل اجرا کنید و چه به شرکتی پول بدهید تا آن را برای شما در ابر اجرا کند، هر سری زمانی و نمونه هم هزینه منابع و هم هزینه انسانی از نظر عملیات مداوم برای حفظ و اجرای سیستم نظارت دارد. در این زمینه می‌خواهیم در مورد کاردینالیتی صحبت کنیم، که در پرومتئوس تعداد سری‌های زمانی شما است. اگر پرومتئوس شما برای مدیریت، مثلاً 10 میلیون سری زمانی، تهیه شده است، چگونه می‌توانید از آنها به بهترین شکل استفاده کنید؟ در چه نقطه‌ای موارد استفاده خاص را به جای آن به نظارت مبتنی بر لاگ (logs-based monitoring) منتقل می‌کنید؟ روشی که ما به آن نگاه می‌کنیم این است که فرض کنیم کسی که کد شما را اجرا می‌کند، یک تنظیمات بزرگ با هزار نمونه از یک برنامه خاص دارد. افزودن یک متریک شمارنده ساده به یک زیرسیستم مبهم، هزار سری زمانی به پرومتئوس شما اضافه می‌کند، که 0.01٪ از ظرفیت آن است. این اساساً رایگان است و ممکن است روزی به شما در اشکال‌زدایی یک مشکل عجیب کمک کند. در سراسر برنامه و کتابخانه‌های آن، ممکن است صد مورد از این متریک‌های مبهم داشته باشید، که در مجموع 1٪ از ظرفیت نظارت شما را تشکیل می‌دهند و حتی با توجه به نادر بودن استفاده شما از هر یک از آنها، هنوز بسیار ارزان است. اکنون یک متریک با برچسبی با 10 مقدار را در نظر بگیرید که علاوه بر آن یک هیستوگرام بود که به طور پیش‌فرض 12 سری زمانی دارد. این 120 سری یا 1.2٪ از ظرفیت نظارت شما است. اینکه این یک معامله خوب است، کمتر واضح است. ممکن است داشتن چند مورد از اینها خوب باشد، اما همچنین می‌توانید به جای آن به یک متریک خلاصه بدون کوانتیل (quantile-less summary metric) تغییر دهید. مرحله بعدی جایی است که اوضاع کمی مشکل‌ساز می‌شود. اگر یک برچسب از قبل کاردینالیتی 10 داشته باشد، احتمال زیادی وجود دارد که با معرفی ویژگی‌های جدید به برنامه شما، فقط با گذشت زمان افزایش یابد. کاردینالیتی 10 امروز ممکن است سال آینده 15 و 200 ممکن است به 300 تغییر کند. افزایش ترافیک کاربران معمولاً به معنای نمونه‌های برنامه بیشتر است. اگر بیش از یکی از این برچسب‌های در حال گسترش را در یک متریک داشته باشید، تأثیر آن تشدید می‌شود و منجر به انفجار ترکیبی سری‌های زمانی می‌شود. و این فقط یکی از برنامه‌های همیشه در حال رشد است که پرومتئوس در حال نظارت بر آن است. به این ترتیب کاردینالیتی می‌تواند به طور پنهانی به شما نزدیک شود. معمولاً آشکار است که آدرس‌های ایمیل، مشتریان و آدرس‌های IP به دلایل کاردینالیتی انتخاب‌های ضعیفی برای مقادیر برچسب هستند. کمتر واضح است که مسیر HTTP مشکل‌ساز خواهد بود. با توجه به اینکه متریک درخواست HTTP به طور منظم استفاده می‌شود، حذف برچسب‌ها از آن، تغییر از هیستوگرام یا حتی کاهش تعداد سطل‌ها در هیستوگرام می‌تواند از نظر سیاسی چالش‌برانگیز باشد. قانون سرانگشتی که ما استفاده می‌کنیم این است که کاردینالیتی یک متریک دلخواه در یک نمونه برنامه باید زیر 10 نگه داشته شود. همچنین خوب است که چند متریک داشته باشیم که کاردینالیتی حدود 100 دارند، اما باید آماده کاهش کاردینالیتی متریک و تکیه بر لاگ‌ها با افزایش کاردینالیتی باشید.

چند متریک با کاردینالیتی صد در هر پرومتئوس، هزار نمونه‌ای را فرض می‌کند که چنین کاردینالیتی را ارائه می‌دهند. اگر 100٪ مطمئن هستید که به این اعداد نخواهید رسید، مانند برنامه‌هایی که دقیقاً یک مورد از آنها را اجرا خواهید کرد، می‌توانید قانون سرانگشتی را بر این اساس تنظیم کنید.

یک الگوی رایج وجود دارد که هنگام معرفی پرومتئوس به یک سازمان دیده‌ایم. معمولاً سازمان‌ها هنگام معرفی پرومتئوس منحنی یادگیری را تجربه می‌کنند. در نقطه‌ای کلیک می‌کند و آنها شروع به درک قدرت برچسب‌ها می‌کنند. معمولاً به سرعت دنبال می‌شود که پرومتئوس شما به دلیل کاردینالیتی برچسب، مشکلات عملکردی دارد. توصیه می‌کنیم در مورد محدودیت‌های کاردینالیتی با کاربران خود در اوایل کار صحبت کنید و همچنین استفاده از `sample_limit` را به عنوان یک شیر اطمینان اضطراری در نظر بگیرید (به "کاهش بار" در صفحه 376 مراجعه کنید). 10 متریک بزرگ در یک پرومتئوس معمولاً بیش از نیمی از مصرف منابع آن را تشکیل می‌دهند و این تقریباً همیشه به دلیل کاردینالیتی برچسب است. گاهی اوقات این سردرگمی وجود دارد که اگر مشکل تعداد مقادیر برچسب است، آیا انتقال مقدار برچسب به نام متریک مشکل را حل نمی‌کند؟ از آنجا که محدودیت منابع اساسی در واقع کاردینالیتی سری‌های زمانی است (که به دلیل مقادیر برچسب آشکار می‌شود)، انتقال مقادیر برچسب به نام متریک کاردینالیتی را تغییر نمی‌دهد، فقط استفاده از متریک‌ها را دشوارتر می‌کند. اکنون که می‌توانید متریک‌ها را به برنامه‌های خود اضافه کنید و برخی از عبارات اساسی PromQL را می‌دانید، در فصل بعد به شما نشان خواهیم داد که چگونه می‌توانید داشبوردها را در Grafana ایجاد کنید.


