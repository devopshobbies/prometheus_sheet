در این آموزش، شما با بازبرچسب‌زنی (relabeling) آشنا خواهید شد، که یک configuration meta language برای Prometheus است و نقش محوری در تبدیل و فیلتر کردن objectهای برچسب‌دار در Prometheus مانند اهداف (targets)، نمونه‌های scrape شده (scraped samples) یا هشدارها (alerts) ایفا می‌کند.

پس از این آموزش، شما خواهید دانست که قوانین بازبرچسب‌زنی چگونه کار می‌کنند و قادر خواهید بود آن‌ها را در سناریوهای مختلف به کار ببرید، مانند نگاشت برچسب‌ها از ابرداده‌های کشف سرویس (service discovery metadata) به برچسب‌های هدف (target labels) یا فیلتر کردن نمونه‌های scrape شده.



**پیش‌نیازها**

این بخش نرم‌افزارها و تجربه‌های پیش‌نیاز برای این آموزش را مشخص می‌کند.

**الزامات نرم‌افزاری**

این آموزش غیرتعاملی است و صرفاً مفاهیم را توضیح می‌دهد، بنابراین نیازی به نصب نرم‌افزار نیست.

**تجربه مورد نیاز**

شما به درک پایه‌ای از مانیتورینگ مبتنی بر پرومتئوس نیاز دارید، که می‌توانید آن را در آموزش رایگان "مقدمه‌ای بر پرومتئوس" ما کسب کنید.


## انگیزه

پرومتئوس انواع مختلف **اشیاء برچسب‌دار** را کشف، scrape و پردازش می‌کند. بارزترین این اشیاء، اهداف scrape و نمونه‌های سری زمانی هستند، اما هشدارها نیز برچسب دارند:



![image](src/relabela.png)



اغلب مفید است که بتوان این اشیاء را بر اساس مقادیر برچسب‌هایشان دستکاری یا فیلتر کرد. برای مثال، ممکن است بخواهیم:

- فقط **اهداف خاصی را مانیتور کنیم** که دارای یک service discovery annotation خاص هستند که نشان می‌دهد باید scrape شوند.
- **یک پارامتر HTTP query را به درخواست scrape** برای یک هدف اضافه کنیم.
- فقط **زیرمجموعه فیلتر شده‌ای از نمونه‌های** scrape شده از یک هدف معین را ذخیره کنیم.
- **یک برچسب تکراری را از هشدارهای ارسال شده به Alertmanager حذف کنیم** (به طوری که هشدارهای یکسان ارسال شده از یک جفت سرور پرومتئوس با دسترس‌پذیری بالا بتوانند در Alertmanager حذف تکراری شوند).
- **دو مقدار برچسب یک سری scrape شده را در یک برچسب واحد ترکیب کنیم** (یا برعکس).

‏ **relabeling (Relabeling)** مفهومی است که به مدیر پرومتئوس اجازه می‌دهد این نوع قوانین تبدیل و فیلتر را پیکربندی کند.

---

‏relabeling (Relabeling) به عنوان مجموعه‌ای از مراحل تبدیل پیاده‌سازی می‌شود که می‌توانید در بخش‌های مختلف فایل پیکربندی پرومتئوس برای فیلتر یا اصلاح لیستی از اشیاء برچسب‌دار اعمال کنید. می‌توانید 
‏relabeling را بر روی انواع زیر از labeled objects اعمال کنید:

| Relabeled Object Type                          | Configuration Section                                                                                                                                                |
| ---------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Discovered **scrape targets**                  | `relabel_configs` section in a [`scrape_config`](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config) section                    |
| Discovered **Alertmanager targets**            | `relabel_configs` section in an [`alertmanager_config`](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config) section       |
| Individual **samples from scrapes**            | `metric_relabel_configs` section in a [`scrape_config`](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config) section             |
| **Alerts** sent to _all_ Alertmanagers         | `alert_relabel_configs` section in the `alerting` section of the main configuration file                                                                             |
| **Alerts** sent to a _subset_ of Alertmanagers | `alert_relabel_configs` section in an [`alertmanager_config`](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config) section |
| **Samples written to remote storage systems**  | `write_relabel_configs` section in the [`remote_write`](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#remote_write) section              |


![image](src/relabling2.png)
تمام این بخش‌های مختلف پیکربندی relabeling از یک نوع هستند: `relabel_config`.

یک بخش پیکربندی relabeling شامل لیستی از قوانینی است که به ترتیب بر روی هر object برچسب‌دار اعمال می‌شوند. هر قانون در زنجیره ممکن است یک object برچسب‌دار را اصلاح یا حذف کند:

![image](src/relabing3.png)

برای مثال، یک relabeling rule ممکن است یک object را بر اساس مطابقت یک regular expression نگه دارد یا حذف کند، ممکن است برچسب‌های آن را تغییر دهد، یا ممکن است مجموعه‌ای کامل از برچسب‌ها را به مجموعه‌ای دیگر نگاشت کند. هنگامی که یک مرحله relabeling تصمیم به حذف یک object برچسب‌دار می‌گیرد، هیچ مرحله relabeling دیگری برای این object اجرا نمی‌شود و از لیست خروجی حذف می‌شود (برای مثال، برای یک هدف، این به معنای آن است که scrape نخواهد شد).

---

**برچسب‌های پنهان (Hidden Labels) و فراداده (Metadata)**

برچسب‌هایی که با دو خط زیرین (__) شروع می‌شوند، به طور خودکار پس از آخرین relabeling rule حذف می‌شوند  و بنابراین به برچسب‌های نهایی یک object وارد نمی‌شوند. این برچسب‌های با پیشوند ویژه می‌توانند برای ذخیره و انتقال Metadata اضافی در طول مرحله relabeling برای تصمیم‌گیری یا تغییر برچسب‌های object استفاده شوند. برای مثال، یک مکانیزم service discovery ممکن است در ابتدا Metadata اضافی را برای هر هدف در این برچسب‌های "hidden" ارائه دهد.

**برچسب‌های کنترل scrape (Scrape)**

برای اهداف، برخی از این hidden labels معنای خاصی دارند و نحوه scrape یک هدف توسط پرومتئوس را کنترل می‌کنند:

- ‏`__address__`: این برچسب آدرس TCP را که باید برای هدف scrape شود، شامل می‌شود. در ابتدا به جفت `<host>:<port>` هدف که توسط مکانیزم کشف سرویس ارائه شده است، تنظیم می‌شود. پس از relabeling، پرومتئوس برچسب `instance` را به مقدار `__address__` تنظیم می‌کند، اگر قبل از آن، برچسب `instance` را به طور صریح به مقدار دیگری تنظیم نکنید.
- ‏`__scheme__`: این برچسب طرح HTTP (http یا https) را که هدف باید با آن scrape شود، شامل می‌شود. مقدار پیش‌فرض آن `http` است.
- ‏`__metrics_path__`: این برچسب مسیر HTTP برای scrape متریک‌ها را شامل می‌شود. مقدار پیش‌فرض آن `/metrics` است.
- ‏`__param_<name>`: این برچسب نام پارامترهای HTTP query و مقادیر آنها را که باید همراه با درخواست scrape ارسال شوند، شامل می‌شود.

شما می‌توانید هر یک از این برچسب‌ها را با استفاده از قوانین relabeling تنظیم یا بازنویسی کنید تا رفتارهای scrape سفارشی را برای اهداف فردی ایجاد کنید.

**برچسب‌های Service discovery metadata**

علاوه بر این، مکانیزم‌های service discovery می‌توانند مجموعه‌ای از برچسب‌ها را که با `__meta_` شروع می‌شوند، ارائه دهند که حاوی فراداده خاص discovery در مورد یک هدف هستند. برای مثال، هنگام کشف پادها در یک خوشه Kubernetes، موتور کشف سرویس Kubernetes برای هر هدف پاد، برچسب `__meta_kubernetes_pod_name` را که حاوی نام پاد کشف شده است، و برچسب `__meta_kubernetes_pod_ready` را که نشان می‌دهد پاد در حالت آماده است یا خیر، ارائه می‌دهد. می‌توانید تمام برچسب‌هایی را که کشف سرویس Kubernetes ارائه می‌دهد، در مستندات پیکربندی پیدا کنید. سایر مکانیزم‌های کشف سرویس فراداده مشابهی را ارائه می‌دهند.

**برچسب‌های موقت**

اگر نیاز دارید یک مقدار برچسب موقت را در یک مرحله relabeling ذخیره کنید (برای استفاده در یک مرحله relabeling بعدی)، می‌توانید از پیشوند نام برچسب `__tmp` استفاده کنید. تضمین می‌شود که برچسب‌هایی که با `__tmp` شروع می‌شوند، هرگز توسط خود پرومتئوس استفاده نمی‌شوند.


---


## Relabeling Rule Fields

قوانین relabeling به طور کلی دارای فیلدهای پیکربندی زیر هستند، اما برای هر نوع `action` (نوع قانون relabeling)، فقط زیرمجموعه‌ای از این فیلدها استفاده می‌شود:


```yaml
action: <relabel action>
source_labels: [<source label name list>]
separator: <source labels separator>
target_label: <target label>
regex: <regular expression>
modulus: <modulus value>
replacement: <replacement string>
```

- ‏`action`: عمل relabeling مورد نظر برای اجرا. مقدار پیش‌فرض `replace` است. اقدامات ممکن (که در بخش‌های بعدی توضیح داده شده‌اند) عبارتند از:

- `replace`
- `keep`
- `drop`
- `hashmod`
- `labelmap`
- `labeldrop`
- `labelkeep`
- `keepequal`
- `dropequal`
- `lowercase`
- `uppercase`

- ‏`source_labels`: لیستی از نام برچسب‌ها که با استفاده از separator string پیکربندی شده به هم متصل می‌شوند و با عبارت منظم ارائه شده در فیلد `regex` مطابقت داده می‌شوند.
- ‏`separator`: رشته‌ای که برای جدا کردن برچسب‌های منبع هنگام اتصال آنها استفاده می‌شود. مقدار پیش‌فرض آن ";" است.
- ‏`target_label`: نام برچسبی که هنگام استفاده از اقدامات relabeling `replace` یا `hashmod` باید بازنویسی شود.
- ‏`regex`: عبارت منظم برای مطابقت با برچسب‌های منبع به هم متصل شده. مقدار پیش‌فرض آن "(.*)" است، که با هر برچسب منبع مطابقت دارد.
- ‏`modulus`: ماژول برای گرفتن هش برچسب‌های منبع به هم متصل شده. برای تقسیم افقی تنظیمات پرومتئوس مفید است.
- ‏`replacement`: یک رشته جایگزین که برای اقدامات relabeling `replace` در برچسب`target_label` نوشته می‌شود. می‌تواند به گروه‌های ضبط عبارت منظم که توسط `regex` ضبط شده‌اند، اشاره کند.

---

## Setting or Replacing Label Values

یک مورد استفاده رایج برای relabeling، تنظیم یا بازنویسی مقدار یک برچسب است. این کار را می‌توان با استفاده از عمل `replace` انجام داد، که اگر فیلد `action` مشخص نشده باشد، مقدار پیش‌فرض است.

ساختار قانون

یک قانون relabeling `replace` دارای ساختار زیر است:

```yaml
action: replace
source_labels: [<source label name list>]
separator: <source labels separator>      # Defaults to ';'
regex: <regular expression>               # Defaults to '(.*)' (matching any value)
replacement: <replacement string>         # Defaults to '$1' (using the first capturing group as a replacement)
target_label: <target label>
```

این عمل مراحل زیر را به ترتیب انجام می‌دهد:

1. مقادیر برچسب‌های فهرست شده در `source_labels` را با استفاده از مقدار `separator` ارائه شده به هم متصل می‌کند.
2. آزمایش می‌کند که آیا عبارت منظم در `regex` با رشته به هم متصل شده از مرحله قبل مطابقت دارد یا خیر. اگر مطابقت وجود نداشته باشد، به قانون relabeling بعدی می‌رود و چیزی را جایگزین نمی‌کند.
3. اگر مطابقت وجود داشته باشد، مقادیر هر گروه ضبط عبارت منظم را استخراج می‌کند (به مستندات عبارت منظم RE2 مراجعه کنید) و هر ارجاع ($1، $2، ...) به این گروه‌ها را در رشته `replacement` با مقادیر آنها جایگزین می‌کند.
4. رشته `replacement` جایگزین شده با regex را به عنوان مقدار جدید برای برچسب ارائه شده به عنوان `target_label` ذخیره می‌کند.

موارد استفاده مثال

بیایید به چند مورد استفاده مثال برای عمل `replace` نگاه کنیم.

تنظیم مقدار برچسب ثابت

ساده‌ترین مثال `replace` فقط تنظیم یک برچسب به یک مقدار ثابت است. برای مثال، می‌توانید برچسب `env` را به مقدار `production` به این صورت تنظیم کنید:

```yaml
action: replace
replacement: production
target_label: env
```

توجه داشته باشید که حتی نیازی به تنظیم اکثر فیلدهای قانون نداریم، زیرا مقادیر پیش‌فرض در حال حاضر برای این مورد به خوبی کار می‌کنند (مطابقت با کل برچسب منبع و استفاده از آن به عنوان رشته جایگزین). حتی می‌توانیم فیلد `action` را حذف کنیم، زیرا `replace` مقدار پیش‌فرض است:

```yaml
replacement: production
target_label: env
```

با این حال، توصیه می‌کنیم همیشه فیلد `action` را برای خوانایی بیشتر قوانین خود درج کنید.

#### Replacing the scrape port

یک مثال پیچیده‌تر، بازنویسی پورتی است که یک نمونه بر روی آن scrape می‌شود. می‌توانید پورت برچسب `__address__` را با پورت ثابت 80 به این صورت جایگزین کنید:

```yaml
action: replace
source_labels: [__address__]
regex: ([^:]+)(?::\d+)?   # The first group matches the host, the second matches the port.
replacement: '$1:80'
target_label: __address__
```

----

نگهداری و حذف Objectها

یک مورد استفاده رایج دیگر، تمایل به حذف یا نگهداری کل اشیاء برچسب‌دار از مجموعه نتایج نهایی است. اقدامات relabeling keep و drop امکان کنترل این موضوع را فراهم می‌کنند.

بسته به اینکه در کدام نوع پیکربندی relabeling استفاده می‌شوند، به شما امکان می‌دهند تصمیم بگیرید:

- ...کدام اهداف حاصل از کشف سرویس باید scrape شوند،
- ...کدام نمونه‌های سری خاص باید از یک هدف scrape یا به فضای ذخیره‌سازی راه دور ارسال شوند،
- ...کدام هشدارها باید به Alertmanager ارسال شوند.

نکته: پرومتئوس 2.41 همچنین اقدامات `keepequal` و `dropequal` را اضافه کرد که به شما امکان می‌دهد یک هدف را بر اساس برابری برچسب‌های منبع و هدف نگه دارید یا حذف کنید. با این حال، موارد استفاده برای این اقدامات نسبتاً نادر است، بنابراین ما آنها را به طور مفصل در اینجا پوشش نخواهیم داد.

### Rule structure

یک قانون relabeling `keep` دارای ساختار زیر است:

```yaml
action: keep
source_labels: [<source label name list>]
separator: <source labels separator>      # Defaults to ';'
regex: <regular expression>               # Defaults to '(.*)' (matching any value)
```




عمل `keep` مراحل زیر را به ترتیب انجام می‌دهد:

1. مقادیر برچسب‌های فهرست شده در `source_labels` را با استفاده از مقدار `separator` ارائه شده به هم متصل می‌کند.
2. آزمایش می‌کند که آیا عبارت منظم در `regex` با رشته به هم متصل شده از مرحله قبل مطابقت دارد یا خیر. اگر مطابقت وجود نداشته باشد، object از لیست خروجی نهایی حذف می‌شود.
3. اگر مطابقت وجود داشته باشد، object نگه داشته می‌شود.

عمل `drop` مانند `keep` کار می‌کند، اما به جای نگه داشتن یک object، آن را حذف می‌کند.

موارد استفاده مثال

بیایید به چند مورد استفاده مثال برای اقدامات `keep` و `drop` نگاه کنیم.

‏scrape فقط اهدافی با حاشیه نویسی scrape خاص

هنگام استفاده از target relabeling، ممکن است بخواهید فقط اهدافی را scrape کنید که دارای یک برچسب metadata خاص (ارائه شده توسط مکانیزم service discovery) هستند که نشان می‌دهد باید scrape شوند. برای مثال، موارد زیر به شما امکان می‌دهد فقط اهدافی را scrape کنید که دارای مقدار `example.io/should_be_scraped = true` در حاشیه نویسی Kubernetes هستند:


```yaml
action: keep
source_labels: [__meta_kubernetes_service_annotation_example_io_should_be_scraped]
regex: true
```


توجه داشته باشید که نام حاشیه نویسی فقط یک مثال است و استاندارد نشده است.

ذخیره فقط متریک‌های خاص

هنگام استفاده از `metric_relabel_configs` برای کنترل نحوه scrape یک هدف، می‌توانید از قانون زیر برای ذخیره فقط متریک‌هایی استفاده کنید که نام متریک آنها با پیشوند `api_` یا `http_` شروع می‌شود:


```yaml
action: keep
source_labels: [__name__]
regex: '(api_|http_).*'
```


---

### نگاشت  Label Sets

گاهی اوقات ممکن است بخواهید مجموعه‌ای کامل از برچسب‌های منبع را بگیرید و مقادیر آنها را به مجموعه‌ای جدید از نام‌های برچسب جدید با پیشوندهای متفاوت نگاشت کنید. عمل `labelmap` به شما امکان می‌دهد این کار را انجام دهید. رایج‌ترین مورد استفاده برای عمل `labelmap`، گرفتن گروهی از برچسب‌های فراداده با پیشوند `__meta` از یک منبع کشف سرویس و نگاشت آنها به برچسب‌های هدف دائمی است.

ساختار قانون

یک قانون relabeling `labelmap` دارای ساختار زیر است:

```yaml
action: labelmap
regex: <regular expression>               # Defaults to '(.*)' (matching any value)
replacement: <replacement string>         # Defaults to '$1' (using the first capturing group as a replacement)
```

برخلاف اقدامات relabeling قبلی که آموختیم، عمل labelmap با نام برچسب‌ها مطابقت regex انجام می‌دهد و بر روی آنها عمل می‌کند، نه مقادیر برچسب.

عمل labelmap مراحل زیر را به ترتیب انجام می‌دهد:

1. عبارت منظم در `regex` را با **تمام** نام‌های برچسب مطابقت می‌دهد.
2. سپس مقادیر نام‌های برچسب منطبق را به مجموعه‌ای از نام‌های برچسب جدید که توسط رشته `replacement` تعیین می‌شوند، کپی می‌کند. رشته `replacement` می‌تواند حاوی ارجاعات گروه ضبط regex ($1، $2، ...) برای درج بخش‌های استخراج شده از نام برچسب اصلی در نام برچسب مقصد باشد.

موارد استفاده مثال

بیایید به یک مورد استفاده مثال برای عمل `labelmap` نگاه کنیم.

#### Mapping Kubernetes service labels

هنگام استفاده از Kubernetes-based service discovery برای discover pod endpoints، ممکن است بخواهید برچسب‌های هدف نهایی برای هر نقطه پایانی نیز حاوی برچسب‌های سرویس Kubernetes باشد. کشف سرویس Kubernetes این موارد را در مجموعه‌ای از برچسب‌ها با الگوی نام‌گذاری `__meta_kubernetes_service_label_<labelname>` ارائه می‌کند. می‌توانیم قسمت `<labelname>` از آن برچسب‌های فراداده را استخراج کرده و مقادیر برچسب مربوطه را به مجموعه‌ای جدید از نام‌های برچسب که با پیشوند `k8s_` شروع می‌شوند، نگاشت کنیم، مانند این:


```yaml
action: labelmap
regex: __meta_kubernetes_service_label_(.+)
replacement: 'k8s_$1'
```

---

## Keeping and Dropping Labels

کمتر پیش می‌آید که بخواهید برچسب‌های منفرد را از یک object نگه دارید یا حذف کنید. برای مثال، برخی از اهداف تعداد زیادی برچسب اضافی (غیر شناسایی کننده) غیرضروری را در سری‌های زمانی ارائه می‌کنند که بعداً جالب نیستند و فقط TSDB و خروجی پرس و جو شما را آلوده می‌کنند. اقدامات `labelkeep` و `labeldrop` به شما امکان می‌دهند برخی از برچسب‌ها را به طور انتخابی نگه دارید یا حذف کنید.

ساختار قانون

یک قانون relabeling `labelkeep` دارای ساختار زیر است:

```yaml
action: labelkeep
regex: <regular expression>  # Defaults to '(.*)' (matching any value)
```



عمل `labelkeep` مراحل زیر را به ترتیب انجام می‌دهد:

1. عبارت منظم در `regex` را با تمام نام‌های برچسب مطابقت می‌دهد.
2. فقط برچسب‌هایی را نگه می‌دارد که مطابقت دارند.

عمل `labeldrop` مانند `labelkeep` کار می‌کند، اما به جای نگه داشتن یک برچسب، آن را حذف می‌کند.

موارد استفاده مثال

بیایید به چند مورد استفاده مثال برای عمل `labelkeep` نگاه کنیم.

#### Removing HA replica labels from alerts

هنگام اجرای دو سرور پرومتئوس یکسان به عنوان یک جفت با دسترس‌پذیری بالا (HA)، اغلب هر دو سرور پیکربندی می‌شوند که یک برچسب خارجی داشته باشند (از طریق گزینه پیکربندی سراسری external_labels) که نشان می‌دهد کدام replica را نشان می‌دهند، به عنوان مثال replica: A و replica: B. قبل از ارسال هشدارها به همان نمونه Alertmanager از هر دو replica، پرومتئوس باید این برچسب replica را حذف کند تا Alertmanager هشدارهای ورودی را متفاوت تفسیر نکند (در غیر این صورت، دو اعلان برای یک هشدار دریافت خواهید کرد، یکی با برچسب replica="A" و دیگری با replica="B")!

می‌توانید این برچسب replica را با قانون relabeling هشدار labeldrop زیر حذف کنید:

```yaml
action: labeldrop
regex: replica
```

حذف برچسب‌های غیرضروری از متریک‌ها

برخی از اهداف (مانند cAdvisor در گذشته) برچسب‌های اضافی را به هر سری زمانی متصل می‌کنند که برای شناسایی منحصربه‌فرد هر سری ضروری نیستند، بلکه فقط اطلاعات اضافی در مورد هدف یا سری ارائه می‌دهند که ممکن است نخواهید ذخیره کنید.

برای حذف هر برچسبی که با info_ شروع می‌شود از متریک‌های scrape شده، می‌توانید یک قانون relabeling متریک مانند این بنویسید:

```yaml
action: labeldrop
regex: info_.*
```

## Hashing and Sharding on Label Values

در شرایط نادر، ممکن است بخواهید یک تنظیمات پرومتئوس را به صورت horizontally با اجرای replicas  سرور پرومتئوس تقریباً یکسان، اما هر کدام فقط زیرمجموعه‌ای از تمام اهداف یک سرویس را scrape کنند، مقیاس‌بندی کنید. عمل relabeling `hashmod` (همراه با عمل `keep`) به ما امکان می‌دهد اهداف را برای این سناریو تقسیم‌بندی کنیم.

ساختار قانون

یک قانون relabeling `hashmod` دارای ساختار زیر است:

```yaml
action: hashmod
source_labels: [<source label name list>]
modulus: <modulus value>
target_label: <target label>
```


این عمل مراحل زیر را به ترتیب انجام می‌دهد:

1. مقادیر برچسب‌های فهرست شده در `source_labels` را با استفاده از مقدار `separator` ارائه شده به هم متصل می‌کند.
2. هش (در حال حاضر به عنوان مجموع MD5 پیاده‌سازی شده) رشته به هم متصل شده را محاسبه می‌کند.
3. مدول ارائه شده در `modulus` را به هش اعمال می‌کند (عملیات: `hash % modulus`)، تا هش را به مقداری بین `0` و `modulus - 1` محدود کند.
4. مقدار مدول از مرحله قبل را در برچسب ارائه شده به عنوان `target_label` ذخیره می‌کند.

موارد استفاده مثال

بیایید به یک مورد استفاده مثال برای عمل `hashmod` نگاه کنیم.

تقسیم‌بندی اهداف در یک سرویس

مورد استفاده اصلی برای استفاده از عمل `hashmod`، تقسیم گروه کلی اهداف یک سرویس به shardهایی برای هر replica از یک تنظیمات سرور پرومتئوس horizontally-scaled است. این کار با محاسبه ابتدا مدول مبتنی بر هش برای هر هدف بر اساس یک یا چند برچسب آن و سپس فقط نگه داشتن اهدافی که مقدار مدول خروجی خاصی دارند، انجام می‌شود. برای مثال، برای تقسیم‌بندی اهداف بر اساس برچسب `instance` آنها و فقط نگه داشتن نمونه‌ها برای تکه 2 (از 10 تکه)، می‌توانید یک `hashmod` را با یک عمل `keep` به این صورت ترکیب کنید:

```yaml
- action: hashmod
  source_labels: [instance]
  modulus: 10
  target_label: __tmp_hashmod
- action: keep
  source_labels: [__tmp_hashmod]
  regex: 2
```

---

تبدیل به حروف کوچک و بزرگ

گاهی اوقات ممکن است بخواهید حالت متن یک مقدار برچسب را تغییر دهید تا با حالت مقدار برچسب دیگری مطابقت داشته باشد، به طوری که بتوانید آنها را مقایسه کنید. برای مثال، ممکن است بخواهید یک مقدار برچسب را که با حروف بزرگ نوشته شده است با مقدار برچسب دیگری که با حروف کوچک نوشته شده است، مطابقت دهید. اقدامات relabeling `lowercase` و `uppercase` به شما امکان می‌دهد این کار را انجام دهید.

ساختار قانون

یک قانون relabeling `lowercase` دارای ساختار زیر است:

YAML

```
action: lowercase
source_labels: [<لیست نام برچسب منبع>]
target_label: <برچسب هدف>
```

این عمل مراحل زیر را به ترتیب انجام می‌دهد:

1. مقادیر برچسب‌های فهرست شده در `source_labels` را با استفاده از مقدار `separator` ارائه شده به هم متصل می‌کند.
2. آن مقدار به هم متصل شده را به حروف کوچک تبدیل می‌کند و آن را در برچسب ارائه شده به عنوان `target_label` ذخیره می‌کند.

عمل `uppercase` مانند `lowercase` کار می‌کند، اما به جای تبدیل خروجی به حروف کوچک، آن را به حروف بزرگ تبدیل می‌کند.

موارد استفاده مثال

بیایید به یک مورد استفاده مثال برای عمل `lowercase` نگاه کنیم.

تبدیل مقدار برچسب به حروف کوچک

تصور کنید دو صادرکننده دارید که متریک‌های سطح ماشین را به شما ارائه می‌دهند، یکی نام میزبان ماشین را با حروف بزرگ در برچسب `host` ارائه می‌کند و دیگری نام میزبان ماشین را با حروف کوچک در برچسب مشابه ارائه می‌کند. شما می‌خواهید بتوانید دو مقدار را مقایسه کنید، اما اگر در حالت‌های مختلف باشند، نمی‌توانید این کار را انجام دهید. می‌توانید از عمل `lowercase` برای تبدیل مقدار برچسب با حروف بزرگ به حروف کوچک استفاده کنید، تا بتوانید آنها را مقایسه کنید:

YAML

```
- action: lowercase
  source_labels: [host]
  target_label: host
```


---

خلاصه

در این آموزش، شما آموختید:

- انگیزه برای قوانین relabeling،
- چه اشیاء برچسب‌داری را می‌توان با استفاده از قوانین relabeling اصلاح و فیلتر کرد،
- نحوه تفسیر و بهره‌برداری از برچسب‌های فراداده پنهان در طول relabeling،
- نحوه نوشتن قوانین relabeling خاص برای دستیابی به اهداف مختلف.

اکنون باید بتوانید مفاهیم پشت قوانین relabeling را توضیح دهید و قوانین relabeling را برای اهداف مختلف بنویسید.