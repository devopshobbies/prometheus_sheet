
اکسپورتِر نود  (Node Exporter) احتمالاً یکی از اولین اکسپورترهایی است که استفاده خواهید کرد، همانطور که قبلاً مشاهده شد. این اکسپورتر متریک‌های سطح ماشین را، عمدتاً از هسته سیستم عامل شما، مانند CPU، حافظه، فضای دیسک، ورودی/خروجی دیسک، پهنای باند شبکه و دمای مادربرد، در معرض نمایش قرار می‌دهد. اکسپورتر نود با سیستم‌های یونیکس استفاده می‌شود؛ کاربران ویندوز باید به جای آن از اکسپورتر ویندوز² (Windows Exporter) استفاده کنند. اکسپورتر نود فقط برای نظارت بر خود ماشین در نظر گرفته شده است، نه فرآیندها یا سرویس‌های منفرد روی آن. سایر سیستم‌های مانیتورینگ اغلب چیزی دارند که ما دوست داریم آن را «عامل جامع» (uberagent) بنامیم؛ یعنی یک فرآیند واحد که همه چیز را روی ماشین نظارت می‌کند. در معماری پرومتئوس (Prometheus)، هر یک از سرویس‌های شما متریک‌های خود را، در صورت نیاز با استفاده از یک اکسپورتر، در معرض نمایش قرار می‌دهند که سپس مستقیماً توسط پرومتئوس اسکرِیپ (scrape) می‌شود. این کار از تبدیل شدن عامل جامع به یک گلوگاه عملیاتی یا عملکردی جلوگیری می‌کند و به شما امکان می‌دهد به جای ماشین‌ها، بیشتر در قالب سرویس‌های پویا فکر کنید.

دستورالعمل‌هایی که هنگام ایجاد متریک‌ها با ابزار دقیق مستقیم (direct instrumentation)، مانند موارد مورد بحث در «متریک‌هایم را چه نام‌گذاری کنم؟»  باید استفاده کنید، نسبتاً واضح هستند. این مورد در مورد اکسپورترها صدق نمی‌کند، جایی که بنا به تعریف، داده‌ها از منبعی می‌آیند که با در نظر گرفتن دستورالعمل‌های پرومتئوس طراحی نشده است. بسته به حجم و کیفیت متریک‌ها، توسعه‌دهندگان اکسپورتر باید بین تلاش مهندسی و به دست آوردن متریک‌های عالی، مصالحه‌هایی انجام دهند. در مورد لینوکس، هزاران متریک در دسترس است. برخی به خوبی مستند و درک شده‌اند، مانند استفاده از CPU؛ برخی دیگر، مانند استفاده از حافظه، با تغییر پیاده‌سازی از نسخه‌ای به نسخه دیگر هسته متفاوت بوده‌اند. حتی متریک‌هایی را خواهید یافت که کاملاً بدون مستندات هستند، جایی که برای فهمیدن کارکرد آن‌ها باید کد منبع هسته را بخوانید. اکسپورتر نود طوری طراحی شده است که به عنوان کاربر غیر روت (non-root) اجرا شود و باید مستقیماً روی ماشین به همان روشی که یک دیمون (daemon) سیستمی مانند sshd یا cron را اجرا می‌کنید، اجرا شود.

در حالی که اجرای اکسپورتر نود در داخل داکر³ (Docker) امکان‌پذیر است، برای مانت (mount) کردن فایل سیستم میزبان در داخل کانتینر، باید از برخی والیوم‌ها (volumes) و پارامترهای خط فرمان (`--path.procfs`, `--path.rootfs`, `--path.sysfs`) استفاده کنید. در صورت امکان، اکسپورتر نود را به عنوان یک سرویس روی نود، بدون داکر اجرا کنید. داکر تلاش می‌کند تا یک کانتینر را از عملکرد داخلی ماشین جدا کند، که این با تلاش اکسپورتر نود برای دسترسی به آن عملکردهای داخلی به خوبی کار نمی‌کند.

برخلاف اکثر اکسپورترهای دیگر، به دلیل تنوع گسترده متریک‌های موجود از سیستم‌عامل‌ها، اکسپورتر نود به شما امکان می‌دهد پیکربندی کنید که کدام دسته‌بندی از متریک‌ها را جمع‌آوری کند. می‌توانید این کار را با فلگ‌های خط فرمان مانند `--collector.wifi` که کالکتور (collector) وای‌فای را فعال می‌کند، و `--no-collector.wifi` که آن را غیرفعال می‌کند، انجام دهید. `--collector.disable-defaults` همه کالکتورها را به جز آن‌هایی که به صراحت با فلگ‌های خط فرمان فعال شده‌اند، غیرفعال می‌کند. پیش‌فرض‌های معقولی تنظیم شده‌اند، بنابراین این چیزی نیست که در شروع کار نگران آن باشید. هسته‌های مختلف متریک‌های متفاوتی را در معرض نمایش قرار می‌دهند، زیرا، به عنوان مثال، لینوکس و FreeBSD کارها را به روش‌های متفاوتی انجام می‌دهند. ممکن است متریک‌ها با گذشت زمان و با بازسازی (refactor) اکسپورتر نود بین کالکتورها جابجا شوند. اگر از سیستم یونیکس دیگری استفاده می‌کنید، متوجه خواهید شد که متریک‌ها و کالکتورهای ارائه شده متفاوت هستند. در این فصل، ما برخی از متریک‌های کلیدی را که اکسپورتر نود نسخه 1.4.0 با هسته لینوکس 5.18.0 در معرض نمایش قرار می‌دهد، توضیح می‌دهیم. این قرار نیست لیست کاملی از متریک‌های موجود باشد. مانند اکثر اکسپورترها و برنامه‌ها، شما می‌خواهید مسیر `/metrics` را بررسی کنید تا ببینید چه چیزی در دسترس است. می‌توانید عبارات PromQL نمونه را با استفاده از تنظیمات خود از فصل‌های قبلی امتحان کنید.

## کالکتور CPU

متریک اصلی از کالکتور CPU، `node_cpu_seconds_total` است، که یک شمارنده (counter) است که نشان می‌دهد هر CPU چقدر زمان در هر حالت (mode) صرف کرده است. لیبل‌ها (labels) `cpu` و `mode` هستند:

```
# HELP node_cpu_seconds_total Seconds the CPUs spent in each mode.
# TYPE node_cpu_seconds_total counter
node_cpu_seconds_total{cpu="0",mode="idle"} 13024.48
node_cpu_seconds_total{cpu="0",mode="iowait"} 9.53
node_cpu_seconds_total{cpu="0",mode="irq"} 0
node_cpu_seconds_total{cpu="0",mode="nice"} 0.11
node_cpu_seconds_total{cpu="0",mode="softirq"} 109.74
node_cpu_seconds_total{cpu="0",mode="steal"} 0
node_cpu_seconds_total{cpu="0",mode="system"} 566.67
node_cpu_seconds_total{cpu="0",mode="user"} 1220.36
node_cpu_seconds_total{cpu="1",mode="idle"} 13501.28
node_cpu_seconds_total{cpu="1",mode="iowait"} 5.96
node_cpu_seconds_total{cpu="1",mode="irq"} 0
node_cpu_seconds_total{cpu="1",mode="nice"} 0.09
node_cpu_seconds_total{cpu="1",mode="softirq"} 23.74
node_cpu_seconds_total{cpu="1",mode="steal"} 0
node_cpu_seconds_total{cpu="1",mode="system"} 423.84
node_cpu_seconds_total{cpu="1",mode="user"} 936.05
```


در لینوکس، **حالت‌های (مُدهای) مختلف CPU** مربوط به **تقسیم‌بندی زمان و اولویت‌بندی پردازش‌ها** هستند که در گزارش‌های مانیتورینگ (مثل `top`، `htop`، `mpstat` و ...) نمایش داده می‌شوند. این مُدها نشان می‌دهند که CPU در هر لحظه مشغول چه نوع کاری است.  



### 📊 **مُدهای اصلی CPU در گزارش‌های لینوکس** (مطابق خروجی `mpstat` و `top`)
این مُدها نشان می‌دهند **CPU زمان خود را چگونه تقسیم کرده است**:

| مُد CPU       | توضیح                                                                    | مثال‌هایی از کاربرد                        |
| ------------- | ------------------------------------------------------------------------ | ------------------------------------------ |
| **`user`**    | زمان پردازش برنامه‌های **کاربران عادی** (User Mode)                      | اجرای `firefox`، `nginx`، برنامه‌های کاربر |
| **`nice`**    | زمان پردازش برنامه‌های **با نیس (Nice) پایین/بالا** (اولویت تغییر یافته) | پردازش‌های کم‌اولویت مثل `backup`          |
| **`system`**  | زمان پردازش **هسته (Kernel Mode)**                                       | مدیریت سیستم‌کال‌ها، درایورهای سخت‌افزار   |
| **`irq`**     | زمان پردازش **وقفه‌های سخت‌افزاری (Interrupts)**                         | پردازش وقفه‌های صفحه‌کلید، شبکه، دیسک      |
| **`softirq`** | زمان پردازش **وقفه‌های نرم‌افزاری (Software Interrupts)**                | پردازش بسته‌های شبکه (`NET_RX`، `TASKLET`) |
| **`iowait`**  | زمان **انتظار برای I/O** (وقتی CPU بیکار است ولی منتظر دیسک/شبکه است)    | خواندن/نوشتن روی دیسک‌های کند              |
| **`steal`**   | زمان **دزدیده شده توسط هایپروایزر** در ماشین‌های مجازی                   | وقتی VM منابع CPU را از دست می‌دهد         |
| **`idle`**    | زمان **بیکاری CPU** (هیچ کاری انجام نمی‌دهد)                             | CPU در حال انتظار برای کار                 |

---

### 🔍 **توضیح جزئیات برخی مُدهای مهم**

#### ۱. **`nice` (نیس)**
- **نیس (Nice Value)** یک مقدار بین `-20` (بالاترین اولویت) تا `19` (پایین‌ترین اولویت) است.
- پردازش‌های با `nice` مثبت (مثل `+10`) **کم‌اولویت‌تر** هستند و CPU زمان کمتری به آن‌ها اختصاص می‌دهد.
- در گزارش `top`، ستون `NI` نشان‌دهنده‌ی مقدار نیس است.

#### ۲. **`irq` و `softirq`**
- ‏**IRQ (Interrupt Request)**: وقفه‌های سخت‌افزاری مثل فشار دادن کلید یا دریافت بسته شبکه.
- ‏**SoftIRQ**: وقفه‌های نرم‌افزاری که معمولاً برای پردازش‌های سریع شبکه/دیسک استفاده می‌شوند.
- مثلاً `NET_RX` مربوط به دریافت بسته‌های شبکه است.

#### ۳. **`iowait`**
- اگر `iowait` بالا باشد، نشان‌دهنده **مشکل در دیسک یا I/O** است (مثلاً دیسک کند است یا بار زیاد دارد).
- **تفاوت با `idle`**: در `idle` CPU واقعاً بیکار است، ولی در `iowait` CPU منتظر I/O است.

#### ۴. **`steal`**
- در محیط‌های مجازی (مثل KVM، VMware) نشان می‌دهد **هایپروایزر چقدر CPU را از ماشین مجازی گرفته است**.
- اگر `steal` بالا باشد، یعنی VM منابع کافی ندارد.

---

### 📉 **چگونه این مُدها را بررسی کنیم؟**
#### روش ۱: با `mpstat` (از بسته `sysstat`)
```bash
mpstat -P ALL 1  # نمایش آمار لحظه‌ای همه CPUها هر ۱ ثانیه
```
خروجی:
```
CPU  %user  %nice  %system  %irq  %softirq  %iowait  %steal  %idle
all  10.2   0.5    2.1      0.1   0.3       5.0      0.0     81.8
```

#### روش ۲: با `top`
- در `top`، کلید **`t`** را بزنید تا نمایش مُدهای CPU تغییر کند.
- خط `Cpu(s)` را ببینید:
  ```
  %Cpu(s):  5.0 us,  1.0 sy,  0.0 ni, 93.0 id,  1.0 wa,  0.0 hi,  0.0 si,  0.0 st
  ```
  - `us` = user, `sy` = system, `ni` = nice, `wa` = iowait, `st` = steal.

#### روش ۳: با `htop`
- در `htop`، مُدهای CPU در بالای صفحه به صورت گرافیکی نمایش داده می‌شوند.

---

### 🚀 **نتیجه‌گیری**
- ‏**`user` + `nice`**: زمان پردازش برنامه‌های کاربران.
- ‏**`system`**: زمان پردازش هسته.
- ‏**`irq` + `softirq`**: پردازش وقفه‌ها.
- ‏**`iowait`**: نشان‌دهنده گلوگاه I/O.
- ‏**`steal`**: مشکل در محیط‌های مجازی.
- ‏**`idle`**: CPU بیکار است.

اگر مثلاً `%system` شما بالاست، احتمالاً درایور یا سیستم‌کال مشکلی دارد. اگر `%iowait` بالا باشد، باید دیسک را بررسی کنید.

برای هر CPU، مجموع حالت‌ها در هر ثانیه یک ثانیه افزایش می‌یابد. این به شما امکان می‌دهد نسبت زمان بیکاری (idle) را در تمام CPUها با استفاده از عبارت PromQL محاسبه کنید:

`avg without(cpu, mode)(rate(node_cpu_seconds_total{mode="idle"}[1m]))`

این کاری می‌کند زیرا زمان بیکاری در هر ثانیه برای هر CPU را محاسبه می‌کند و سپس آن را در تمام CPUهای ماشین میانگین می‌گیرد. می‌توانید این را برای محاسبه نسبت زمان صرف شده در هر حالت برای یک ماشین با استفاده از عبارت زیر تعمیم دهید:
`avg without(cpu)(rate(node_cpu_seconds_total[1m]))`

استفاده از CPU توسط مهمان‌ها (یعنی ماشین‌های مجازی که تحت هسته اجرا می‌شوند) قبلاً در حالت‌های user و nice گنجانده شده است. می‌توانید زمان مهمان را به طور جداگانه در متریک `node_cpu_guest_seconds_total` مشاهده کنید.

### کالکتور Filesystem (فایل سیستم)

کالکتور فایل سیستم، همانطور که انتظار می‌رود، متریک‌هایی درباره فایل سیستم‌های مانت شده شما جمع‌آوری می‌کند، درست همانطور که از دستور `df` به دست می‌آورید. فلگ‌های `--collector.filesystem.mount-points-exclude` و `--collector.filesystem.fs-types-exclude` اجازه محدود کردن فایل سیستم‌های گنجانده شده را می‌دهند (پیش‌فرض‌ها شامل شبه‌فایل‌سیستم‌های (pseudofilesystems) مختلف نمی‌شوند). از آنجایی که اکسپورتر نود را به عنوان روت اجرا نخواهید کرد، باید اطمینان حاصل کنید که مجوزهای فایل به آن اجازه می‌دهد از فراخوانی سیستمی `statfs` روی نقاط مانت (mountpoints) مورد نظر شما استفاده کند.

تمام متریک‌های این کالکتور با پیشوند `node_filesystem_` شروع می‌شوند و دارای لیبل‌های `device`، `fstype` و `mountpoint` هستند:

```sh
# HELP node_filesystem_size_bytes Filesystem size in bytes.
# TYPE node_filesystem_size_bytes gauge
node_filesystem_size_bytes{device="/dev/sda5",fstype="ext4",mountpoint="/"} 9e+10
```

در **Prometheus**، لیبل‌های `device`، `fstype` و `mountpoint` برای مانیتورینگ **دیسک‌ها و فایل‌سیستم‌ها** استفاده می‌شوند و جزئیات مهمی را درباره‌ی ذخیره‌سازی سیستم ارائه می‌دهند. در اینجا توضیح هر لیبل به همراه مثال آورده شده است:

---

### 📌 **لیبل‌های اصلی دیسک در Prometheus**
| لیبل             | توضیحات                                         | مثال مقدار               | کاربرد نمونه                               |
| ---------------- | ----------------------------------------------- | ------------------------ | ------------------------------------------ |
| **`device`**     | نام دستگاه دیسک (مسیر دستگاه در سیستم)          | `sda1`، `nvme0n1p2`      | شناسایی دیسک خاص                           |
| **`fstype`**     | نوع فایل‌سیستم (فرمت ذخیره‌سازی داده‌ها)        | `ext4`، `xfs`، `btrfs`   | تشخیص فایل‌سیستم‌های پرکاربرد              |
| **`mountpoint`** | مسیر نصب (مکانی که دیسک در سیستم mount شده است) | `/`، `/var/lib`، `/home` | مانیتورینگ فضای اشغال‌شده در مسیرهای حیاتی |

---

### 🔍 **جزئیات بیشتر درباره هر لیبل**
#### ۱. **`device`**
- **مقادیر رایج**:  
  - دیسک‌های SATA/SCSI: `sda`، `sdb`، `sda1`  
  - دیسک‌های NVMe: `nvme0n1`، `nvme0n1p1`  
- **مثال در متریک**:  
  ```promql
  node_filesystem_size_bytes{device="/dev/nvme0n1p1"}
  ```

#### ۲. **`fstype`**
- **انواع رایج**:  
  - `ext4` (پیش‌فرض در بسیاری از توزیع‌های لینوکس)  
  - `xfs` (برای سیستم‌های با فایل‌های بزرگ)  
  - `btrfs`، `zfs` (برای snapshot و مدیریت پیشرفته)  
  - `tmpfs` (فایل‌سیستم موقت در RAM)  
- **مثال در کوئری**:  
  ```promql
  node_filesystem_avail_bytes{fstype="ext4"}
  ```

#### ۳. **`mountpoint`**
- **مسیرهای حیاتی**:  
  - `/` (ریت فایل‌سیستم)  
  - `/boot` (پارتیشن بوت)  
  - `/var` (برای لاگ‌ها و داده‌های متغیر)  
- **مثال در هشدار**:  
  ```promql
  node_filesystem_avail_bytes{mountpoint="/"} < 1GB  # هشدار برای پر شدن روت
  ```

---

### 🛠 **کاربردهای عملی**
۱. **پیدا کردن دیسک‌های پرکاربرد**:  
   ```promql
   rate(node_disk_read_bytes_total{device=~"sd.*|nvme.*"}[5m])
   ```

۲. **مانیتورینگ فضای آزاد بر اساس mountpoint**:  
   ```promql
   node_filesystem_avail_bytes{mountpoint="/home"} / node_filesystem_size_bytes{mountpoint="/home"} * 100
   ```

۳. **فیلتر کردن فایل‌سیستم‌های موقت**:  
   ```promql
   node_filesystem_size_bytes{fstype!="tmpfs"}
   ```

---

### 📊 **نمونه خروجی متریک با لیبل‌ها**
```promql
node_filesystem_size_bytes{device="/dev/nvme0n1p1", fstype="ext4", mountpoint="/"} 256GB

node_filesystem_avail_bytes{device="/dev/sda1", fstype="xfs", mountpoint="/var"} 50GB
```

---

### ❓ **چرا این لیبل‌ها مهم هستند؟**
- **عیب‌یابی**: اگر `/var` پر شود، می‌تواند باعث crash برنامه‌ها شود.  
- **بهینه‌سازی**: تشخیص دیسک‌های کند (`device`) یا فایل‌سیستم‌های ناکارآمد (`fstype`).  
- **هشداردهی**: اعلان هنگام پر شدن mountpoint‌های حیاتی.  

---


متریک‌های فایل سیستم عمدتاً بدیهی هستند. نکته ظریفی که باید از آن آگاه باشید تفاوت بین `node_filesystem_avail_bytes` و `node_filesystem_free_bytes` است. در فایل سیستم‌های یونیکس مقداری فضا برای کاربر روت رزرو شده است، تا زمانی که کاربران تمام فضای موجود را پر می‌کنند، همچنان بتوانند کارهایی انجام دهند. `node_filesystem_avail_bytes` فضای در دسترس کاربران است و هنگام تلاش برای محاسبه فضای دیسک استفاده شده، باید بر این اساس از فرمول زیر استفاده کنید:

```sh
node_filesystem_avail_bytes
/
node_filesystem_size_bytes
```

‏`node_filesystem_files` و `node_filesystem_files_free` تعداد آی‌نودها (inodes) و تعداد آی‌نودهای آزاد را نشان می‌دهند، که تقریباً تعداد فایل‌هایی است که فایل سیستم شما دارد. می‌توانید این را با `df -i` نیز مشاهده کنید.


در **Prometheus**، هر دو متریک `node_filesystem_avail_bytes` و `node_filesystem_free_bytes` مربوط به **فضای ذخیره‌سازی دیسک** هستند، اما تفاوت مهمی در معنی و کاربرد دارند. در اینجا مقایسه دقیق این دو متریک را بررسی می‌کنیم:

---

### 📊 **مقایسه `node_filesystem_avail_bytes` و `node_filesystem_free_bytes**

| **متریک**                      | **توضیح**                                                                 | **مثال کاربردی**                                                                 |
|---------------------------------|---------------------------------------------------------------------------|---------------------------------------------------------------------------------|
| **`node_filesystem_free_bytes`**   | **کل فضای خالی فیزیکی** روی دیسک (بدون در نظر گرفتن رزرو سیستم).<br>• شامل فضایی است که حتی ممکن است توسط سیستم رزرو شده باشد. | اگر دیسک ۱۰۰GB باشد و ۲۰GB آزاد داشته باشد، این مقدار **۲۰GB** را نشان می‌دهد (حتی اگر ۵GB برای root رزرو شده باشد). |
| **`node_filesystem_avail_bytes`**  | **فضای قابل استفاده توسط کاربران عادی** (پس از کسر فضای رزرو سیستم).<br>• این مقدار معمولاً **≤ free_bytes** است. | در همان مثال بالا، اگر ۵GB برای root رزرو شده باشد، این متریک **۱۵GB** را نشان می‌دهد (۲۰GB آزاد - ۵GB رزرو). |

---

### 🔍 **تفاوت کلیدی**
-‏ ‏**`free_bytes`** → فضای خام آزاد (بدون توجه به محدودیت‌های سیستم).  
-‏ ‏**`avail_bytes`** → فضای واقعاً قابل دسترس برای برنامه‌های کاربران عادی (پس از کسر سهم root و سایر رزروها).  

---

### 📌 **مثال عملی در PromQL**
۱. **هشدار برای فضای قابل استفاده (avail)**:  
   ```promql
   node_filesystem_avail_bytes{mountpoint="/"} / node_filesystem_size_bytes{mountpoint="/"} * 100 < 10
   ```
   - **هشدار** زمانی فعال می‌شود که کمتر از **۱۰٪** فضای دیسک برای کاربران عادی قابل استفاده باشد.

۲. **بررسی فضای آزاد خام (free)**:  
   ```promql
   node_filesystem_free_bytes{fstype="ext4"}
   ```
   - برای تحلیل **فضای فیزیکی باقی‌مانده** بدون در نظر گرفتن رزرو سیستم.

---

### 🖼️ **تصویرسازی تفاوت**
```
دیسک ۱۰۰GB:
│
├── فضای استفاده‌شده: ۷۰GB
├── Free (free_bytes): ۳۰GB
│   ├── رزرو سیستم: ۵GB (فقط برای root قابل استفاده)
│   └── Available (avail_bytes): ۲۵GB (برای کاربران عادی)
```

---

### ❓ **کدام متریک مهم‌تر است؟**
- برای **مانیتورینگ عمومی** → از `avail_bytes` استفاده کنید (زیرا وضعیت واقعی کاربران را نشان می‌دهد).  
- برای **بررسی فضای خام** → `free_bytes` مفید است (مثلاً وقتی می‌خواهید بدانید چقدر فضای خالی بدون تغییر تنظیمات سیستم دارید).  

---

### ⚠️ **نکته فنی**
- در برخی فایل‌سیستم‌ها (مثل `ext4`)، **۵٪ از فضای دیسک به طور پیش‌فرض برای root رزرو می‌شود** (برای جلوگیری از پر شدن کامل دیسک توسط کاربران عادی).  
- این رزرو با دستور `tune2fs` قابل تغییر است:  
  ```bash
  tune2fs -m 1 /dev/sda1  # تغییر رزرو به ۱٪
  ```




### کالکتور Diskstats (آمار دیسک)

کالکتور diskstats متریک‌های ورودی/خروجی دیسک را از `/proc/diskstats` در معرض نمایش قرار می‌دهد. به طور پیش‌فرض، فلگ `--collector.diskstats.device-exclude` سعی می‌کند چیزهایی را که دیسک واقعی نیستند، مانند پارتیشن‌ها و دستگاه‌های لوپ‌بک (loopback)، مستثنی کند:

```
# HELP node_disk_io_now The number of I/Os currently in progress.
# TYPE node_disk_io_now gauge
node_disk_io_now{device="sda"} 0
```

تمام متریک‌ها دارای لیبل `device` هستند و تقریباً همه شمارنده (counter) می‌باشند، به شرح زیر:

در اینجا جدول متریک‌های دیسک در Prometheus را مشاهده می‌کنید:

| متریک                                | توضیحات                                       |
| ------------------------------------ | --------------------------------------------- |
| `node_disk_io_now`                   | تعداد عملیات I/O در حال انجام روی دیسک        |
| `node_disk_io_time_seconds_total`    | زمان کل صرف شده برای عملیات I/O (به ثانیه)    |
| `node_disk_read_bytes_total`         | تعداد کل بایت‌های خوانده شده از دیسک          |
| `node_disk_read_time_seconds_total`  | زمان کل صرف شده برای عملیات خواندن (به ثانیه) |
| `node_disk_reads_completed_total`    | تعداد کل عملیات خواندن تکمیل شده              |
| `node_disk_written_bytes_total`      | تعداد کل بایت‌های نوشته شده روی دیسک          |
| `node_disk_write_time_seconds_total` | زمان کل صرف شده برای عملیات نوشتن (به ثانیه)  |
| `node_disk_writes_completed_total`   | تعداد کل عملیات نوشتن تکمیل شده               |

این جدول به شما کمک می‌کند تا:
۱. میزان فعالیت دیسک‌های خود را مانیتور کنید
۲. مشکلات مربوط به I/O را تشخیص دهید
۳. کارایی سیستم ذخیره‌سازی را تحلیل نمایید

برای استفاده از این متریک‌ها می‌توانید از کوئری‌های PromQL استفاده کنید، مثلاً:
```promql
rate(node_disk_read_bytes_total[5m])  # نرخ خواندن از دیسک
```

### کالکتور Netdev (دستگاه شبکه)

کالکتور netdev متریک‌هایی درباره دستگاه‌های شبکه شما با پیشوند `node_network_` و یک لیبل `device` در معرض نمایش قرار می‌دهد:

```sh
# HELP node_network_receive_bytes_total Network device statistic receive_bytes.
# TYPE node_network_receive_bytes_total counter
node_network_receive_bytes_total{device="lo"} 8.3213967e+07
node_network_receive_bytes_total{device="wlan0"} 7.0854462e+07
```

‏`node_network_receive_bytes_total` و `node_network_transmit_bytes_total` متریک‌های اصلی هستند که به آن‌ها اهمیت خواهید داد زیرا می‌توانید پهنای باند ورودی و خروجی شبکه را با آن‌ها محاسبه کنید:

`rate(node_network_receive_bytes_total[1m])`

ممکن است به `node_network_receive_packets_total` و `node_network_transmit_packets_total` نیز علاقه‌مند باشید که به ترتیب بسته‌های ورودی و خروجی را ردیابی می‌کنند.

## کالکتور Meminfo (اطلاعات حافظه)

کالکتور meminfo تمام متریک‌های استاندارد مربوط به حافظه شما را با پیشوند `node_memory_` دارد. همه این‌ها از `/proc/meminfo` شما می‌آیند، و این اولین کالکتوری است که معناشناسی (semantics) کمی مبهم می‌شود. کالکتور کیلوبایت‌ها را به بایت‌های ترجیحی تبدیل می‌کند، اما فراتر از آن، به شما بستگی دارد که به اندازه کافی از مستندات و تجربه با موارد داخلی لینوکس بدانید تا بفهمید این متریک‌ها چه معنایی دارند:

```sh
# HELP node_memory_MemTotal_bytes Memory information field MemTotal.
# TYPE node_memory_MemTotal_bytes gauge
node_memory_MemTotal_bytes 3.285016576e+10
```

به عنوان مثال، `node_memory_MemTotal_bytes` مقدار کل حافظه فیزیکی در ماشین است – خوب و واضح. اما توجه داشته باشید که هیچ متریک حافظه استفاده شده (used memory) وجود ندارد، بنابراین باید به نوعی آن را محاسبه کنید و در نتیجه بفهمید چقدر حافظه از متریک‌های دیگر استفاده نشده است.

‏`node_memory_MemFree_bytes` مقدار حافظه‌ای است که توسط هیچ چیزی استفاده نمی‌شود، اما این بدان معنا نیست که تمام حافظه‌ای است که در اختیار دارید. در تئوری، کش صفحه (page cache) شما (`node_memory_Cached_bytes`) و همچنین بافرهای نوشتن (write buffers) شما (`node_memory_Buffers_bytes`) قابل بازپس‌گیری هستند، اما این می‌تواند بر عملکرد برخی برنامه‌ها تأثیر منفی بگذارد. علاوه بر این، ساختارهای مختلف هسته دیگری وجود دارند که از حافظه استفاده می‌کنند مانند slab و جداول صفحه (page tables).

‏`node_memory_MemAvailable` یک روش اکتشافی (heuristic) از هسته برای میزان حافظه واقعاً در دسترس است، اما تنها در نسخه 3.14 لینوکس اضافه شد. اگر از هسته به اندازه کافی جدید استفاده می‌کنید، این متریکی است که می‌توانید برای تشخیص اتمام حافظه از آن استفاده کنید.

در لینوکس، **Slab** و **Page Tables** دو مکانیسم مهم برای مدیریت حافظه (Memory Management) هستند که نقش‌های متفاوتی ایفا می‌کنند.

---

### ۱. **Slab Allocator (تخصیص دهنده اسلب)**
#### 📌 **چیست؟**
- ‏**Slab** یک سیستم تخصیص حافظه **کارآمد برای اشیاء کوچک و پرتکرار** در هسته لینوکس است.
- برای جلوگیری از **تکهتکه شدن حافظه (Fragmentation)** و کاهش **سربار تخصیص/آزادسازی مکرر** طراحی شده است.

#### 🔍 **کاربرد اصلی**
- مدیریت حافظه برای:
  - **ساختارهای داده پرکاربرد هسته** (مثل `task_struct`، `inode`، `dentries`).
  - **اشیا کوچک** (مثلاً descriptorهای فایل، شبکه، و غیره).

#### 🛠 **مکانیسم کار**
- ‏**Slab** حافظه را به **حوضچه‌های از پیش اختصاص‌یافته (Cache)** تقسیم می‌کند.
- هر Cache برای یک نوع شیء خاص (مثلاً `inode_cache`) استفاده می‌شود.
- اشیاء آزاد شده بلافاصله حذف نمی‌شوند، بلکه برای استفاده بعدی **درون Cache نگهداری** می‌شوند.

#### 📊 **نمایش در لینوکس**
- با دستور `slabtop` می‌توان وضعیت Slab را مشاهده کرد:
  ```bash
  slabtop -o
  ```
  خروجی:
  ```
  OBJS   ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME
  1024    800    78%    256B      4     256     1MB     inode_cache
  ```

#### 🌟 **مزایا**
- کاهش **تأخیر تخصیص حافظه**.
- جلوگیری از **Fragmentation حافظه هسته**.

---

### ۲. **Page Tables (جداول صفحه)**
#### 📌 **چیست؟**
- ‏**Page Tables** ساختارهای داده‌ای هستند که **نگاشت آدرس‌های مجازی به فیزیکی** را مدیریت می‌کنند.
- هر پروسه در لینوکس آدرس‌های مجازی (Virtual Addresses) خود را دارد که باید به آدرس‌های فیزیکی (Physical Addresses) ترجمه شود.

#### 🔍 **کاربرد اصلی**
- پیاده‌سازی **حافظه مجازی (Virtual Memory)**.
- جداسازی حافظه بین پروسه‌ها (**ایزوله کردن حافظه**).

#### 🛠 **مکانیسم کار**
- **هر پروسه** جدول صفحه مخصوص به خود دارد.
- معماری‌های مختلف از **سطوح مختلف Page Table** استفاده می‌کنند (مثلاً ۴ سطح در x86-64):
  ۱. **PGD (Page Global Directory)**
  ۲. **PUD (Page Upper Directory)**
  ۳. **PMD (Page Middle Directory)**
  ۴. **PTE (Page Table Entry)**

#### 📊 **نمایش در لینوکس**
- میزان استفاده از Page Tables را می‌توان با `pmap` یا `/proc/meminfo` دید:
  ```bash
  grep "PageTables" /proc/meminfo
  ```
  خروجی:
  ```
  PageTables:   123456 kB
  ```

#### 🌟 **چالش‌ها**
- **سربار حافظه**: هر پروسه به فضایی برای Page Tables نیاز دارد.
- ‏**TLB Miss**: اگر ترجمه آدرس در حافظه پنهان (TLB) نباشد، دسترسی به حافظه کند می‌شود.

---

### � **مقایسه Slab و Page Tables**
| ویژگی            | Slab Allocator              | Page Tables                    |
| ---------------- | --------------------------- | ------------------------------ |
| **هدف**          | مدیریت اشیاء کوچک در هسته   | ترجمه آدرس‌های مجازی به فیزیکی |
| **سطح عمل**      | هسته لینوکس                 | سخت‌افزار/هسته (MMU)           |
| **وابسته به**    | اشیاء هسته (مثل `inode`)    | پروسه‌های کاربر و هسته         |
| **ابزار مشاهده** | `slabtop`، `/proc/slabinfo` | `pmap`، `/proc/meminfo`        |
| **مصرف حافظه**   | برای Cache اشیاء هسته       | برای نگاشت حافظه مجازی         |

---

### ❓ **چرا این مفاهیم مهم هستند؟**
- ‏**Slab** → اگر حافظه هسته (Slab) پر شود، سیستم ممکن است **کرش** کند (مثلاً به دلیل انباشت `dentry`).
- ‏**Page Tables** → اگر تعداد پروسه‌ها زیاد باشد، مصرف حافظه توسط Page Tables افزایش می‌یابد (مشاهده در `PageTables` در `/proc/meminfo`).

---

### مثال کاربردی:
۱. **عیب‌یابی حافظه Slab**:
   ```bash
   watch -n 1 "cat /proc/meminfo | grep -E 'Slab|SReclaimable|SUnreclaim'"
   ```

۲. **بررسی مصرف Page Tables یک پروسه**:
   ```bash
   pmap -x <PID>
   ```

---

### تفاوت **`free`** و **`available`**

در خروجی دستور `free -h` در لینوکس، دو مقدار **`free`** و **`available`** مربوط به **حافظه رم (RAM)** هستند، اما تفاوت مهمی بین آنها وجود دارد. در اینجا به زبان ساده توضیح می‌دهم:

---

### 📊 **مقایسه `free` و `available` در خروجی `free -h`**

| پارامتر         | توضیح به زبان ساده                                                                         | مثال (فرضی) | نکات کلیدی                                                                                                                                                      |
| --------------- | ------------------------------------------------------------------------------------------ | ----------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`free`**      | مقدار **رم کاملاً خالی و بلااستفاده**                                                      | `1.2G`      | - این حافظه **همین الان قابل استفاده** است.<br>- اما شامل حافظه‌های **کش شده (cache/buffer)** نمی‌شود.                                                          |
| **`available`** | مقدار **رمی که برنامه‌ها واقعاً می‌توانند استفاده کنند** (حتی اگر فعلاً استفاده شده باشد!) | `3.5G`      | - شامل حافظه `free` **+** حافظه‌های کش شده قابل آزادسازی (cache/buffers)<br>- همچنین شامل حافظه‌های **قابل بازپس‌گیری (reclaimable)** مثل Slabهای SReclaimable. |

---

### 🖼️ **تصویرسازی با مثال**
فرض کنید سیستم شما **۴ گیگابایت رم** دارد:
```
                    +---------------------+
                    |        RAM 4G       |
                    +---------------------+
                               |
         +---------------------+---------------------+
         |                     |                     |
      [Used: 2G]           [Cache: 0.8G]         [Free: 1.2G]
         |                     |
         |                (قابل آزاد شدن در صورت نیاز)
         |
   [برنامه‌های در حال اجرا]
```
- ‏**`free` = 1.2G** (رم کاملاً خالی).  
- ‏**`available` = 1.2G (free) + 0.8G (cache) ≈ 2G** (رمی که عملاً برای برنامه‌های جدید آزاد است).

---

### ❓ **چرا `available` مهم‌تر از `free` است؟**
- لینوکس به‌طور عمدی **حافظه بلااستفاده را برای کش (cache) استفاده می‌کند** تا عملکرد سیستم بهبود یابد.  
- مقدار `free` ممکن است **خیلی کم** نشان داده شود، اما سیستم همچنان **پرفورمنس خوبی دارد** چون `available` واقعی بیشتر است.  
- اگر `available` نزدیک به صفر شود، سیستم شروع به **سواپ (swap)** می‌کند (کاهش عملکرد!).

---

### 🔍 **چگونه این مقادیر را بخوانیم؟**
خروجی نمونه `free -h`:
```
              total        used        free      shared  buff/cache   available
Mem:           7.7G        2.1G        1.2G        123M        4.4G        5.0G
Swap:          2.0G        0B          2.0G
```
- ‏**`free` (1.2G)**: رم کاملاً آزاد.  
- ‏**`available` (5.0G)**: شامل `free` + حافظه‌های کش/بافر که در صورت نیاز آزاد می‌شوند.  

---

### 🛠 **چه زمانی نگران باشیم؟**
- اگر **`available` کمتر از ۱۰٪ کل رم** باشد (`7.7G * 0.1 ≈ 0.77G` در مثال بالا)، سیستم تحت فشار است.  
- اگر **`available` نزدیک به `free` باشد**، یعنی کش‌ها کم هستند (احتمالاً سیستم تازه بوت شده).

---

### ✅ **جمع‌بندی**
- ‏**`free`**: رم "هدررفته" (اما در واقع برای کش مفید است!).  
- ‏**`available`**: رم "واقعاً قابل استفاده" (مهم‌تر از `free`).  
- **خطای رایج**: تصور اینکه `free=0` به معنی مشکل است (در حالی که `available` معیار اصلی است).  

اگر مقدار `available` کم است، می‌توانید با دستور زیر حافظه کش را پاک کنید (موقتاً):  
```bash
echo 3 > /proc/sys/vm/drop_caches  # فقط برای تست!
``` 



## کالکتور Hwmon (نظارت سخت‌افزار)

هنگامی که روی سخت‌افزار فیزیکی (bare metal) هستید، کالکتور hwmon متریک‌هایی مانند دما و سرعت فن‌ها را با پیشوند `node_hwmon_` ارائه می‌دهد. این همان اطلاعاتی است که می‌توانید با دستور `sensors` به دست آورید:

```sh
# HELP node_hwmon_sensor_label Label for given chip and sensor
# TYPE node_hwmon_sensor_label gauge
node_hwmon_sensor_label{chip="platform_coretemp_0", label="core_0",sensor="temp2"} 1
node_hwmon_sensor_label{chip="platform_coretemp_0", label="core_1",sensor="temp3"} 1
# HELP node_hwmon_temp_celsius Hardware monitor for temperature (input)
# TYPE node_hwmon_temp_celsius gauge
node_hwmon_temp_celsius{chip="platform_coretemp_0",sensor="temp1"} 42
node_hwmon_temp_celsius{chip="platform_coretemp_0",sensor="temp2"} 42
node_hwmon_temp_celsius{chip="platform_coretemp_0",sensor="temp3"} 41
```

‏`node_hwmon_temp_celsius` دمای اجزای مختلف شما است، که ممکن است دارای لیبل‌های سنسور نیز باشند که در `node_hwmon_sensor_label` نمایش داده می‌شوند.

در حالی که این مورد برای همه سخت‌افزارها صدق نمی‌کند، برای برخی برای درک اینکه سنسور چیست، به لیبل سنسور نیاز دارید. در متریک‌های قبلی، `temp3` هسته شماره ۱ CPU را نشان می‌دهد.

می‌توانید لیبل `label` از `node_hwmon_sensor_label` را با استفاده از `group_left` به `node_hwmon_temp_celsius` متصل کنید، که در «Many-to-One و group_left» در آينده  بیشتر مورد بحث قرار گرفته است:

```
node_hwmon_temp_celsius
* ignoring(label) group_left(label)
node_hwmon_sensor_label
```

### کالکتور Stat (آمار)

کالکتور stat کمی ترکیبی است، زیرا متریک‌هایی را از `/proc/stat` ارائه می‌دهد. `node_boot_time_seconds` زمانی است که هسته شروع به کار کرده است، که از آن می‌توانید محاسبه کنید چه مدت هسته فعال بوده است:

`time() - node_boot_time_seconds`
‏‏
‏`node_intr_total` تعداد وقفه‌های سخت‌افزاری (hardware interrupts) را که داشته‌اید نشان می‌دهد. به آن `node_interrupts_total` گفته نمی‌شود، زیرا این نام توسط کالکتور interrupts استفاده می‌شود که به دلیل کاردینالیتی بالا به طور پیش‌فرض غیرفعال است. متریک‌های دیگر مربوط به فرآیندها هستند. `node_forks_total` یک شمارنده برای تعداد فراخوانی‌های سیستمی fork است، `node_context_switches_total` تعداد تعویض‌های زمینه (context switches) است، در حالی که `node_procs_blocked` و `node_procs_running` تعداد فرآیندهایی را که مسدود (blocked) یا در حال اجرا (running) هستند، نشان می‌دهند.

### کالکتور Uname (اطلاعات Uname)

کالکتور uname یک متریک واحد به نام `node_uname_info` را در معرض نمایش قرار می‌دهد که قبلاً در «پنل Stat»  آن را دیده‌اید:

```sh
# HELP node_uname_info Labeled system information as provided by the uname system call.
# TYPE node_uname_info gauge
node_uname_info{domainname="(none)",machine="x86_64",nodename="kozo", release="4.4.0-101-generic",sysname="Linux", version="#124-Ubuntu SMP Fri Nov 10 18:29:59 UTC 2017"} 1
```

لیبل `nodename` نام میزبان (hostname) ماشین است، که ممکن است با لیبل هدف `instance`  یا هر نام دیگری، مانند نام‌های موجود در DNS، که ممکن است برای آن داشته باشید، متفاوت باشد.

برای شمارش تعداد ماشین‌هایی که هر نسخه هسته را اجرا می‌کنند، می‌توانید از دستور زیر استفاده کنید:

`count by(release)(node_uname_info)`

## کالکتور OS (سیستم عامل)

کالکتور OS دو متریک `node_os_info` و `node_os_version` را در معرض نمایش قرار می‌دهد که اطلاعات سیستم عامل را به شما ارائه می‌دهند:

```sh
# HELP node_os_info A metric with a constant '1' value labeled by build_id, id, id_like, image_id, image_version, name, pretty_name, variant, variant_id, version, version_codename, version_id.
# TYPE node_os_info gauge
node_os_info{build_id="22.05.20220912.bf014ca",id="nixos", id_like="",image_id="",image_version="",name="NixOS", pretty_name="NixOS 22.05 (Quokka)",variant="", variant_id="",version="22.05 (Quokka)", version_codename="quokka",version_id="22.05"} 1
# HELP node_os_version Metric containing the major.minor part of the OS version.
# TYPE node_os_version gauge
node_os_version{id="nixos",id_like="",name="NixOS"} 22.05
```

برای شمارش تعداد ماشین‌هایی که هر نسخه توزیع (distro) را اجرا می‌کنند، می‌توانید از دستور زیر استفاده کنید:
`count by(name, version)(node_os_info)`


## کالکتور Loadavg (میانگین بار)

جمع‌آورنده loadavg میانگین بارهای 1، 5 و 15 دقیقه را به ترتیب به عنوان `node_load1`، `node_load5` و `node_load15` ارائه می‌کند.




#### **کالکتور `loadavg` در Prometheus چیست؟**  
کالکتور `loadavg` (مخفف **Load Average**) در Prometheus (معمولاً از طریق **`node_exporter`**) یک متریک کلیدی برای اندازه‌گیری **میانگین بار پردازشی (Load) سیستم** در بازه‌های زمانی مختلف ارائه می‌دهد. این کالکتور داده‌های مربوط به صف اجرای پردازش‌ها را از فایل `/proc/loadavg` لینوکس جمع‌آوری می‌کند.

---

#### ‏📌 **Load Average چیست؟**
‏Load Average نشان‌دهنده **تعداد پردازش‌های در حال اجرا یا منتظر برای اجرا** (در صف CPU و I/O) در سه بازه زمانی است:  
- **۱ دقیقه‌ای (`avg1`)**  
- **۵ دقیقه‌ای (`avg5`)**  
- **۱۵ دقیقه‌ای (`avg15`)**  

مثال خروجی از `/proc/loadavg`:
```
1.25 0.80 0.50 2/100 3510
```
- سه عدد اول: Load Average برای ۱، ۵ و ۱۵ دقیقه.  
- `2/100`: ۲ پردازش در حال اجرا از ۱۰۰ پردازش کل.  
- `3510`: آخرین PID اختصاص‌یافته.  

---

#### 📊 **متریک‌های کالکتور `loadavg` در Prometheus**
در `node_exporter`، این متریک‌ها تحت نام زیر گزارش می‌شوند:
```promql
node_load1   # میانگین بار ۱ دقیقه‌ای
node_load5   # میانگین بار ۵ دقیقه‌ای
node_load15  # میانگین بار ۱۵ دقیقه‌ای
```

---

#### 🔍 **تفاوت Load Average و Usage CPU**
| معیار                | Load Average                                         | CPU Usage                           |
| -------------------- | ---------------------------------------------------- | ----------------------------------- |
| **نحوه اندازه‌گیری** | تعداد پردازش‌های در صف اجرا (CPU + I/O)              | درصد استفاده از CPU                 |
| **مقدار ایده‌آل**    | ≤ تعداد هسته‌های CPU                                 | ≤ ۷۰-۸۰٪                            |
| **گلوگاه**           | اگر بیشتر از تعداد هسته‌ها باشد، سیستم اشباع شده است | اگر ۱۰۰٪ باشد، CPU کاملاً مشغول است |

---

#### ❓ **چگونه تفسیر کنیم؟**
- اگر سیستم **۴ هسته‌ای** داشته باشد:  
  - `node_load5 = 4` → سیستم کاملاً مشغول است.  
  - `node_load5 > 4` → پردازش‌ها در صف انتظار هستند (اشباع CPU یا I/O).  
  - `node_load5 < 4` → سیستم ظرفیت آزاد دارد.  

---

#### 🛠 **کاربردهای عملی در Prometheus**
##### ۱. **هشدار برای Load بالا**
```promql
# هشدار اگر Load متوسط ۵ دقیقه بیش از ۸۰ٞ٪ ظرفیت CPU باشد
expr: node_load5 / count(count(node_cpu_seconds_total{mode="idle"}) by (cpu)) > 0.8
```

##### ۲. **مقایسه Load با تعداد هسته‌ها**
```promql
# نسبت Load به تعداد هسته‌ها
node_load5 / count(node_cpu_seconds_total{mode="system"}) by (instance)
```

##### ۳. **تفکیک Load ناشی از CPU vs I/O**
- اگر `node_load5` بالا است ولی `avg(rate(node_cpu_seconds_total{mode="idle"}[5m]))` پایین نیست، احتمالاً **گلوگاه I/O** وجود دارد.

---

#### 📉 **نمونه گراف در Grafana**
می‌توانید Load Average را همراه با **مصرف CPU** و **I/O Wait** در یک داشبورد نمایش دهید:  
```promql
node_load5
rate(node_cpu_seconds_total{mode="iowait"}[5m])
```

---

##### ✅ **جمع‌بندی**
- **کالکتور `loadavg`** در `node_exporter` داده‌های Load Average سیستم را جمع‌آوری می‌کند.  
- ‏**Load Average** معیاری برای **صف اجرای پردازش‌ها** است (نه صرفاً مصرف CPU!).  
- مقدار بالای Load می‌تواند نشان‌دهنده **اشباع CPU** یا **گلوگاه I/O** باشد.  
- برای تفسیر صحیح، همیشه Load را با **تعداد هسته‌های CPU** مقایسه کنید.  

-------



معنی این متریک در پلتفرم‌های مختلف متفاوت است و ممکن است آن چیزی نباشد که شما فکر می‌کنید. برای مثال، در لینوکس، این فقط تعداد فرآیندهایی نیست که در صف اجرا منتظر هستند، بلکه فرآیندهای غیرقابل قطع شدن مانند فرآیندهایی که منتظر ورودی/خروجی هستند نیز شامل می‌شود.

جمع‌آورنده loadavg میانگین بارهای 1، 5 و 15 دقیقه را به ترتیب به عنوان `node_load1`، `node_load5` و `node_load15` ارائه می‌کند.

معنی این متریک در پلتفرم‌های مختلف متفاوت است و ممکن است آن چیزی نباشد که شما فکر می‌کنید. برای مثال، در لینوکس، این فقط تعداد فرآیندهایی نیست که در صف اجرا منتظر هستند، بلکه فرآیندهای غیرقابل قطع شدن مانند فرآیندهایی که منتظر ورودی/خروجی هستند نیز شامل می‌شود.

اگر هسته شما به اندازه کافی جدید است، توصیه می‌کنیم از جمع‌آورنده فشار (pressure collector) استفاده کنید.
میانگین بارها می‌توانند برای یک ایده سریع مفید باشند که آیا یک دستگاه اخیراً شلوغ‌تر شده است (برای برخی تعاریف شلوغ‌تر)، اما انتخاب خوبی برای هشدار دادن نیستند. 

این یک عدد احمقانه است اما مردم فکر می‌کنند مهم است.
> — یک نظر در فایل loadavg.c لینوکس.

## کالکتور Pressure (فشار)

اطلاعات توقف فشار (Pressure Stall Information - PSI) در هسته لینوکس نسخه 4.20 معرفی شد. این متریک‌ها فشار منابع را برای سه منبع اندازه‌گیری می‌کنند: CPU، حافظه و ورودی/خروجی (I/O). این قابلیت باید در زمان کامپایل در هسته فعال شود.

ممکن است هسته شما با پشتیبانی PSI ساخته شده باشد اما به طور پیش‌فرض غیرفعال باشد، در این صورت می‌توانید در زمان بوت (boot) `psi=1` را در خط فرمان هسته (kernel command line) برای فعال کردن آن ارسال کنید. پنج متریک مختلف توسط کالکتور PSI در معرض نمایش قرار می‌گیرند:

```sh
# HELP node_pressure_cpu_waiting_seconds_total Total time in seconds that processes have waited for CPU time
# TYPE node_pressure_cpu_waiting_seconds_total counter
node_pressure_cpu_waiting_seconds_total 113.6605130
# HELP node_pressure_io_stalled_seconds_total Total time in seconds no process could make progress due to IO congestion
# TYPE node_pressure_io_stalled_seconds_total counter
node_pressure_io_stalled_seconds_total 8.630361
# HELP node_pressure_io_waiting_seconds_total Total time in seconds that processes have waited due to IO congestion
# TYPE node_pressure_io_waiting_seconds_total counter
node_pressure_io_waiting_seconds_total 9.609997
# HELP node_pressure_memory_stalled_seconds_total Total time in seconds no process could make progress
# TYPE node_pressure_memory_stalled_seconds_total counter
node_pressure_memory_stalled_seconds_total 0
# HELP node_pressure_memory_waiting_seconds_total Total time in seconds that processes have waited for memory
# TYPE node_pressure_memory_waiting_seconds_total counter
node_pressure_memory_waiting_seconds_total 0
```


#### **‏Pressure Stall Information (PSI) چیست؟**  
‏**PSI** یک قابلیت در هسته لینوکس (از نسخه ۴٫۲۰ به بعد) است که **فشار (Pressure) روی منابع سیستمی مثل CPU، حافظه (RAM)، و I/O** را اندازه‌گیری می‌کند. برخلاف معیارهای سنتی (مثل `load average` یا `free memory`) که فقط وضعیت لحظه‌ای را نشان می‌دهند، PSI **تأخیرهای ناشی از کمبود منابع** را گزارش می‌دهد و به شما می‌گوید:  
**«چقدر زمان به دلیل کمبود یک منبع، پردازش‌ها متوقف (Stall) شده‌اند؟»**  

---

## 📌 **چرا PSI مهم است؟**
- **تشخیص مشکلات کارایی** (مثلاً کندی سیستم به دلیل کمبود RAM یا I/O).  
- **پیش‌بینی مشکلات قبل از وقوع** (مثلاً قبل از پر شدن کامل حافظه).  
- **بهتر از `load average`** چون علت تأخیر (CPU، حافظه، یا I/O) را مشخص می‌کند.  

---

## 🔍 **انواع فشار (Pressure) در PSI**
سه نوع فشار اصلی اندازه‌گیری می‌شود:  

### ۱. **CPU Pressure (`cpu.pressure`)**  
- زمانی که **پردازش‌ها منتظر CPU می‌مانند** (به دلیل اشباع شدن CPU).  
- مثال: وقتی چندین پردازش سنگین همزمان اجرا می‌شوند.  

### ۲. **حافظه (RAM) Pressure (`memory.pressure`)**  
- زمانی که **سیستم به دلیل کمبود حافظه مجبور به صفحه‌بندی (paging) یا سواپ (swap)** می‌شود.  
- مثال: وقتی `available memory` کم است و سیستم شروع به استفاده از `swap` می‌کند.  

### ۳. **I/O Pressure (`io.pressure`)**  
- زمانی که **پردازش‌ها منتظر عملیات I/O (مثل خواندن/نوشتن دیسک)** می‌مانند.  
- مثال: وقتی دیسک کند است یا بار I/O بسیار بالا است.  

---

## 📊 **چگونه PSI را بخوانیم؟**
اطلاعات PSI در فایل‌های زیر در `/proc` موجود است:  
- `/proc/pressure/cpu`  
- `/proc/pressure/memory`  
- `/proc/pressure/io`  

### مثال خروجی برای `memory.pressure`:
```bash
cat /proc/pressure/memory
```
خروجی:
```
some avg10=5.23 avg60=2.05 avg300=1.23 total=123456789
full avg10=1.87 avg60=0.75 avg300=0.30 total=98765432
```
- ‏**`some`**: درصد زمانی که **حداقل یک پردازش** به دلیل کمبود حافظه متوقف شده.  
- ‏**`full`**: درصد زمانی که **همه پردازش‌ها** به دلیل کمبود حافظه متوقف شده‌اند (شرایط بحرانی!).  
- ‏**`avg10`/`avg60`/`avg300`**: میانگین فشار در ۱۰ ثانیه، ۱ دقیقه و ۵ دقیقه گذشته.  
- ‏**`total`**: کل میکروثانیه‌های تأخیر از زمان بوت سیستم.  

---

## 🛠 **کاربردهای PSI**
### ۱. **مانیتورینگ لحظه‌ای**
```bash
watch -n 1 "cat /proc/pressure/{cpu,memory,io}"
```

### ۲. **هشداردهی (Alerting)**
مثلاً اگر فشار حافظه (`full`) بیش از ۱۰٪ در ۵ دقیقه باشد:  
```bash
avg300=$(cat /proc/pressure/memory | grep full | awk '{print $3}' | cut -d= -f2)
[ $(echo "$avg300 > 10" | bc) -eq 1 ] && echo "⚠️ Memory pressure too high!"
```

### ۳. **تنظیمات `cgroups` برای محدودیت منابع**
با PSI می‌توانید **سیاست‌های تخصیص منابع** را بر اساس فشار سیستم تعیین کنید (مثلاً اولویت‌دهی به پردازش‌های خاص).  

---

## 💡 **مقایسه PSI با معیارهای سنتی**
| معیار | PSI | `load average` | `free -h` |
|-------|-----|---------------|----------|
| **نحوه اندازه‌گیری** | تأخیرهای واقعی پردازش‌ها | تعداد پردازش‌های در صف اجرا | حافظه آزاد/مصرف‌شده |
| **تشخیص گلوگاه** | دقیقاً مشخص می‌کند (CPU/RAM/I/O) | فقط کلیات را نشان می‌دهد | فقط وضعیت حافظه را نشان می‌دهد |
| **پیش‌بینی مشکلات** | بله (قبل از وقوع) | خیر | خیر |

---

## 🚨 **چه زمانی PSI خطرناک است؟**
- اگر `full` برای حافظه (`memory.pressure`) بیش از **۱۰٪** باشد → سیستم در حال استفاده سنگین از **سواپ (swap)** است.  
- اگر `some` برای I/O (`io.pressure`) بیش از **۲۰٪** باشد → دیسک شما **گلوگاه** است.  
- اگر `full` برای CPU (`cpu.pressure`) بالا باشد → پردازنده **کاملاً اشباع** شده است.  

---

## ✅ **جمع‌بندی**
- ‏**PSI** معیاری هوشمند برای تشخیص **گلوگاه‌های منابع سیستم** است.  
- تفاوت اصلی آن با ابزارهای قدیمی: **اندازه‌گیری تأخیرهای واقعی (Stall Time)** به جای نمایش صرف مصرف منابع.  
- برای سرورهای حیاتی، مانیتورینگ PSI **ضروری** است (مخصوصاً برای حافظه و I/O).  

اگر می‌خواهید PSI را در ابزارهایی مثل **Prometheus** یا **Grafana** ادغام کنید، از **اکسپورترهایی مثل `node_exporter`** (با فعال کردن قابلیت PSI) استفاده کنید. 

متریک‌های `waiting` نشان‌دهنده کل زمان به ثانیه است که برخی وظایف منتظر بوده‌اند، و `stalled` به این معنی است که تمام وظایف به دلیل کمبود منابع به تأخیر افتاده‌اند. حافظه و I/O هر دو متریک `waiting` و `stalled` دارند، در حالی که CPU فقط `waiting` دارد. این به این دلیل است که CPU همیشه در حال اجرای یک فرآیند است.

از آنجایی که این‌ها شمارنده هستند، می‌توانید از آن‌ها با تابع `rate()` برای تعیین اینکه آیا برخی منابع بیش از حد بارگذاری شده‌اند استفاده کنید:

`rate(node_pressure_memory_waiting_seconds_total[1m])`

### کالکتور Textfile (فایل متنی)

کالکتور textfile کمی با کالکتورهایی که قبلاً به شما نشان دادیم متفاوت است. این کالکتور متریک‌ها را از هسته به دست نمی‌آورد، بلکه از فایل‌هایی که شما تولید می‌کنید، به دست می‌آورد. اکسپورتر نود قرار نیست به عنوان روت اجرا شود، بنابراین متریک‌هایی مانند متریک‌های SMART¹⁰ برای اجرای دستور `smartctl` به امتیازات روت (root privileges) نیاز دارند. علاوه بر متریک‌هایی که به روت نیاز دارند، برخی اطلاعات را فقط با اجرای دستوری مانند `iptables` می‌توانید به دست آورید. برای اطمینان‌پذیری، اکسپورتر نود فرآیندها را شروع نمی‌کند.

برای استفاده از کالکتور textfile، شما یک کران‌جاب (cronjob) ایجاد می‌کنید که به طور منظم دستوراتی مانند `smartctl` یا `iptables` را اجرا می‌کند، خروجی آن را به فرمت نمایش متنی پرومتئوس (Prometheus text exposition format) تبدیل می‌کند و آن را به صورت اتمی (atomically) در فایلی در یک دایرکتوری مشخص می‌نویسد. در هر اسکرِیپ (scrape)، اکسپورتر نود فایل‌های موجود در آن دایرکتوری را می‌خواند و متریک‌های آن‌ها را در خروجی خود قرار می‌دهد.

سرور پرومتئوس نمی‌تواند فایل‌های متنی را مستقیماً بخواند، بنابراین شما به نرم‌افزاری نیاز دارید تا فایل را به صورت HTTP در معرض نمایش قرار دهد. در حالی که می‌توانید از هر سرور HTTP استفاده کنید، اکسپورتر نود همچنین صحت متریک‌ها را بررسی می‌کند و قادر است متریک‌های حاصل از چندین فایل را در معرض نمایش قرار دهد.

می‌توانید از این کالکتور برای افزودن متریک‌های خود از طریق کران‌جاب‌ها استفاده کنید، یا می‌توانید اطلاعات ایستا (static) بیشتری داشته باشید که از فایل‌هایی می‌آیند که توسط سیستم مدیریت پیکربندی ماشین (machine configuration management system) شما نوشته شده‌اند تا برخی متریک‌های اطلاعاتی (info metrics) را ارائه دهند، مانند اینکه چه نقش‌های Chef¹¹ را دارد، درباره ماشین.

مانند اکسپورتر نود به طور کلی، کالکتور textfile برای متریک‌های مربوط به یک ماشین در نظر گرفته شده است. به عنوان مثال، ممکن است متریک هسته‌ای وجود داشته باشد که اکسپورتر نود هنوز آن را در معرض نمایش قرار نمی‌دهد، یا برای دسترسی به روت نیاز دارد. ممکن است بخواهید متریک‌های سطح سیستم عامل بیشتری را ردیابی کنید، مانند اینکه آیا به‌روزرسانی‌های بسته در انتظار هستند یا نیاز به راه‌اندازی مجدد (reboot) وجود دارد. در حالی که از نظر فنی یک سرویس است تا یک متریک سیستم عامل، ثبت زمان آخرین تکمیل کارهای دسته‌ای (batch jobs) مانند پشتیبان‌گیری (backups) برای نود Cassandra¹² که روی ماشین اجرا می‌شود نیز استفاده خوبی از کالکتور textfile خواهد بود، زیرا علاقه شما به اینکه آیا پشتیبان‌گیری‌ها روی آن ماشین کار کرده‌اند، با از بین رفتن ماشین از بین می‌رود. یعنی نود Cassandra چرخه عمر (lifecycle) مشابهی با ماشین دارد.

کالکتور textfile نباید برای تبدیل پرومتئوس به حالت پوش (push) استفاده شود. همچنین نباید از کالکتور textfile به عنوان راهی برای گرفتن متریک‌ها از سایر اکسپورترها و برنامه‌های در حال اجرا روی ماشین و نمایش همه آنها در `/metrics` اکسپورتر نود استفاده کنید، بلکه باید پرومتئوس هر اکسپورتر و برنامه را به صورت جداگانه اسکرِیپ کند.

### استفاده از کالکتور Textfile

کالکتور textfile به طور پیش‌فرض فعال است، اما برای کار کردن آن باید فلگ خط فرمان `--collector.textfile.directory` را به اکسپورتر نود ارائه دهید. این باید به دایرکتوری اشاره کند که صرفاً برای این منظور استفاده می‌کنید تا از اشتباهات جلوگیری شود.

برای امتحان کردن این، باید یک دایرکتوری ایجاد کنید، یک فایل ساده در فرمت نمایش (exposition format) بنویسید (همانطور که در «فرمت نمایش متنی» در صفحه ۸۰ بحث شد)، و اکسپورتر نود را با پیکربندی برای استفاده از این دایرکتوری، همانطور که در مثال ۷-۱ نشان داده شده است، شروع کنید. کالکتور textfile فقط به فایل‌هایی با پسوند `.prom` نگاه می‌کند.

مثال ۷-۱. استفاده از کالکتور textfile با یک مثال ساده

```
hostname $ mkdir textfile
hostname $ echo example_metric 1 > textfile/example.prom
hostname $ ./node_exporter --collector.textfile.directory=$PWD/textfile
```

مثال ۷ محتوای فایل ایجاد شده توسط مثال ۷-۱ را نشان می‌دهد.
مثال ۷. محتوای textfile/example.prom

```
example_metric 1
```

اگر به `/metrics` اکسپورتر نود نگاه کنید، اکنون متریک خود را خواهید دید:

```
# HELP example_metric Metric read from /some/path/textfile/example.prom
# TYPE example_metric untyped
example_metric 1
```

اگر هیچ HELP ارائه نشود، کالکتور textfile یکی برای شما ارائه می‌دهد. اگر همان متریک را در چندین فایل (البته با لیبل‌های مختلف) قرار می‌دهید، باید HELP یکسانی برای هر کدام ارائه دهید، زیرا در غیر این صورت HELP نامطابق باعث خطا می‌شود.

معمولاً شما فایل‌های `.prom` را با یک کران‌جاب ایجاد و به‌روز می‌کنید. از آنجایی که یک اسکرِیپ می‌تواند در هر زمانی اتفاق بیفتد، مهم است که اکسپورتر نود فایل‌هایی را که تا حدی نوشته شده‌اند نبیند. برای این منظور باید ابتدا در یک فایل موقت (temporary file) در همان دایرکتوری بنویسید و سپس فایل کامل را به نام فایل نهایی منتقل (move) کنید.

مثال ۷-۳ یک کران‌جاب را نشان می‌دهد که به کالکتور textfile خروجی می‌دهد. این کران‌جاب متریک‌ها را در یک فایل موقت¹⁵ ایجاد می‌کند و نام آنها را به نام فایل نهایی تغییر می‌دهد. این یک مثال پیش پا افتاده است که از دستورات کوتاه استفاده می‌کند، اما در بیشتر موارد استفاده واقعی، می‌خواهید یک اسکریپت برای خوانا نگه داشتن موارد ایجاد کنید.

مثال ۷-۳. فایل `/etc/crontab` که تعداد خطوط در `/etc/shadow` را به عنوان متریک `shadow_entries` با استفاده از کالکتور textfile در معرض نمایش قرار می‌دهد.

`TEXTFILE=/path/to/textfile/directory`

```sh
# این باید همه در یک خط باشد
*/5 * * * * root (echo -n 'shadow_entries '; grep -c . /etc/shadow) > $TEXTFILE/shadow.prom.$$ && mv $TEXTFILE/shadow.prom.$$ $TEXTFILE/shadow.prom
```

تعدادی اسکریپت نمونه برای استفاده با کالکتور textfile در مخزن GitHub اسکریپت‌های نمونه کالکتور textfile موجود است.

### مُهرهای زمانی (Timestamps)

در حالی که فرمت نمایش از مُهرهای زمانی پشتیبانی می‌کند، نمی‌توانید از آنها با کالکتور textfile استفاده کنید. این به این دلیل است که از نظر معنایی منطقی نیست، زیرا متریک‌های شما با همان مُهر زمانی سایر متریک‌های اسکرِیپ ظاهر نمی‌شوند. در عوض، mtime¹⁶ (زمان آخرین تغییر) فایل در متریک `node_textfile_mtime_seconds` در دسترس شماست. می‌توانید از این برای هشدار دادن در مورد کار نکردن کران‌جاب‌های خود استفاده کنید، زیرا اگر این مقدار مربوط به زمان خیلی دوری باشد، می‌تواند نشان‌دهنده یک مشکل باشد:

```sh
# HELP node_textfile_mtime_seconds Unixtime mtime of textfiles successfully read.
# TYPE node_textfile_mtime_seconds gauge
node_textfile_mtime_seconds{file="example.prom"} 1.516205651e+09
```

اکنون که اکسپورتر نود را در حال اجرا دارید، بیایید ببینیم چگونه می‌توانید به پرومتئوس در مورد تمام ماشین‌هایی که آن را روی آن‌ها اجرا می‌کنید، اطلاع دهید.
