
reff:

https://github.com/antonputra/tutorials/tree/main/lessons/141/prometheus-nginx-exporter

https://prometheus.io/docs/instrumenting/writing_exporters/


**نوشتن Exporter‌ها (WRITING EXPORTERS)**

اگر در حال ابزارگذاری (instrumenting) کد خود هستید، باید قوانین کلی نحوه ابزارگذاری کد با یک کتابخانه کلاینت پرومتئوس (Prometheus client library) را دنبال کنید. هنگام گرفتن متریک‌ها از یک سامانه پایش (monitoring) یا ابزارگذاری دیگر، مسائل معمولاً به این سادگی (سیاه و سفید) نیستند.

این سند شامل مواردی است که باید هنگام نوشتن یک Exporter (exporter) یا جمع‌آورنده سفارشی (custom collector) در نظر بگیرید. تئوری پوشش داده شده همچنین برای کسانی که ابزارگذاری مستقیم (direct instrumentation) انجام می‌دهند جالب خواهد بود.


**قابلیت نگهداری و خلوص (Maintainability and purity)**
تصمیم اصلی که هنگام نوشتن یک Exporter باید بگیرید این است که چقدر کار مایلید انجام دهید تا متریک‌های کاملی (perfect metrics) از آن بدست آورید.

اگر سیستم مورد نظر فقط تعداد انگشت‌شماری متریک دارد که به ندرت تغییر می‌کنند، دستیابی به کمال در همه چیز یک انتخاب آسان است؛ یک مثال خوب از این مورد، Exporter HAProxy است.

از طرف دیگر، اگر سعی کنید همه چیز را کامل کنید در حالی که سیستم صدها متریک دارد که با نسخه‌های جدید به طور مکرر تغییر می‌کنند، خود را برای کار مداوم زیادی آماده کرده‌اید. Exporter MySQL در این انتهای طیف قرار دارد.

‏Exporter node ترکیبی از این دو است، با پیچیدگی متفاوت در هر ماژول. به عنوان مثال، جمع‌آورنده `mdadm` یک فایل را به صورت دستی تجزیه (parse) می‌کند و متریک‌هایی را که به طور خاص برای آن جمع‌آورنده ایجاد شده‌اند، در معرض نمایش قرار می‌دهد (expose)، بنابراین بهتر است متریک‌ها را درست دریافت کنیم. برای جمع‌آورنده `meminfo`، نتایج در نسخه‌های مختلف کرنل متفاوت است، بنابراین ما فقط به اندازه‌ای تبدیل انجام می‌دهیم که متریک‌های معتبر ایجاد شوند.

**پیکربندی (Configuration)**
هنگام کار با برنامه‌ها، باید هدف‌تان یک Exporter باشد که به جز اطلاع دادن مکان برنامه، به هیچ پیکربندی سفارشی توسط کاربر نیاز نداشته باشد. همچنین ممکن است لازم باشد قابلیت فیلتر کردن برخی متریک‌ها را ارائه دهید، اگر ممکن است در تنظیمات بزرگ بسیار جزئی و پرهزینه باشند، به عنوان مثال Exporter HAProxy اجازه فیلتر کردن آمار هر سرور (per-server stats) را می‌دهد. به طور مشابه، ممکن است متریک‌های پرهزینه‌ای وجود داشته باشند که به طور پیش‌فرض غیرفعال هستند.

هنگام کار با سایر سیستم‌های مانیتورینگ، فریم‌ورک‌ها و پروتکل‌ها، اغلب نیاز به ارائه پیکربندی یا سفارشی‌سازی اضافی برای تولید متریک‌های مناسب برای پرومتئوس خواهید داشت. در بهترین حالت، یک سیستم مانیتورینگ دارای مدل داده‌ای به اندازه کافی شبیه به پرومتئوس است که می‌توانید به طور خودکار نحوه تبدیل متریک‌ها را تعیین کنید. این مورد برای Cloudwatch، SNMP و collectd صادق است. حداکثر، ما به این قابلیت نیاز داریم که به کاربر اجازه دهیم انتخاب کند کدام متریک‌ها را می‌خواهد استخراج کند.

در موارد دیگر، متریک‌های سیستم کاملاً غیراستاندارد هستند و به استفاده از سیستم و برنامه زیربنایی بستگی دارند. در این صورت کاربر باید به ما بگوید چگونه متریک‌ها را تبدیل کنیم. Exporter JMX بدترین نمونه در اینجاست، و Exporter‌های Graphite و StatsD نیز برای استخراج برچسب‌ها (labels) به پیکربندی نیاز دارند.

توصیه می‌شود اطمینان حاصل کنید که Exporter بدون پیکربندی اولیه (out of the box) کار می‌کند و در صورت نیاز، مجموعه‌ای از پیکربندی‌های نمونه برای تبدیل ارائه دهید.

‏YAML فرمت پیکربندی استاندارد پرومتئوس است، تمام پیکربندی‌ها باید به طور پیش‌فرض از YAML استفاده کنند.

**متریک‌ها (Metrics)**

**نام‌گذاری (Naming)**
بهترین شیوه‌ها (best practices) در نام‌گذاری متریک‌ها را دنبال کنید.

به طور کلی، نام متریک‌ها باید به کسی که با پرومتئوس آشناست اما با یک سیستم خاص آشنا نیست، اجازه دهد حدس خوبی در مورد معنای یک متریک بزند. متریکی به نام `http_requests_total` بسیار مفید نیست - آیا این‌ها هنگام ورود، در برخی فیلترها یا زمانی که به کد کاربر می‌رسند اندازه‌گیری می‌شوند؟ و `requests_total` حتی بدتر است، چه نوع درخواست‌هایی؟

با ابزارگذاری مستقیم، یک متریک معین باید دقیقاً در یک فایل وجود داشته باشد. بر این اساس، در Exporter‌ها و جمع‌آورنده‌ها، یک متریک باید دقیقاً به یک زیرسیستم (subsystem) اعمال شود و بر اساس آن نام‌گذاری شود.

نام متریک‌ها هرگز نباید به صورت رویه‌ای (procedurally) تولید شوند، مگر هنگام نوشتن یک جمع‌آورنده یا Exporter سفارشی.

نام متریک‌ها برای برنامه‌ها به طور کلی باید با نام Exporter پیشوند داشته باشند، به عنوان مثال `haproxy_up`.

متریک‌ها باید از واحدهای پایه (base units) استفاده کنند (مانند ثانیه، بایت) و تبدیل آن‌ها به چیزی خواناتر را به ابزارهای رسم نمودار بسپارند. مهم نیست در نهایت از چه واحدهایی استفاده می‌کنید، واحدهای موجود در نام متریک باید با واحدهای مورد استفاده مطابقت داشته باشند. به طور مشابه، نسبت‌ها (ratios) را در معرض نمایش قرار دهید، نه درصدها را. حتی بهتر از آن، یک شمارنده (counter) برای هر یک از دو مؤلفه نسبت مشخص کنید.

نام متریک‌ها نباید شامل برچسب‌هایی باشد که با آن‌ها صادر می‌شوند، به عنوان مثال `by_type`، زیرا اگر برچسب تجمیع (aggregate) شود، معنی نخواهد داشت.

تنها استثنا زمانی است که شما داده‌های یکسان را با برچسب‌های مختلف از طریق چندین متریک صادر می‌کنید، که در این صورت معمولاً این سالم‌ترین راه برای تمایز آن‌ها است. برای ابزارگذاری مستقیم، این فقط باید زمانی پیش بیاید که صادر کردن یک متریک واحد با تمام برچسب‌ها، کاردینالیتی (cardinality) بسیار بالایی داشته باشد.

نام متریک‌ها و برچسب‌های پرومتئوس با `snake_case` نوشته می‌شوند. تبدیل `camelCase` به `snake_case` مطلوب است، اگرچه انجام خودکار این کار همیشه نتایج خوبی برای مواردی مانند `myTCPExample` یا `isNaN` ایجاد نمی‌کند، بنابراین گاهی اوقات بهتر است آن‌ها را به همان شکل باقی گذاشت.

متریک‌های در معرض نمایش قرار گرفته نباید شامل دو نقطه (colon) باشند، این‌ها برای استفاده قوانین ضبط تعریف‌شده توسط کاربر (user defined recording rules) هنگام تجمیع رزرو شده‌اند.

فقط `[a-zA-Z0-9:_]` در نام متریک‌ها معتبر هستند.

پسوندهای `_sum`، `_count`، `_bucket` و `_total` توسط خلاصه‌ها (Summaries)، هیستوگرام‌ها (Histograms) و شمارنده‌ها (Counters) استفاده می‌شوند. مگر اینکه یکی از این‌ها را تولید کنید، از این پسوندها اجتناب کنید.

‏`_total` یک قرارداد (convention) برای شمارنده‌ها است، اگر از نوع `COUNTER` استفاده می‌کنید باید از آن استفاده کنید.

پیشوندهای `process_` و `scrape_` رزرو شده‌اند. اضافه کردن پیشوند خود به این‌ها در صورتی که از معناشناسی تطبیق پیروی کنند، اشکالی ندارد. به عنوان مثال، پرومتئوس `scrape_duration_seconds` را برای مدت زمان یک جمع‌آوری (scrape) دارد، تمرین خوبی است که یک متریک متمرکز بر Exporter نیز داشته باشید، به عنوان مثال `jmx_scrape_duration_seconds`، که نشان می‌دهد Exporter خاص چقدر طول کشید تا کار خود را انجام دهد. برای آمار فرآیند (process stats) که به PID دسترسی دارید، هم Go و هم Python جمع‌آورنده‌هایی را ارائه می‌دهند که این کار را برای شما انجام می‌دهند. یک مثال خوب از این مورد، Exporter HAProxy است.

وقتی تعداد درخواست‌های موفق و تعداد درخواست‌های ناموفق دارید، بهترین راه برای نمایش این مورد، یک متریک برای کل درخواست‌ها و متریک دیگری برای درخواست‌های ناموفق است. این محاسبه نسبت شکست (failure ratio) را آسان می‌کند. از یک متریک با برچسب `failed` یا `success` استفاده نکنید. به طور مشابه، برای `hit` یا `miss` در کش‌ها (caches)، بهتر است یک متریک برای کل و دیگری برای `hit` ها داشته باشید.

احتمال اینکه کسی که از مانیتورینگ استفاده می‌کند، نام متریک را در کد یا وب جستجو کند را در نظر بگیرید. اگر نام‌ها بسیار تثبیت شده‌اند و بعید است خارج از حوزه افرادی که به آن نام‌ها عادت دارند استفاده شوند، به عنوان مثال SNMP و مهندسان شبکه، آنگاه باقی گذاشتن آن‌ها به همان شکل ممکن است ایده خوبی باشد. این منطق برای همه Exporter‌ها صدق نمی‌کند، به عنوان مثال متریک‌های Exporter MySQL ممکن است توسط افراد مختلفی استفاده شوند، نه فقط مدیران پایگاه داده (DBA). یک رشته راهنما (HELP string) با نام اصلی می‌تواند بیشتر مزایای استفاده از نام‌های اصلی را فراهم کند.

**برچسب‌ها (Labels)**
توصیه‌های کلی در مورد برچسب‌ها را بخوانید.

از `type` به عنوان نام برچسب خودداری کنید، بسیار کلی است و اغلب بی‌معنی است. همچنین باید سعی کنید تا حد امکان از نام‌هایی که احتمالاً با برچسب‌های هدف (target labels) تداخل دارند، مانند `region`, `zone`, `cluster`, `availability_zone`, `az`, `datacenter`, `dc`, `owner`, `customer`, `stage`, `service`, `environment` و `env` اجتناب کنید. با این حال، اگر برنامه منبعی را به این نام می‌خواند، بهتر است با تغییر نام آن باعث سردرگمی نشوید.

از وسوسه قرار دادن چیزها در یک متریک فقط به این دلیل که پیشوند مشترکی دارند، خودداری کنید. مگر اینکه مطمئن باشید چیزی به عنوان یک متریک معنی‌دار است، استفاده از چندین متریک ایمن‌تر است.

برچسب `le` معنای خاصی برای هیستوگرام‌ها (Histograms) دارد و `quantile` برای خلاصه‌ها (Summaries). به طور کلی از این برچسب‌ها اجتناب کنید.

‏`Read/write` و `send/receive` بهتر است به عنوان متریک‌های جداگانه باشند، نه به عنوان یک برچسب. این معمولاً به این دلیل است که شما در یک زمان فقط به یکی از آن‌ها اهمیت می‌دهید و استفاده از آن‌ها به این شکل آسان‌تر است.

قاعده کلی این است که یک متریک باید هنگام جمع زدن (summed) یا میانگین گرفتن (averaged) معنی‌دار باشد. یک مورد دیگر وجود دارد که با Exporter‌ها پیش می‌آید، و آن جایی است که داده‌ها اساساً جدولی (tabular) هستند و انجام غیر از این، کاربران را ملزم به استفاده از عبارات منظم (regexes) روی نام متریک‌ها برای قابل استفاده بودن می‌کند. سنسورهای ولتاژ روی مادربورد خود را در نظر بگیرید، در حالی که انجام محاسبات ریاضی روی آن‌ها بی‌معنی است، منطقی است که آن‌ها را در یک متریک داشته باشید به جای داشتن یک متریک برای هر سنسور. تمام مقادیر درون یک متریک باید (تقریباً) همیشه واحد یکسانی داشته باشند، به عنوان مثال در نظر بگیرید اگر سرعت فن‌ها با ولتاژها مخلوط شده بود و راهی برای جداسازی خودکار آن‌ها نداشتید.

این کار را نکنید:

```
my_metric{label="a"} 1
my_metric{label="b"} 6
my_metric{label="total"} 7
```

یا این:

```
my_metric{label="a"} 1
my_metric{label="b"} 6
my_metric{} 7
```

مورد اول برای افرادی که `sum()` روی متریک شما انجام می‌دهند مشکل‌ساز است، و مورد دوم `sum` را خراب می‌کند و کار با آن بسیار دشوار است. برخی از کتابخانه‌های کلاینت، به عنوان مثال Go، فعالانه سعی می‌کنند شما را از انجام مورد دوم در یک جمع‌آورنده سفارشی باز دارند، و تمام کتابخانه‌های کلاینت باید شما را از انجام مورد دوم با ابزارگذاری مستقیم باز دارند. هرگز هیچ یک از این کارها را انجام ندهید، به جای آن به تجمیع پرومتئوس تکیه کنید.

اگر مانیتورینگ شما یک مجموع (total) مانند این را نمایش می‌دهد، مجموع را حذف کنید. اگر به دلایلی مجبور به نگه داشتن آن هستید، به عنوان مثال مجموع شامل مواردی است که به صورت جداگانه شمارش نشده‌اند، از نام‌های متریک متفاوتی استفاده کنید.

برچسب‌های ابزارگذاری (instrumentation labels) باید حداقل باشند، هر برچسب اضافی یکی دیگر است که کاربران باید هنگام نوشتن PromQL خود در نظر بگیرند. بر این اساس، از داشتن برچسب‌های ابزارگذاری که می‌توان بدون تأثیر بر یکتایی (uniqueness) سری زمانی (time series) حذف کرد، خودداری کنید. اطلاعات اضافی پیرامون یک متریک را می‌توان از طریق یک متریک اطلاعاتی (info metric) اضافه کرد، برای مثال، نحوه مدیریت شماره‌های نسخه را در زیر ببینید.

با این حال، مواردی وجود دارد که انتظار می‌رود تقریباً تمام کاربران یک متریک اطلاعات اضافی را بخواهند. اگر چنین است، اضافه کردن یک برچسب غیر یکتا، به جای یک متریک اطلاعاتی، راه حل مناسب است. به عنوان مثال، برچسب `digest` در متریک `mysqld_perf_schema_events_statements_total` Exporter `mysqld_exporter` یک هش از الگوی کامل کوئری است و برای یکتایی کافی است. با این حال، بدون برچسب `digest_text` قابل خواندن توسط انسان، که برای کوئری‌های طولانی فقط شامل شروع الگوی کوئری است و بنابراین یکتا نیست، کاربرد چندانی ندارد. بنابراین در نهایت هم برچسب `digest_text` برای انسان‌ها و هم برچسب `digest` برای یکتایی را داریم.

**برچسب‌های هدف، نه برچسب‌های جمع‌آوری شده استاتیک (Target labels, not static scraped labels)**
اگر زمانی متوجه شدید که می‌خواهید یک برچسب یکسان را به تمام متریک‌های خود اعمال کنید، دست نگه دارید.

به طور کلی دو مورد وجود دارد که این موضوع پیش می‌آید.

اولین مورد برای برخی برچسب‌ها است که داشتن آن‌ها روی متریک‌ها مفید خواهد بود، مانند شماره نسخه نرم‌افزار. به جای آن، از رویکرد شرح داده شده در https://www.robustperception.io/how-to-have-labels-for-machine-roles/ استفاده کنید.

مورد دوم زمانی است که یک برچسب واقعاً یک برچسب هدف (target label) است. این‌ها مواردی مانند منطقه (region)، نام‌های خوشه (cluster) و غیره هستند که از تنظیمات زیرساخت شما ناشی می‌شوند نه از خود برنامه. این وظیفه یک برنامه نیست که بگوید در طبقه‌بندی برچسب شما کجا قرار می‌گیرد، این وظیفه فردی است که سرور پرومتئوس را اجرا می‌کند و افراد مختلفی که همان برنامه را مانیتور می‌کنند ممکن است نام‌های متفاوتی به آن بدهند.

بر این اساس، این برچسب‌ها متعلق به تنظیمات جمع‌آوری (scrape configs) پرومتئوس از طریق هر کشف سرویسی (service discovery) که استفاده می‌کنید، هستند. اعمال مفهوم نقش‌های ماشین (machine roles) در اینجا نیز اشکالی ندارد، زیرا احتمالاً اطلاعات مفیدی برای حداقل برخی از افرادی است که آن را جمع‌آوری می‌کنند.

**انواع (Types)**
باید سعی کنید انواع متریک‌های خود را با انواع پرومتئوس مطابقت دهید. این معمولاً به معنای شمارنده‌ها (counters) و گیج‌ها (gauges) است. `_count` و `_sum` خلاصه‌ها نیز نسبتاً رایج هستند و گاهی اوقات کوانتیل‌ها (quantiles) را خواهید دید. هیستوگرام‌ها نادر هستند، اگر با یکی مواجه شدید به یاد داشته باشید که فرمت نمایش (exposition format) مقادیر تجمعی (cumulative values) را نشان می‌دهد.

اغلب مشخص نخواهد بود که نوع متریک چیست، به خصوص اگر به طور خودکار مجموعه‌ای از متریک‌ها را پردازش می‌کنید. به طور کلی `UNTYPED` (بدون نوع) یک پیش‌فرض امن است.

شمارنده‌ها نمی‌توانند کاهش یابند، بنابراین اگر یک نوع شمارنده از سیستم ابزارگذاری دیگری دارید که می‌تواند کاهش یابد، به عنوان مثال متریک‌های Dropwizard، پس آن یک شمارنده نیست، بلکه یک گیج است. `UNTYPED` احتمالاً بهترین نوع برای استفاده در آنجا است، زیرا `GAUGE` اگر به عنوان شمارنده استفاده شود، گمراه‌کننده خواهد بود.

**رشته‌های راهنما (Help strings)**
هنگامی که متریک‌ها را تبدیل می‌کنید، برای کاربران مفید است که بتوانند ردپای آنچه اصلی بود و قوانینی که باعث آن تبدیل شدند را دنبال کنند. قرار دادن نام جمع‌آورنده یا Exporter، شناسه هر قانونی که اعمال شده و نام و جزئیات متریک اصلی در رشته راهنما (help string) به کاربران کمک زیادی خواهد کرد.

پرومتئوس دوست ندارد یک متریک رشته‌های راهنمای متفاوتی داشته باشد. اگر یک متریک را از بسیاری دیگر می‌سازید، یکی از آن‌ها را برای قرار دادن در رشته راهنما انتخاب کنید.

برای نمونه‌هایی از این مورد، Exporter SNMP از OID استفاده می‌کند و Exporter JMX یک نام mBean نمونه را قرار می‌دهد. Exporter HAProxy رشته‌های دست‌نویس دارد. Exporter node نیز طیف گسترده‌ای از مثال‌ها را دارد.

**حذف آمارهای کمتر مفید (Drop less useful statistics)**
برخی از سیستم‌های ابزارگذاری نرخ‌های 1m، 5m، 15m، نرخ‌های متوسط از زمان شروع برنامه (این‌ها به عنوان مثال در متریک‌های Dropwizard، `mean` نامیده می‌شوند) علاوه بر حداقل‌ها، حداکثرها و انحرافات معیار را نمایش می‌دهند.

همه این‌ها باید حذف شوند، زیرا خیلی مفید نیستند و شلوغی ایجاد می‌کنند. پرومتئوس می‌تواند نرخ‌ها را خودش محاسبه کند، و معمولاً دقیق‌تر، زیرا میانگین‌های نمایش داده شده معمولاً به صورت نمایی کاهش می‌یابند (exponentially decaying). شما نمی‌دانید min یا max در چه زمانی محاسبه شده‌اند، و انحراف معیار از نظر آماری بی‌فایده است و همیشه می‌توانید مجموع مربعات، `_sum` و `_count` را در صورت نیاز به محاسبه آن، نمایش دهید.

کوانتیل‌ها (Quantiles) مسائل مرتبطی دارند، ممکن است انتخاب کنید آن‌ها را حذف کنید یا در یک خلاصه (Summary) قرار دهید.

**رشته‌های نقطه‌گذاری شده (Dotted strings)**
بسیاری از سیستم‌های مانیتورینگ برچسب ندارند، در عوض کارهایی مانند `my.class.path.mymetric.labelvalue1.labelvalue2.labelvalue3` انجام می‌دهند.

‏Exporter‌های Graphite و StatsD روشی برای تبدیل این‌ها با یک زبان پیکربندی کوچک به اشتراک می‌گذارند. سایر Exporter‌ها باید همین را پیاده‌سازی کنند. این تبدیل در حال حاضر فقط در Go پیاده‌سازی شده است و از تفکیک به یک کتابخانه جداگانه سود خواهد برد.

**جمع‌آورنده‌ها (Collectors)**
هنگام پیاده‌سازی جمع‌آورنده برای Exporter خود، هرگز نباید از رویکرد معمول ابزارگذاری مستقیم استفاده کنید و سپس متریک‌ها را در هر جمع‌آوری (scrape) به‌روز کنید.

بلکه هر بار متریک‌های جدیدی ایجاد کنید. در Go این کار با `MustNewConstMetric` در متد `Collect()` شما انجام می‌شود. برای Python به https://github.com/prometheus/client_python#custom-collectors مراجعه کنید و برای Java یک `List<MetricFamilySamples>` در متد `collect` خود تولید کنید، برای مثال به `StandardExports.java` مراجعه کنید.

دلیل این امر دوگانه است. اولاً، دو جمع‌آوری می‌توانند همزمان اتفاق بیفتند، و ابزارگذاری مستقیم از متغیرهایی استفاده می‌کند که عملاً متغیرهای سراسری سطح فایل (file-level global variables) هستند، بنابراین با شرایط رقابتی (race conditions) مواجه خواهید شد. ثانیاً، اگر یک مقدار برچسب ناپدید شود، همچنان صادر خواهد شد.

ابزارگذاری خود Exporter از طریق ابزارگذاری مستقیم خوب است، به عنوان مثال کل بایت‌های منتقل شده یا فراخوانی‌های انجام شده توسط Exporter در تمام جمع‌آوری‌ها. برای Exporter‌هایی مانند Exporter blackbox و Exporter SNMP، که به یک هدف واحد وابسته نیستند، این‌ها فقط باید در یک فراخوانی وانیلی (vanilla) `/metrics` نمایش داده شوند، نه در یک جمع‌آوری از یک هدف خاص.

**متریک‌های مربوط به خود جمع‌آوری (Metrics about the scrape itself)**
گاهی اوقات می‌خواهید متریک‌هایی را صادر کنید که مربوط به جمع‌آوری هستند، مانند مدت زمان آن یا تعداد رکوردهایی که پردازش کرده‌اید.

این‌ها باید به عنوان گیج (gauges) نمایش داده شوند زیرا مربوط به یک رویداد، یعنی جمع‌آوری، هستند و نام متریک باید با نام Exporter پیشوند داشته باشد، به عنوان مثال `jmx_scrape_duration_seconds`. معمولاً `_exporter` حذف می‌شود و اگر Exporter به عنوان یک جمع‌آورنده صرف نیز معنی‌دار باشد، قطعاً آن را حذف کنید.

از سایر متریک‌های "متا" (meta) جمع‌آوری باید اجتناب شود. به عنوان مثال، یک شمارنده برای تعداد جمع‌آوری‌ها، یا یک هیستوگرام از مدت زمان جمع‌آوری. ردیابی این متریک‌ها توسط Exporter، متریک‌های تولید شده خودکار خود پرومتئوس را تکرار می‌کند. این به هزینه ذخیره‌سازی هر نمونه Exporter می‌افزاید.

**متریک‌های ماشین و فرآیند (Machine and process metrics)**
بسیاری از سیستم‌ها، به عنوان مثال Elasticsearch، متریک‌های ماشین مانند CPU، حافظه و اطلاعات سیستم فایل را نمایش می‌دهند. از آنجایی که Exporter node این‌ها را در اکوسیستم پرومتئوس فراهم می‌کند، چنین متریک‌هایی باید حذف شوند.

در دنیای جاوا، بسیاری از فریم‌ورک‌های ابزارگذاری، آمارهای سطح فرآیند و سطح JVM مانند CPU و GC را نمایش می‌دهند. کلاینت جاوا و Exporter JMX قبلاً این‌ها را در فرم ترجیحی از طریق `DefaultExports.java` شامل می‌شوند، بنابراین این‌ها نیز باید حذف شوند.

به طور مشابه با سایر زبان‌ها و فریم‌ورک‌ها.

**استقرار (Deployment)**
هر Exporter باید دقیقاً یک نمونه برنامه را مانیتور کند، ترجیحاً درست در کنار آن روی همان ماشین قرار گیرد. این بدان معناست که برای هر HAProxy که اجرا می‌کنید، یک فرآیند `haproxy_exporter` اجرا می‌کنید. برای هر ماشینی با یک worker Mesos، Exporter Mesos را روی آن اجرا می‌کنید، و یکی دیگر برای master، اگر یک ماشین هر دو را داشته باشد.

تئوری پشت این امر این است که برای ابزارگذاری مستقیم این کاری است که انجام می‌دهید، و ما سعی می‌کنیم در چیدمان‌های دیگر تا حد امکان به آن نزدیک شویم. این بدان معناست که تمام کشف سرویس (service discovery) در پرومتئوس انجام می‌شود، نه در Exporter‌ها. این همچنین این مزیت را دارد که پرومتئوس اطلاعات هدف مورد نیاز خود را برای اجازه دادن به کاربران برای کاوش (probe) سرویس شما با Exporter blackbox دارد.

دو استثنا وجود دارد:

اولین مورد زمانی است که اجرا در کنار برنامه‌ای که مانیتور می‌کنید کاملاً بی‌معنی است. Exporter‌های SNMP، blackbox و IPMI نمونه‌های اصلی این مورد هستند. Exporter‌های IPMI و SNMP به این دلیل که دستگاه‌ها اغلب جعبه‌های سیاه (black boxes) هستند که اجرای کد روی آن‌ها غیرممکن است (اگرچه اگر می‌توانستید به جای آن یک Exporter node روی آن‌ها اجرا کنید بهتر بود)، و Exporter blackbox جایی که چیزی مانند یک نام DNS را مانیتور می‌کنید، که در آنجا نیز چیزی برای اجرا وجود ندارد. در این حالت، پرومتئوس همچنان باید کشف سرویس را انجام دهد و هدف را برای جمع‌آوری ارسال کند. برای مثال به Exporter‌های blackbox و SNMP مراجعه کنید.

توجه داشته باشید که در حال حاضر فقط با کتابخانه‌های کلاینت Go، Python و Java می‌توان این نوع Exporter را نوشت.

استثنای دوم زمانی است که شما برخی آمارها را از یک نمونه تصادفی یک سیستم بیرون می‌کشید و برایتان مهم نیست با کدام یک صحبت می‌کنید. مجموعه‌ای از رپلیکاهای (replicas) MySQL را در نظر بگیرید که می‌خواستید برخی کوئری‌های تجاری را روی داده‌ها اجرا کنید تا سپس صادر شوند. داشتن یک Exporter که از رویکرد معمول متعادل‌سازی بار (load balancing) شما برای صحبت با یک رپلیکا استفاده می‌کند، سالم‌ترین رویکرد است.

این مورد زمانی که شما در حال مانیتور کردن سیستمی با انتخاب مستر (master-election) هستید، صدق نمی‌کند، در این صورت باید هر نمونه را به صورت جداگانه مانیتور کنید و با "مستر بودن" (masterness) در پرومتئوس برخورد کنید. این به این دلیل است که همیشه دقیقاً یک مستر وجود ندارد، و تغییر اینکه یک هدف زیر پای پرومتئوس چیست، باعث ناهنجاری می‌شود.

**زمان‌بندی (Scheduling)**
متریک‌ها فقط باید زمانی از برنامه کشیده شوند که پرومتئوس آن‌ها را جمع‌آوری می‌کند، Exporter‌ها نباید بر اساس تایمرهای خودشان جمع‌آوری انجام دهند. یعنی تمام جمع‌آوری‌ها باید همزمان (synchronous) باشند.

بر این اساس، نباید بر روی متریک‌هایی که نمایش می‌دهید، مُهر زمانی (timestamps) تنظیم کنید، اجازه دهید پرومتئوس این کار را انجام دهد. اگر فکر می‌کنید به مُهر زمانی نیاز دارید، پس احتمالاً به جای آن به Pushgateway نیاز دارید.

اگر بازیابی یک متریک به خصوص پرهزینه است، یعنی بیش از یک دقیقه طول می‌کشد، قابل قبول است که آن را کش (cache) کنید. این باید در رشته راهنما (HELP string) ذکر شود.

مهلت زمانی (timeout) جمع‌آوری پیش‌فرض برای پرومتئوس 10 ثانیه است. اگر انتظار می‌رود Exporter شما از این فراتر رود، باید صراحتاً این موضوع را در مستندات کاربر خود ذکر کنید.

**ارسال‌ها (Pushes)**
برخی برنامه‌ها و سیستم‌های مانیتورینگ فقط متریک‌ها را ارسال (push) می‌کنند، به عنوان مثال StatsD، Graphite و collectd.

دو نکته در اینجا وجود دارد.

اولاً، چه زمانی متریک‌ها را منقضی (expire) می‌کنید؟ Collectd و چیزهایی که با Graphite صحبت می‌کنند هر دو به طور منظم صادر می‌کنند، و وقتی متوقف می‌شوند می‌خواهیم نمایش متریک‌ها را متوقف کنیم. Collectd شامل زمان انقضا است، بنابراین ما از آن استفاده می‌کنیم، Graphite ندارد، بنابراین این یک پرچم (flag) روی Exporter است.

‏StatsD کمی متفاوت است، زیرا با رویدادها (events) سروکار دارد نه متریک‌ها. بهترین مدل این است که یک Exporter در کنار هر برنامه اجرا کنید و هنگامی که برنامه راه‌اندازی مجدد می‌شود، آن‌ها را نیز راه‌اندازی مجدد کنید تا وضعیت پاک شود.

ثانیاً، این نوع سیستم‌ها تمایل دارند به کاربران شما اجازه دهند یا دلتاها (deltas) یا شمارنده‌های خام (raw counters) را ارسال کنند. شما باید تا حد امکان به شمارنده‌های خام تکیه کنید، زیرا این مدل کلی پرومتئوس است.

برای متریک‌های سطح سرویس (service-level metrics)، به عنوان مثال کارهای دسته‌ای (batch jobs) سطح سرویس، باید Exporter خود را به Pushgateway ارسال (push) کنید و پس از رویداد خارج شوید به جای اینکه خودتان وضعیت را مدیریت کنید. برای متریک‌های دسته‌ای سطح نمونه (instance-level batch metrics)، هنوز الگوی مشخصی وجود ندارد. گزینه‌ها یا سوء استفاده از جمع‌آورنده textfile Exporter node، تکیه بر وضعیت درون حافظه (in-memory state) (احتمالاً بهترین گزینه اگر نیازی به پایداری پس از راه‌اندازی مجدد ندارید) یا پیاده‌سازی عملکردی مشابه جمع‌آورنده textfile است.

**جمع‌آوری‌های ناموفق (Failed scrapes)**
در حال حاضر دو الگو برای جمع‌آوری‌های ناموفق وجود دارد که در آن برنامه‌ای که با آن صحبت می‌کنید پاسخ نمی‌دهد یا مشکلات دیگری دارد.

اولین مورد بازگرداندن خطای 5xx است.

دومین مورد داشتن یک متغیر `myexporter_up` است، به عنوان مثال `haproxy_up`، که بسته به اینکه جمع‌آوری موفقیت‌آمیز بوده یا نه، مقدار 0 یا 1 دارد.

مورد دوم بهتر است در جایی که هنوز متریک‌های مفیدی وجود دارد که حتی با یک جمع‌آوری ناموفق می‌توانید بدست آورید، مانند Exporter HAProxy که آمار فرآیند را ارائه می‌دهد. برخورد با مورد اول برای کاربران کمی آسان‌تر است، زیرا `up` به روش معمول کار می‌کند، اگرچه نمی‌توانید بین پایین بودن Exporter و پایین بودن برنامه تمایز قائل شوید.

**صفحه فرود (Landing page)**
برای کاربران بهتر است اگر بازدید از `http://yourexporter/` یک صفحه HTML ساده با نام Exporter و پیوندی به صفحه `/metrics` داشته باشد.

**شماره پورت‌ها (Port numbers)**
یک کاربر ممکن است چندین Exporter و مؤلفه پرومتئوس روی یک ماشین داشته باشد، بنابراین برای آسان‌تر کردن این کار، هر کدام یک شماره پورت منحصر به فرد دارند.

https://github.com/prometheus/prometheus/wiki/Default-port-allocations جایی است که ما آن‌ها را ردیابی می‌کنیم، این صفحه به صورت عمومی قابل ویرایش است.

هنگام توسعه Exporter خود، آزادانه شماره پورت آزاد بعدی را انتخاب کنید، ترجیحاً قبل از اعلام عمومی آن. اگر هنوز برای انتشار آماده نیستید، قرار دادن نام کاربری خود و WIP اشکالی ندارد.

این یک رجیستری برای آسان‌تر کردن زندگی کاربران ما است، نه تعهدی برای توسعه Exporter‌های خاص. برای Exporter‌های برنامه‌های داخلی، توصیه می‌کنیم از پورت‌های خارج از محدوده تخصیص پورت پیش‌فرض استفاده کنید.

**اعلام کردن (Announcing)**
هنگامی که آماده اعلام Exporter خود به جهان هستید، به لیست پستی ایمیل بزنید و یک PR برای اضافه کردن آن به لیست Exporter‌های موجود ارسال کنید.