در این آموزش، شما با بازبرچسب‌زنی (relabeling) آشنا خواهید شد، که یک زبان پیکربندی متا برای Prometheus است و نقش central در تبدیل و فیلتر کردن اشیاء برچسب‌دار در Prometheus مانند اهداف (targets)، نمونه‌های جمع‌آوری شده (scraped samples) یا هشدارها (alerts) ایفا می‌کند.

پس از این آموزش، شما خواهید دانست که قوانین بازبرچسب‌زنی چگونه کار می‌کنند و قادر خواهید بود آن‌ها را در سناریوهای مختلف به کار ببرید، مانند نگاشت برچسب‌ها از ابرداده‌های کشف سرویس (service discovery metadata) به برچسب‌های هدف (target labels) یا فیلتر کردن نمونه‌های جمع‌آوری شده.



**پیش‌نیازها**

این بخش نرم‌افزارها و تجربه‌های پیش‌نیاز برای این آموزش را مشخص می‌کند.

**الزامات نرم‌افزاری**

این آموزش غیرتعاملی است و صرفاً مفاهیم را توضیح می‌دهد، بنابراین نیازی به نصب نرم‌افزار نیست.

**تجربه مورد نیاز**

شما به درک پایه‌ای از مانیتورینگ مبتنی بر پرومتئوس نیاز دارید، که می‌توانید آن را در آموزش رایگان "مقدمه‌ای بر پرومتئوس" ما کسب کنید.


## انگیزه

پرومتئوس انواع مختلف **اشیاء برچسب‌دار** را کشف، جمع‌آوری و پردازش می‌کند. بارزترین این اشیاء، اهداف جمع‌آوری و نمونه‌های سری زمانی هستند، اما هشدارها نیز برچسب دارند:



![[src/relabela.png]]



اغلب مفید است که بتوان این اشیاء را بر اساس مقادیر برچسب‌هایشان دستکاری یا فیلتر کرد. برای مثال، ممکن است بخواهیم:

- فقط **اهداف خاصی را مانیتور کنیم** که دارای یک حاشیه نویسی کشف سرویس خاص هستند که نشان می‌دهد باید جمع‌آوری شوند.
- **یک پارامتر پرس و جو HTTP را به درخواست جمع‌آوری** برای یک هدف اضافه کنیم.
- فقط **زیرمجموعه فیلتر شده‌ای از نمونه‌های** جمع‌آوری شده از یک هدف معین را ذخیره کنیم.
- **یک برچسب تکراری را از هشدارهای ارسال شده به Alertmanager حذف کنیم** (به طوری که هشدارهای یکسان ارسال شده از یک جفت سرور پرومتئوس با دسترس‌پذیری بالا بتوانند در Alertmanager حذف تکراری شوند).
- **دو مقدار برچسب یک سری جمع‌آوری شده را در یک برچسب واحد ترکیب کنیم** (یا برعکس).

**بازبرچسب‌گذاری (Relabeling)** مفهومی است که به مدیر پرومتئوس اجازه می‌دهد این نوع قوانین تبدیل و فیلتر را پیکربندی کند.

---

بازبرچسب‌گذاری به عنوان مجموعه‌ای از مراحل تبدیل پیاده‌سازی می‌شود که می‌توانید در بخش‌های مختلف فایل پیکربندی پرومتئوس برای فیلتر یا اصلاح لیستی از اشیاء برچسب‌دار اعمال کنید. می‌توانید 
بازبرچسب‌گذاری را بر روی انواع زیر از اشیاء برچسب‌دار اعمال کنید:

| Relabeled Object Type                          | Configuration Section                                                                                                                                                |
| ---------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Discovered **scrape targets**                  | `relabel_configs` section in a [`scrape_config`](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config) section                    |
| Discovered **Alertmanager targets**            | `relabel_configs` section in an [`alertmanager_config`](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config) section       |
| Individual **samples from scrapes**            | `metric_relabel_configs` section in a [`scrape_config`](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config) section             |
| **Alerts** sent to _all_ Alertmanagers         | `alert_relabel_configs` section in the `alerting` section of the main configuration file                                                                             |
| **Alerts** sent to a _subset_ of Alertmanagers | `alert_relabel_configs` section in an [`alertmanager_config`](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config) section |
| **Samples written to remote storage systems**  | `write_relabel_configs` section in the [`remote_write`](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#remote_write) section              |


![[src/relabling2.png]]
تمام این بخش‌های مختلف پیکربندی بازبرچسب‌گذاری از یک نوع هستند: `relabel_config`.

یک بخش پیکربندی بازبرچسب‌گذاری شامل لیستی از قوانینی است که به ترتیب بر روی هر شیء برچسب‌دار اعمال می‌شوند. هر قانون در زنجیره ممکن است یک شیء برچسب‌دار را اصلاح یا حذف کند:

![[relabing3.png]]

برای مثال، یک قانون بازبرچسب‌گذاری ممکن است یک شیء را بر اساس مطابقت یک عبارت منظم نگه دارد یا حذف کند، ممکن است برچسب‌های آن را تغییر دهد، یا ممکن است مجموعه‌ای کامل از برچسب‌ها را به مجموعه‌ای دیگر نگاشت کند. هنگامی که یک مرحله بازبرچسب‌گذاری تصمیم به حذف یک شیء برچسب‌دار می‌گیرد، هیچ مرحله بازبرچسب‌گذاری دیگری برای این شیء اجرا نمی‌شود و از لیست خروجی حذف می‌شود (برای مثال، برای یک هدف، این به معنای آن است که جمع‌آوری نخواهد شد).

---

**برچسب‌های پنهان و فراداده (Metadata)**

برچسب‌هایی که با دو خط زیرین (__) شروع می‌شوند، به طور خودکار پس از آخرین قانون بازبرچسب‌گذاری حذف می‌شوند  و بنابراین به برچسب‌های نهایی یک شیء وارد نمی‌شوند. این برچسب‌های با پیشوند ویژه می‌توانند برای ذخیره و انتقال فراداده اضافی در طول مرحله بازبرچسب‌گذاری برای تصمیم‌گیری یا تغییر برچسب‌های شیء استفاده شوند. برای مثال، یک مکانیزم کشف سرویس ممکن است در ابتدا فراداده اضافی را برای هر هدف در این برچسب‌های "پنهان" ارائه دهد.

**برچسب‌های کنترل جمع‌آوری (Scrape)**

برای اهداف، برخی از این برچسب‌های پنهان معنای خاصی دارند و نحوه جمع‌آوری یک هدف توسط پرومتئوس را کنترل می‌کنند:

- ‏`__address__`: این برچسب آدرس TCP را که باید برای هدف جمع‌آوری شود، شامل می‌شود. در ابتدا به جفت `<host>:<port>` هدف که توسط مکانیزم کشف سرویس ارائه شده است، تنظیم می‌شود. پس از بازبرچسب‌گذاری، پرومتئوس برچسب `instance` را به مقدار `__address__` تنظیم می‌کند، اگر قبل از آن، برچسب `instance` را به طور صریح به مقدار دیگری تنظیم نکنید.
- ‏`__scheme__`: این برچسب طرح HTTP (http یا https) را که هدف باید با آن جمع‌آوری شود، شامل می‌شود. مقدار پیش‌فرض آن `http` است.
- ‏`__metrics_path__`: این برچسب مسیر HTTP برای جمع‌آوری متریک‌ها را شامل می‌شود. مقدار پیش‌فرض آن `/metrics` است.
- ‏`__param_<name>`: این برچسب نام پارامترهای پرس و جو HTTP و مقادیر آنها را که باید همراه با درخواست جمع‌آوری ارسال شوند، شامل می‌شود. شما می‌توانید هر یک از این برچسب‌ها را با استفاده از قوانین بازبرچسب‌گذاری تنظیم یا بازنویسی کنید تا رفتارهای جمع‌آوری سفارشی را برای اهداف فردی ایجاد کنید.

**برچسب‌های فراداده کشف سرویس**

علاوه بر این، مکانیزم‌های کشف سرویس می‌توانند مجموعه‌ای از برچسب‌ها را که با `__meta_` شروع می‌شوند، ارائه دهند که حاوی فراداده خاص کشف در مورد یک هدف هستند. برای مثال، هنگام کشف پادها در یک خوشه Kubernetes، موتور کشف سرویس Kubernetes برای هر هدف پاد، برچسب `__meta_kubernetes_pod_name` را که حاوی نام پاد کشف شده است، و برچسب `__meta_kubernetes_pod_ready` را که نشان می‌دهد پاد در حالت آماده است یا خیر، ارائه می‌دهد. می‌توانید تمام برچسب‌هایی را که کشف سرویس Kubernetes ارائه می‌دهد، در مستندات پیکربندی پیدا کنید. سایر مکانیزم‌های کشف سرویس فراداده مشابهی را ارائه می‌دهند.

**برچسب‌های موقت**

اگر نیاز دارید یک مقدار برچسب موقت را در یک مرحله بازبرچسب‌گذاری ذخیره کنید (برای استفاده در یک مرحله بازبرچسب‌گذاری بعدی)، می‌توانید از پیشوند نام برچسب `__tmp` استفاده کنید. تضمین می‌شود که برچسب‌هایی که با `__tmp` شروع می‌شوند، هرگز توسط خود پرومتئوس استفاده نمی‌شوند.


---


فیلدهای قانون بازبرچسب‌گذاری

قوانین بازبرچسب‌گذاری به طور کلی دارای فیلدهای پیکربندی زیر هستند، اما برای هر نوع `action` (نوع قانون بازبرچسب‌گذاری)، فقط زیرمجموعه‌ای از این فیلدها استفاده می‌شود:


```yaml
action: <relabel action>
source_labels: [<source label name list>]
separator: <source labels separator>
target_label: <target label>
regex: <regular expression>
modulus: <modulus value>
replacement: <replacement string>
```

- ‏`action`: عمل بازبرچسب‌گذاری مورد نظر برای اجرا. مقدار پیش‌فرض `replace` است. اقدامات ممکن (که در بخش‌های بعدی توضیح داده شده‌اند) عبارتند از:

- `replace`
- `keep`
- `drop`
- `hashmod`
- `labelmap`
- `labeldrop`
- `labelkeep`
- `keepequal`
- `dropequal`
- `lowercase`
- `uppercase`

- ‏`source_labels`: لیستی از نام برچسب‌ها که با استفاده از رشته جداکننده پیکربندی شده به هم متصل می‌شوند و با عبارت منظم ارائه شده در فیلد `regex` مطابقت داده می‌شوند.
- ‏`separator`: رشته‌ای که برای جدا کردن برچسب‌های منبع هنگام اتصال آنها استفاده می‌شود. مقدار پیش‌فرض آن ";" است.
- ‏`target_label`: نام برچسبی که هنگام استفاده از اقدامات بازبرچسب‌گذاری `replace` یا `hashmod` باید بازنویسی شود.
- ‏`regex`: عبارت منظم برای مطابقت با برچسب‌های منبع به هم متصل شده. مقدار پیش‌فرض آن "(.*)" است، که با هر برچسب منبع مطابقت دارد.
- ‏`modulus`: مدول برای گرفتن هش برچسب‌های منبع به هم متصل شده. برای تقسیم افقی تنظیمات پرومتئوس مفید است.
- ‏`replacement`: یک رشته جایگزین که برای اقدامات بازبرچسب‌گذاری `replace` در برچسب `target_label` نوشته می‌شود. می‌تواند به گروه‌های ضبط عبارت منظم که توسط `regex` ضبط شده‌اند، اشاره کند.

---

تنظیم یا جایگزینی مقادیر برچسب

یک مورد استفاده رایج برای بازبرچسب‌گذاری، تنظیم یا بازنویسی مقدار یک برچسب است. این کار را می‌توان با استفاده از عمل `replace` انجام داد، که اگر فیلد `action` مشخص نشده باشد، مقدار پیش‌فرض است.

ساختار قانون

یک قانون بازبرچسب‌گذاری `replace` دارای ساختار زیر است:

```yaml
action: replace
source_labels: [<source label name list>]
separator: <source labels separator>      # Defaults to ';'
regex: <regular expression>               # Defaults to '(.*)' (matching any value)
replacement: <replacement string>         # Defaults to '$1' (using the first capturing group as a replacement)
target_label: <target label>
```

این عمل مراحل زیر را به ترتیب انجام می‌دهد:

1. مقادیر برچسب‌های فهرست شده در `source_labels` را با استفاده از مقدار `separator` ارائه شده به هم متصل می‌کند.
2. آزمایش می‌کند که آیا عبارت منظم در `regex` با رشته به هم متصل شده از مرحله قبل مطابقت دارد یا خیر. اگر مطابقت وجود نداشته باشد، به قانون بازبرچسب‌گذاری بعدی می‌رود و چیزی را جایگزین نمی‌کند.
3. اگر مطابقت وجود داشته باشد، مقادیر هر گروه ضبط عبارت منظم را استخراج می‌کند (به مستندات عبارت منظم RE2 مراجعه کنید) و هر ارجاع ($1، $2، ...) به این گروه‌ها را در رشته `replacement` با مقادیر آنها جایگزین می‌کند.
4. رشته `replacement` جایگزین شده با regex را به عنوان مقدار جدید برای برچسب ارائه شده به عنوان `target_label` ذخیره می‌کند.

موارد استفاده مثال

بیایید به چند مورد استفاده مثال برای عمل `replace` نگاه کنیم.

تنظیم مقدار برچسب ثابت

ساده‌ترین مثال `replace` فقط تنظیم یک برچسب به یک مقدار ثابت است. برای مثال، می‌توانید برچسب `env` را به مقدار `production` به این صورت تنظیم کنید:

```yaml
action: replace
replacement: production
target_label: env
```

توجه داشته باشید که حتی نیازی به تنظیم اکثر فیلدهای قانون نداریم، زیرا مقادیر پیش‌فرض در حال حاضر برای این مورد به خوبی کار می‌کنند (مطابقت با کل برچسب منبع و استفاده از آن به عنوان رشته جایگزین). حتی می‌توانیم فیلد `action` را حذف کنیم، زیرا `replace` مقدار پیش‌فرض است:

```yaml
replacement: production
target_label: env
```

با این حال، توصیه می‌کنیم همیشه فیلد `action` را برای خوانایی بیشتر قوانین خود درج کنید.

جایگزینی پورت جمع‌آوری

یک مثال پیچیده‌تر، بازنویسی پورتی است که یک نمونه بر روی آن جمع‌آوری می‌شود. می‌توانید پورت برچسب `__address__` را با پورت ثابت 80 به این صورت جایگزین کنید:

```yaml
action: replace
source_labels: [__address__]
regex: ([^:]+)(?::\d+)?   # The first group matches the host, the second matches the port.
replacement: '$1:80'
target_label: __address__
```

----

نگهداری و حذف اشیاء

یک مورد استفاده رایج دیگر، تمایل به حذف یا نگهداری کل اشیاء برچسب‌دار از مجموعه نتایج نهایی است. اقدامات بازبرچسب‌گذاری keep و drop امکان کنترل این موضوع را فراهم می‌کنند.

بسته به اینکه در کدام نوع پیکربندی بازبرچسب‌گذاری استفاده می‌شوند، به شما امکان می‌دهند تصمیم بگیرید:

- ...کدام اهداف حاصل از کشف سرویس باید جمع‌آوری شوند،
- ...کدام نمونه‌های سری خاص باید از یک هدف جمع‌آوری شوند یا به فضای ذخیره‌سازی راه دور ارسال شوند،
- ...کدام هشدارها باید به Alertmanager ارسال شوند.

نکته: پرومتئوس 2.41 همچنین اقدامات `keepequal` و `dropequal` را اضافه کرد که به شما امکان می‌دهد یک هدف را بر اساس برابری برچسب‌های منبع و هدف نگه دارید یا حذف کنید. با این حال، موارد استفاده برای این اقدامات نسبتاً نادر است، بنابراین ما آنها را به طور مفصل در اینجا پوشش نخواهیم داد.

ساختار قانون

یک قانون بازبرچسب‌گذاری `keep` دارای ساختار زیر است:

```yaml
action: keep
source_labels: [<source label name list>]
separator: <source labels separator>      # Defaults to ';'
regex: <regular expression>               # Defaults to '(.*)' (matching any value)
```

کپی

عمل `keep` مراحل زیر را به ترتیب انجام می‌دهد:

1. مقادیر برچسب‌های فهرست شده در `source_labels` را با استفاده از مقدار `separator` ارائه شده به هم متصل می‌کند.
2. آزمایش می‌کند که آیا عبارت منظم در `regex` با رشته به هم متصل شده از مرحله قبل مطابقت دارد یا خیر. اگر مطابقت وجود نداشته باشد، شیء از لیست خروجی نهایی حذف می‌شود.
3. اگر مطابقت وجود داشته باشد، شیء نگه داشته می‌شود.

عمل `drop` مانند `keep` کار می‌کند، اما به جای نگه داشتن یک شیء، آن را حذف می‌کند.

موارد استفاده مثال

بیایید به چند مورد استفاده مثال برای اقدامات `keep` و `drop` نگاه کنیم.

جمع‌آوری فقط اهدافی با حاشیه نویسی جمع‌آوری خاص

هنگام استفاده از بازبرچسب‌گذاری هدف، ممکن است بخواهید فقط اهدافی را جمع‌آوری کنید که دارای یک برچسب فراداده خاص (ارائه شده توسط مکانیزم کشف سرویس) هستند که نشان می‌دهد باید جمع‌آوری شوند. برای مثال، موارد زیر به شما امکان می‌دهد فقط اهدافی را جمع‌آوری کنید که دارای مقدار `example.io/should_be_scraped = true` در حاشیه نویسی Kubernetes هستند:


```yaml
action: keep
source_labels: [__meta_kubernetes_service_annotation_example_io_should_be_scraped]
regex: true
```


توجه داشته باشید که نام حاشیه نویسی فقط یک مثال است و استاندارد نشده است.

ذخیره فقط متریک‌های خاص

هنگام استفاده از `metric_relabel_configs` برای کنترل نحوه جمع‌آوری یک هدف، می‌توانید از قانون زیر برای ذخیره فقط متریک‌هایی استفاده کنید که نام متریک آنها با پیشوند `api_` یا `http_` شروع می‌شود:


```yaml
action: keep
source_labels: [__name__]
regex: '(api_|http_).*'
```


---

نگاشت مجموعه‌های برچسب

گاهی اوقات ممکن است بخواهید مجموعه‌ای کامل از برچسب‌های منبع را بگیرید و مقادیر آنها را به مجموعه‌ای جدید از نام‌های برچسب جدید با پیشوندهای متفاوت نگاشت کنید. عمل `labelmap` به شما امکان می‌دهد این کار را انجام دهید. رایج‌ترین مورد استفاده برای عمل `labelmap`، گرفتن گروهی از برچسب‌های فراداده با پیشوند `__meta` از یک منبع کشف سرویس و نگاشت آنها به برچسب‌های هدف دائمی است.

ساختار قانون

یک قانون بازبرچسب‌گذاری `labelmap` دارای ساختار زیر است:

```yaml
action: labelmap
regex: <regular expression>               # Defaults to '(.*)' (matching any value)
replacement: <replacement string>         # Defaults to '$1' (using the first capturing group as a replacement)
```

برخلاف اقدامات بازبرچسب‌گذاری قبلی که آموختیم، عمل labelmap با نام برچسب‌ها مطابقت regex انجام می‌دهد و بر روی آنها عمل می‌کند، نه مقادیر برچسب.

عمل labelmap مراحل زیر را به ترتیب انجام می‌دهد:

1. عبارت منظم در `regex` را با **تمام** نام‌های برچسب مطابقت می‌دهد.
2. سپس مقادیر نام‌های برچسب منطبق را به مجموعه‌ای از نام‌های برچسب جدید که توسط رشته `replacement` تعیین می‌شوند، کپی می‌کند. رشته `replacement` می‌تواند حاوی ارجاعات گروه ضبط regex ($1، $2، ...) برای درج بخش‌های استخراج شده از نام برچسب اصلی در نام برچسب مقصد باشد.

موارد استفاده مثال

بیایید به یک مورد استفاده مثال برای عمل `labelmap` نگاه کنیم.

نگاشت برچسب‌های سرویس Kubernetes

هنگام استفاده از کشف سرویس مبتنی بر Kubernetes برای کشف نقاط پایانی پاد، ممکن است بخواهید برچسب‌های هدف نهایی برای هر نقطه پایانی نیز حاوی برچسب‌های سرویس Kubernetes باشد. کشف سرویس Kubernetes این موارد را در مجموعه‌ای از برچسب‌ها با الگوی نام‌گذاری `__meta_kubernetes_service_label_<labelname>` ارائه می‌کند. می‌توانیم قسمت `<labelname>` از آن برچسب‌های فراداده را استخراج کرده و مقادیر برچسب مربوطه را به مجموعه‌ای جدید از نام‌های برچسب که با پیشوند `k8s_` شروع می‌شوند، نگاشت کنیم، مانند این:


```yaml
action: labelmap
regex: __meta_kubernetes_service_label_(.+)
replacement: 'k8s_$1'
```

---

نگهداری و حذف برچسب‌ها

کمتر پیش می‌آید که بخواهید برچسب‌های منفرد را از یک شیء نگه دارید یا حذف کنید. برای مثال، برخی از اهداف تعداد زیادی برچسب اضافی (غیر شناسایی کننده) غیرضروری را در سری‌های زمانی ارائه می‌کنند که بعداً جالب نیستند و فقط TSDB و خروجی پرس و جو شما را آلوده می‌کنند. اقدامات `labelkeep` و `labeldrop` به شما امکان می‌دهند برخی از برچسب‌ها را به طور انتخابی نگه دارید یا حذف کنید.

ساختار قانون

یک قانون بازبرچسب‌گذاری `labelkeep` دارای ساختار زیر است:

```yaml
action: labelkeep
regex: <regular expression>  # Defaults to '(.*)' (matching any value)
```



عمل `labelkeep` مراحل زیر را به ترتیب انجام می‌دهد:

1. عبارت منظم در `regex` را با تمام نام‌های برچسب مطابقت می‌دهد.
2. فقط برچسب‌هایی را نگه می‌دارد که مطابقت دارند.

عمل `labeldrop` مانند `labelkeep` کار می‌کند، اما به جای نگه داشتن یک برچسب، آن را حذف می‌کند.

موارد استفاده مثال

بیایید به چند مورد استفاده مثال برای عمل `labelkeep` نگاه کنیم.

حذف برچسب‌های تکراری HA از هشدارها

هنگام اجرای دو سرور پرومتئوس یکسان به عنوان یک جفت با دسترس‌پذیری بالا (HA)، اغلب هر دو سرور پیکربندی می‌شوند که یک برچسب خارجی داشته باشند (از طریق گزینه پیکربندی سراسری external_labels) که نشان می‌دهد کدام تکراری را نشان می‌دهند، به عنوان مثال replica: A و replica: B. قبل از ارسال هشدارها به همان نمونه Alertmanager از هر دو تکراری، پرومتئوس باید این برچسب تکراری را حذف کند تا Alertmanager هشدارهای ورودی را متفاوت تفسیر نکند (در غیر این صورت، دو اعلان برای یک هشدار دریافت خواهید کرد، یکی با برچسب replica="A" و دیگری با replica="B")!

می‌توانید این برچسب replica را با قانون بازبرچسب‌گذاری هشدار labeldrop زیر حذف کنید:

```yaml
action: labeldrop
regex: replica
```

حذف برچسب‌های غیرضروری از متریک‌ها

برخی از اهداف (مانند cAdvisor در گذشته) برچسب‌های اضافی را به هر سری زمانی متصل می‌کنند که برای شناسایی منحصربه‌فرد هر سری ضروری نیستند، بلکه فقط اطلاعات اضافی در مورد هدف یا سری ارائه می‌دهند که ممکن است نخواهید ذخیره کنید.

برای حذف هر برچسبی که با info_ شروع می‌شود از متریک‌های جمع‌آوری شده، می‌توانید یک قانون بازبرچسب‌گذاری متریک مانند این بنویسید:

```yaml
action: labeldrop
regex: info_.*
```

هش کردن و تقسیم‌بندی  (sharding) بر اساس مقادیر برچسب

در شرایط نادر، ممکن است بخواهید یک تنظیمات پرومتئوس را به صورت افقی با اجرای چندین تکراری سرور پرومتئوس تقریباً یکسان، اما هر کدام فقط زیرمجموعه‌ای از تمام اهداف یک سرویس را جمع‌آوری کنند، مقیاس‌بندی کنید. عمل بازبرچسب‌گذاری `hashmod` (همراه با عمل `keep`) به ما امکان می‌دهد اهداف را برای این سناریو تقسیم‌بندی کنیم.

ساختار قانون

یک قانون بازبرچسب‌گذاری `hashmod` دارای ساختار زیر است:

```yaml
action: hashmod
source_labels: [<source label name list>]
modulus: <modulus value>
target_label: <target label>
```


این عمل مراحل زیر را به ترتیب انجام می‌دهد:

1. مقادیر برچسب‌های فهرست شده در `source_labels` را با استفاده از مقدار `separator` ارائه شده به هم متصل می‌کند.
2. هش (در حال حاضر به عنوان مجموع MD5 پیاده‌سازی شده) رشته به هم متصل شده را محاسبه می‌کند.
3. مدول ارائه شده در `modulus` را به هش اعمال می‌کند (عملیات: `hash % modulus`)، تا هش را به مقداری بین `0` و `modulus - 1` محدود کند.
4. مقدار مدول از مرحله قبل را در برچسب ارائه شده به عنوان `target_label` ذخیره می‌کند.

موارد استفاده مثال

بیایید به یک مورد استفاده مثال برای عمل `hashmod` نگاه کنیم.

تقسیم‌بندی اهداف در یک سرویس

مورد استفاده اصلی برای استفاده از عمل `hashmod`، تقسیم گروه کلی اهداف یک سرویس به تکه‌هایی برای هر تکرار از یک تنظیمات سرور پرومتئوس مقیاس‌بندی شده به صورت افقی است. این کار با محاسبه ابتدا مدول مبتنی بر هش برای هر هدف بر اساس یک یا چند برچسب آن و سپس فقط نگه داشتن اهدافی که مقدار مدول خروجی خاصی دارند، انجام می‌شود. برای مثال، برای تقسیم‌بندی اهداف بر اساس برچسب `instance` آنها و فقط نگه داشتن نمونه‌ها برای تکه 2 (از 10 تکه)، می‌توانید یک `hashmod` را با یک عمل `keep` به این صورت ترکیب کنید:

```yaml
- action: hashmod
  source_labels: [instance]
  modulus: 10
  target_label: __tmp_hashmod
- action: keep
  source_labels: [__tmp_hashmod]
  regex: 2
```

---

تبدیل به حروف کوچک و بزرگ

گاهی اوقات ممکن است بخواهید حالت متن یک مقدار برچسب را تغییر دهید تا با حالت مقدار برچسب دیگری مطابقت داشته باشد، به طوری که بتوانید آنها را مقایسه کنید. برای مثال، ممکن است بخواهید یک مقدار برچسب را که با حروف بزرگ نوشته شده است با مقدار برچسب دیگری که با حروف کوچک نوشته شده است، مطابقت دهید. اقدامات بازبرچسب‌گذاری `lowercase` و `uppercase` به شما امکان می‌دهد این کار را انجام دهید.

ساختار قانون

یک قانون بازبرچسب‌گذاری `lowercase` دارای ساختار زیر است:

YAML

```
action: lowercase
source_labels: [<لیست نام برچسب منبع>]
target_label: <برچسب هدف>
```

این عمل مراحل زیر را به ترتیب انجام می‌دهد:

1. مقادیر برچسب‌های فهرست شده در `source_labels` را با استفاده از مقدار `separator` ارائه شده به هم متصل می‌کند.
2. آن مقدار به هم متصل شده را به حروف کوچک تبدیل می‌کند و آن را در برچسب ارائه شده به عنوان `target_label` ذخیره می‌کند.

عمل `uppercase` مانند `lowercase` کار می‌کند، اما به جای تبدیل خروجی به حروف کوچک، آن را به حروف بزرگ تبدیل می‌کند.

موارد استفاده مثال

بیایید به یک مورد استفاده مثال برای عمل `lowercase` نگاه کنیم.

تبدیل مقدار برچسب به حروف کوچک

تصور کنید دو صادرکننده دارید که متریک‌های سطح ماشین را به شما ارائه می‌دهند، یکی نام میزبان ماشین را با حروف بزرگ در برچسب `host` ارائه می‌کند و دیگری نام میزبان ماشین را با حروف کوچک در برچسب مشابه ارائه می‌کند. شما می‌خواهید بتوانید دو مقدار را مقایسه کنید، اما اگر در حالت‌های مختلف باشند، نمی‌توانید این کار را انجام دهید. می‌توانید از عمل `lowercase` برای تبدیل مقدار برچسب با حروف بزرگ به حروف کوچک استفاده کنید، تا بتوانید آنها را مقایسه کنید:

YAML

```
- action: lowercase
  source_labels: [host]
  target_label: host
```


---

خلاصه

در این آموزش، شما آموختید:

- انگیزه برای قوانین بازبرچسب‌گذاری،
- چه اشیاء برچسب‌داری را می‌توان با استفاده از قوانین بازبرچسب‌گذاری اصلاح و فیلتر کرد،
- نحوه تفسیر و بهره‌برداری از برچسب‌های فراداده پنهان در طول بازبرچسب‌گذاری،
- نحوه نوشتن قوانین بازبرچسب‌گذاری خاص برای دستیابی به اهداف مختلف.

اکنون باید بتوانید مفاهیم پشت قوانین بازبرچسب‌گذاری را توضیح دهید و قوانین بازبرچسب‌گذاری را برای اهداف مختلف بنویسید.