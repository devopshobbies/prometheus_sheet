

شما قبلاً در بخش «مبانی تجمیع» (Aggregation Basics) با مفهوم تجمیع آشنا شدید؛ با این حال، این تنها بخش کوچکی از امکانات موجود است. تجمیع اهمیت زیادی دارد. در برنامه‌هایی با هزاران یا حتی فقط ده‌ها نمونه (instance)، بررسی جداگانه متریک‌های هر نمونه عملی نیست. تجمیع به شما امکان می‌دهد متریک‌ها را نه تنها در یک برنامه، بلکه در چندین برنامه نیز خلاصه کنید. در PromQL دوازده عملگر تجمیع وجود دارد، به همراه دو بند (clause) اختیاری: `without` و `by`. در این فصل با روش‌های مختلف استفاده از تجمیع آشنا خواهید شد.

### گروه‌بندی (Grouping)

پیش از صحبت در مورد خودِ عملگرهای تجمیع، لازم است با نحوه گروه‌بندی سری‌های زمانی (time series) آشنا شوید. عملگرهای تجمیع فقط روی بردارهای لحظه‌ای (instant vectors) عمل می‌کنند و خروجی آن‌ها نیز بردارهای لحظه‌ای است.
در Prometheus مفهوم **Grouping** به معنی دسته‌بندی یا گروه‌بندی داده‌های متریک بر اساس برچسب‌ها (Labels) است. این مفهوم معمولاً در دو زمینه اصلی استفاده می‌شود:
 ۱. **Grouping در جمع‌آوری داده‌ها (Aggregation)**
 ۲. **Grouping در عملیات Join (زمان ادغام متریک‌ها)**
 
فرض کنید سری‌های زمانی زیر را در پرومتئوس (Prometheus) دارید:

```json
node_filesystem_size_bytes{device="/dev/sda1",fstype="vfat",
instance="localhost:9100",job="node",mountpoint="/boot/efi"} 100663296
node_filesystem_size_bytes{device="/dev/sda5",fstype="ext4",
instance="localhost:9100",job="node",mountpoint="/"} 90131324928
node_filesystem_size_bytes{device="tmpfs",fstype="tmpfs",
instance="localhost:9100",job="node",mountpoint="/run"} 826961920
node_filesystem_size_bytes{device="tmpfs",fstype="tmpfs",
instance="localhost:9100",job="node",mountpoint="/run/lock"} 5242880
node_filesystem_size_bytes{device="tmpfs",fstype="tmpfs",
instance="localhost:9100",job="node",mountpoint="/run/user/1000"} 826961920
node_filesystem_size_bytes{device="tmpfs",fstype="tmpfs",
instance="localhost:9100",job="node",mountpoint="/run/user/119"} 826961920
```

سه برچسب ابزاردقیق (instrumentation labels) وجود دارد: `device`، `fstype` و `mountpoint`. همچنین دو برچسب هدف (target labels) موجود است: `job` و `instance`. برچسب‌های هدف و ابزاردقیق مفهومی است که ما و شما از آن آگاهیم، اما PromQL چیزی درباره آن نمی‌داند. از دید PromQL، تمام برچسب‌ها یکسان هستند، صرف‌نظر از اینکه از کجا نشأت گرفته‌اند.


### ۱. **Grouping در جمع‌آوری داده‌ها (Aggregation)**
   - وقتی از عملگرهای تجمعی مانند `sum()`، `avg()`، `min()`، `max()` و غیره استفاده می‌کنید، می‌توانید داده‌ها را بر اساس برچسب‌های خاص **گروه‌بندی (Group by)** کنید.
   - مثال:
     ```promql
     sum(rate(http_requests_total[5m])) by (service, endpoint)
     ```
     این پرسش، میزان درخواست‌های HTTP را بر اساس `service` و `endpoint` گروه‌بندی و جمع می‌زند.


### ۲. **Grouping در عملیات Join (زمان ادغام متریک‌ها)**
   - هنگام استفاده از عملگرهای باینری مانند `+`، `-`، `*`، `/` و غیره، Prometheus سعی می‌کند متریک‌های متناظر را بر اساس برچسب‌هایشان تطبیق دهد.
   - اگر بخواهید برخی برچسب‌ها را در تطبیق نادیده بگیرید، از `ignoring()` استفاده می‌کنید:
     ```promql
     metric1{env="prod"} + ignoring(instance) metric2{env="prod"}
     ```
   - اگر بخواهید فقط برچسب‌های خاصی را در تطبیق در نظر بگیرید، از `on()` استفاده می‌کنید:
     ```promql
     metric1{env="prod"} * on(service, endpoint) metric2{env="prod"}
     ```

## `without`

معمولاً شما همیشه برچسب‌های ابزاردقیق را می‌شناسید، زیرا به‌ندرت تغییر می‌کنند. اما همیشه از برچسب‌های هدفِ درگیر اطلاعی ندارید، زیرا عبارتی (expression) که می‌نویسید ممکن است توسط شخص دیگری روی متریک‌هایی با پیکربندی‌های scrape متفاوت استفاده شود، یا سرورهای پرومتئوس ممکن است برچسب‌های هدف دیگری را در سطح یک `job` اضافه کرده باشند، مانند برچسب `env` یا `cluster`. حتی ممکن است خودتان در مقطعی چنین برچسب‌های هدفی اضافه کنید و بهتر است مجبور به به‌روزرسانی تمام عبارات خود نشوید. هنگام تجمیع متریک‌ها، معمولاً باید سعی کنید چنین برچسب‌های هدفی را حفظ کنید و بنابراین، هنگام تجمیع باید از بند `without` برای مشخص کردن برچسب‌هایی که می‌خواهید حذف شوند، استفاده کنید. برای مثال، کوئری (query) زیر:

`sum without(fstype, mountpoint)(node_filesystem_size_bytes)`

سری‌های زمانی را با نادیده گرفتن برچسب‌های `fstype` و `mountpoint`، به سه گروه دسته‌بندی می‌کند:

`node_filesystem_size_bytes`

```json
# Group {device="/dev/sda1",instance="localhost:9100",job="node"}
node_filesystem_size_bytes{device="/dev/sda1",fstype="vfat",
instance="localhost:9100",job="node",mountpoint="/boot/efi"} 100663296
# Group {device="/dev/sda5",instance="localhost:9100",job="node"}
node_filesystem_size_bytes{device="/dev/sda5",fstype="ext4",
instance="localhost:9100",job="node",mountpoint="/"} 90131324928
# Group {device="tmpfs",instance="localhost:9100",job="node"}
node_filesystem_size_bytes{device="tmpfs",fstype="tmpfs",
instance="localhost:9100",job="node",mountpoint="/run"} 826961920
node_filesystem_size_bytes{device="tmpfs",fstype="tmpfs",
instance="localhost:9100",job="node",mountpoint="/run/lock"} 5242880
node_filesystem_size_bytes{device="tmpfs",fstype="tmpfs",
instance="localhost:9100",job="node",mountpoint="/run/user/1000"} 826961920
node_filesystem_size_bytes{device="tmpfs",fstype="tmpfs",
instance="localhost:9100",job="node",mountpoint="/run/user/119"} 826961920
```

و عملگر تجمیع `sum` در هر یک از این گروه‌ها اعمال می‌شود، مقادیر سری‌های زمانی را جمع کرده و یک نمونه به ازای هر گروه برمی‌گرداند:

```sh
{device="/dev/sda1",instance="localhost:9100",job="node"} 100663296
{device="/dev/sda5",instance="localhost:9100",job="node"} 90131324928
{device="tmpfs",instance="localhost:9100",job="node"} 2486128640
```

توجه داشته باشید که برچسب‌های `instance` و `job` حفظ می‌شوند، همانطور که هر برچسب دیگری که وجود داشت، حفظ می‌شد. این مفید است زیرا هر هشداری که ایجاد کرده‌اید و به نوعی شامل این عبارت بوده، برچسب‌های هدف اضافی مانند `env` یا `cluster` را حفظ می‌کند. این به هشدارهای شما زمینه (context) می‌دهد و آنها را مفیدتر می‌کند (همچنین برای رسم نمودار نیز مفید است). نام متریک نیز حذف شده است، زیرا این تجمیعی از متریک `node_filesystem_size_bytes` است و نه خود متریک اصلی. وقتی یک عملگر یا تابع PromQL می‌تواند مقدار یا معنای یک سری زمانی را تغییر دهد، نام متریک حذف می‌شود.

ارائه نکردن هیچ برچسبی به `without` معتبر است. برای مثال:
`sum without()(node_filesystem_size_bytes)`
همان نتیجه‌ای را به شما می‌دهد که:
`node_filesystem_size_bytes`
با این تفاوت که نام متریک حذف شده است.

## `by`

علاوه بر `without`، بند `by` نیز وجود دارد. درحالی‌که `without` برچسب‌های قابل حذف را مشخص می‌کند، `by` برچسب‌هایی را که باید حفظ شوند، مشخص می‌کند. بنابراین، هنگام استفاده از `by` باید دقت کرد تا برچسب‌های هدفی را که مایلید در هشدارها منتشر شوند یا در داشبوردهایتان استفاده کنید، حذف نکنید. نمی‌توانید همزمان از `by` و `without` در یک تجمیع استفاده کنید.

کوئری زیر:

`sum by(job, instance, device)(node_filesystem_size_bytes)`

همان نتیجه‌ای را تولید می‌کند که کوئری بخش قبل با استفاده از `without` تولید کرد:

```json
{device="/dev/sda1",instance="localhost:9100",job="node"} 100663296
{device="/dev/sda5",instance="localhost:9100",job="node"} 90131324928
{device="tmpfs",instance="localhost:9100",job="node"} 2486128640
```

با این حال، اگر `instance` یا `job` مشخص نشده بودند، گروه را تعریف نمی‌کردند و در خروجی نیز وجود نداشتند. به همین دلیل، عموماً باید استفاده از `without` را به `by` ترجیح دهید.

دو حالت وجود دارد که ممکن است `by` را مفیدتر بیابید. اولین مورد این است که برخلاف `without`استفاده از `by` در صورت مشخص شدن صریح، برچسب `__name__` را حفظ می‌کند. این به شما امکان می‌دهد از عباراتی مانند زیر برای بررسی اینکه چه تعداد سری زمانی نام‌های متریک یکسانی دارند، استفاده کنید:

`sort_desc(count by(__name__)({__name__=~".+"}))`

دومین مورد، حالاتی است که می‌خواهید هر برچسبی را که نمی‌شناسید حذف کنید. برای مثال، متریک‌های اطلاعاتی (info metrics)، انتظار می‌رود با گذشت زمان برچسب‌های بیشتری به آن‌ها اضافه شود. برای شمارش تعداد ماشین‌هایی که هر نسخه کرنل را اجرا می‌کردند، می‌توانید از این دستور استفاده کنید:

`count by(release)(node_uname_info)`

که در تنظیمات تست تک ماشین ما، نتیجه زیر را برمی‌گرداند:

`sum by()(node_filesystem_size_bytes)`

و:

`sum(node_filesystem_size_bytes)`

دقیقاً معادل هستند و نتیجه‌ای مانند زیر خواهند داد:

`{} 92718116864`

این یک سری زمانی واحد است و آن سری زمانی هیچ برچسبی ندارد.
اگر عبارت زیر را اجرا کنید:

`sum(non_existent_metric)`

نتیجه یک بردار لحظه‌ای بدون هیچ سری زمانی خواهد بود که در تب Console مرورگر عبارات به صورت «no data» (داده‌ای وجود ندارد) نمایش داده می‌شود.

اگر ورودی یک عملگر تجمیع، یک بردار لحظه‌ای خالی باشد، خروجی آن نیز یک بردار لحظه‌ای خالی خواهد بود. بنابراین، `count by(foo)(non_existent_metric)` به جای 0 خالی خواهد بود، زیرا `count` و سایر تجمیع‌کننده‌ها هیچ برچسبی برای کار با آن ندارند. `count(non_existent_metric)` با این موضوع سازگار است و همچنین یک بردار لحظه‌ای خالی برمی‌گرداند.

## عملگرها (Operators)

تمام ۱۱ عملگر تجمیع از منطق گروه‌بندی یکسانی استفاده می‌کنند. شما می‌توانید این را با یکی از بندهای `without` یا `by` کنترل کنید. تفاوت بین عملگرهای تجمیع در کاری است که با داده‌های گروه‌بندی شده انجام می‌دهند.

### `sum`

مورد `sum` رایج‌ترین عملگر تجمیع است؛ این عملگر تمام مقادیر موجود در یک گروه را جمع کرده و آن را به عنوان مقدار گروه برمی‌گرداند. برای مثال:

`sum without(fstype, mountpoint, device)(node_filesystem_size_bytes)`

اندازه کل فایل‌سیستم‌های هر یک از ماشین‌های شما را برمی‌گرداند. هنگام کار با شمارنده‌ها (counters)،  مهم است که قبل از تجمیع با `sum`، نرخ (rate) را محاسبه کنید:

`sum without(device)(rate(node_disk_read_bytes_total[5m]))`

اگر مستقیماً روی شمارنده‌ها از `sum` استفاده کنید، نتیجه بی‌معنی خواهد بود، زیرا شمارنده‌های مختلف ممکن است بسته به زمان شروع یا راه‌اندازی مجدد اکسپورتر، یا اولین باری که هر یک از فرزندان (children) خاص استفاده شده‌اند، در زمان‌های متفاوتی مقداردهی اولیه شده باشند.

### `count`

عملگر `count` تعداد سری‌های زمانی در یک گروه را شمارش کرده و آن را به عنوان مقدار گروه برمی‌گرداند. برای مثال:

`count without(device)(node_disk_read_bytes_total)`

تعداد دستگاه‌های دیسک یک ماشین را برمی‌گرداند. ماشین ما فقط یک دیسک دارد، بنابراین نتیجه می‌گیریم:

`{instance="localhost:9100",job="node"} 1`

در اینجا مشکلی نیست که از `rate` با یک شمارنده استفاده نکنید، زیرا شما به وجود سری زمانی اهمیت می‌دهید نه مقدار آن.

### مقادیر منحصربه‌فرد برچسب (Unique label values)

همچنین می‌توانید از `count` برای شمارش تعداد مقادیر منحصربه‌فرد یک برچسب استفاده کنید. برای مثال، برای شمارش تعداد CPUها در هر یک از ماشین‌هایتان، می‌توانید از دستور زیر استفاده کنید:

`count without(cpu)(count without (mode)(node_cpu_seconds_total))`

این `count` داخلی، برچسب ابزاردقیق دیگر یعنی `mode` را حذف می‌کند و به ازای هر CPU در هر نمونه، یک سری زمانی برمی‌گرداند:

```json
{cpu="0",instance="localhost:9100",job="node"} 8
{cpu="1",instance="localhost:9100",job="node"} 8
{cpu="2",instance="localhost:9100",job="node"} 8
{cpu="3",instance="localhost:9100",job="node"} 8
```

سپس `count` بیرونی تعداد CPUهای هر نمونه را برمی‌گرداند:

`{instance="localhost:9100",job="node"} 4`

اگر به تفکیک هر ماشین نیاز نداشتید، مثلاً اگر در حال بررسی این بودید که آیا برچسب‌های خاصی دارای کاردینالیتی (cardinality) بالایی هستند یا خیر، می‌توانستید از اصلاح‌گر (modifier) `by` برای بررسی تنها یک برچسب استفاده کنید:

`count(count by(cpu)(node_cpu_seconds_total))`

که یک نمونه واحد بدون برچسب تولید می‌کند، مانند:

`{} 4`

## `avg`

عملگر `avg` میانگین مقادیر سری‌های زمانی در گروه را به عنوان مقدار گروه برمی‌گرداند. برای مثال:
`avg without(cpu)(rate(node_cpu_seconds_total[5m]))`

میانگین استفاده از هر حالت CPU را برای هر نمونه Node Exporter با نتیجه‌ای مانند زیر به شما می‌دهد:

```json
{instance="localhost:9100",job="node",mode="idle"} 0.9095948275861836
{instance="localhost:9100",job="node",mode="iowait"} 0.005543103448275879
{instance="localhost:9100",job="node",mode="irq"} 0
{instance="localhost:9100",job="node",mode="nice"} 0.0013620689655172522
{instance="localhost:9100",job="node",mode="softirq"} 0.0001465517241379329
{instance="localhost:9100",job="node",mode="steal"} 0
{instance="localhost:9100",job="node",mode="system"} 0.015836206896552414
{instance="localhost:9100",job="node",mode="user"} 0.06054310344827549
```

این دقیقاً همان نتیجه‌ای را به شما می‌دهد که:

```json
sum without(cpu)(rate(node_cpu_seconds_total[5m]))
/
count without(cpu)(rate(node_cpu_seconds_total[5m]))
```

اما استفاده از `avg` هم مختصرتر و هم کارآمدتر است. هنگام استفاده از `avg`، گاهی اوقات ممکن است متوجه شوید که یک `NaN` در ورودی باعث می‌شود کل نتیجه `NaN` شود. این به این دلیل است که هرگونه عملیات محاسباتی ممیز شناور (floating-point) که شامل `NaN` باشد، نتیجه‌اش `NaN` خواهد بود. شاید از خود بپرسید چگونه این `NaN`ها را در ورودی فیلتر کنید، اما این سوال اشتباهی است. معمولاً این به دلیل تلاش برای میانگین‌گیری از میانگین‌ها است و یکی از مخرج‌های میانگین‌های اولیه 0 بوده است. میانگین‌گیری از میانگین‌ها از نظر آماری معتبر نیست، بنابراین کاری که باید انجام دهید این است که با استفاده از `sum` تجمیع کرده و سپس در نهایت تقسیم کنید، همانطور که در بخش «خلاصه» (Summary)  نشان داده شده است.

- از نظر فنی به آن میانگین حسابی (arithmetic mean) می‌گویند. در موارد نادر که به میانگین هندسی (geometric mean) نیاز دارید، می‌توان از توابع `ln` و `exp` در ترکیب با عملگر `avg` برای محاسبه آن استفاده کرد.
- این به این دلیل است که 1 / 0 = `NaN`.

### `group`

عملگر `group` برای هر یک از سری‌های زمانی در گروه، مقدار 1 را به عنوان مقدار گروه برمی‌گرداند. برای مثال:

`count by (instance)( group by (fstype,instance) (node_filesystem_files) )`

این کوئری تعداد انواع مختلف فایل‌سیستم را برای هر نمونه برمی‌گرداند. در این حالت، هر عملگر تجمیعی (`sum`، `count`) می‌توانست به جای `group` کار کند. با این حال، استفاده از `group` برای هر کسی که کوئری را می‌خواند، روشن می‌کند که ما به خودِ گروه‌بندی و برچسب‌های حاصل از آن علاقه‌مندیم، نه به مقداری که توسط عملگر تجمیع داخلی تولید می‌شود.

### `stddev` و `stdvar`

انحراف معیار (standard deviation) یک معیار آماری برای نشان دادن میزان پراکندگی مجموعه‌ای از اعداد است. برای مثال، اگر اعداد [۲،۴،۶] را داشته باشید، انحراف معیار ۱.۶۳۳ خواهد بود.⁶ اعداد [۳،۴،۵] میانگین یکسان ۴ دارند، اما انحراف معیار آن‌ها ۰.۸۱۶ است. کاربرد اصلی انحراف معیار در مانیتورینگ، تشخیص داده‌های پرت (outliers) است. در داده‌های با توزیع نرمال، انتظار می‌رود حدود ۶۸٪ از نمونه‌ها در فاصله یک انحراف معیار از میانگین و ۹۵٪ در فاصله دو انحراف معیار قرار گیرند.⁷ اگر یک نمونه در یک `job`، متریکی داشته باشد که چندین انحراف معیار از میانگین فاصله دارد، این نشانه خوبی است که مشکلی در آن وجود دارد. برای مثال، می‌توانید تمام نمونه‌هایی را که حداقل دو انحراف معیار بالاتر از میانگین هستند، با استفاده از عبارتی مانند زیر پیدا کنید:

```
some_gauge
> ignoring (instance) group_left()
(
avg without(instance)(some_gauge)
+
2 * stddev without(instance)(some_gauge)
)
```

این از تطابق برداری یک به چند (one-to-many vector matching) استفاده می‌کند که در بخش «تطابق چند به یک و group_left» (Many-to-One and group_left) در ادامه مورد بحث قرار خواهد گرفت. اگر مقادیر شما همگی به هم نزدیک باشند (tightly bunched)، ممکن است این دستور برخی سری‌های زمانی را برگرداند که بیش از دو انحراف معیار فاصله دارند، اما همچنان به طور عادی کار می‌کنند و به میانگین نزدیک هستند. می‌توانید یک فیلتر اضافی اضافه کنید که مقدار باید حداقل، مثلاً، ۲۰٪ بیشتر از میانگین باشد تا از این حالت جلوگیری شود. این همچنین یک مورد نادر است که میانگین‌گیری از یک میانگین مشکلی ندارد، مثلاً اگر این را برای میانگین تأخیر (latency) اعمال کنید. واریانس معیار (standard variance)، مجذور انحراف معیار است و کاربردهای آماری دارد.

- پرومتئوس از انحراف معیار تجمعی به جای انحراف معیار نمونه استفاده می‌کند، زیرا معمولاً شما به تمام مقادیری که به آن‌ها علاقه‌مندید نگاه می‌کنید، نه یک زیرمجموعه تصادفی.
- برای داده‌های با توزیع غیرنرمال، نابرابری چبیشف (Chebyshev’s inequality) کران ضعیف‌تری ارائه می‌دهد.


---

## 📘 تعریف پایه

فرض کن مجموعه‌ای از داده‌ها داریم:

```
x₁, x₂, x₃, ..., xₙ
```

که این داده‌ها از یک **range vector** در Prometheus به‌دست اومدن، مثل:

```promql
http_requests_total[5m]
```

در این صورت Prometheus روی این داده‌ها توابع آماری مثل `avg`, `stddev`, `stdvar` رو اجرا می‌کنه.

---

## ✅ میانگین (Average / Mean)

قبل از محاسبه واریانس یا انحراف معیار، باید میانگین رو محاسبه کنیم:

$$
\mu = \frac{1}{n} \sum_{i=1}^{n} x_i
$$

---

## ✅ واریانس (Variance) – `stdvar_over_time`

واریانس، متوسط مربع فاصله‌ی مقادیر از میانگینه:

$$
\text{Var}(X) = \frac{1}{n} \sum_{i=1}^{n} (x_i - \mu)^2
$$

در Prometheus، این رو با `stdvar_over_time()` به‌دست میاریم.

---

## ✅ انحراف معیار (Standard Deviation) – `stddev_over_time`

انحراف معیار، ریشه دوم واریانسه:

$$
\text{StdDev}(X) = \sqrt{\text{Var}(X)} = \sqrt{ \frac{1}{n} \sum_{i=1}^{n} (x_i - \mu)^2 }
$$

در Prometheus، این رو با `stddev_over_time()` محاسبه می‌کنیم.

---

## 🧪 مثال واقعی از Prometheus

فرض کن یه متریک مثل `temperature_celsius` داریم که دمای یک سرور رو در ۵ دقیقه اخیر نشون می‌ده:

```promql
stddev_over_time(temperature_celsius[5m])
```

فرض کن داده‌ها این باشن:

```
x₁ = 25.0
x₂ = 26.0
x₃ = 27.5
x₄ = 25.5
x₅ = 26.5
```

* میانگین:

$$
\mu = \frac{25.0 + 26.0 + 27.5 + 25.5 + 26.5}{5} = \frac{130.5}{5} = 26.1
$$

* واریانس:

$$
\text{Var} = \frac{(25 - 26.1)^2 + (26 - 26.1)^2 + (27.5 - 26.1)^2 + (25.5 - 26.1)^2 + (26.5 - 26.1)^2}{5}
$$

$$
= \frac{1.21 + 0.01 + 1.96 + 0.36 + 0.16}{5} = \frac{3.7}{5} = 0.74
$$

* انحراف معیار:

$$
\text{StdDev} = \sqrt{0.74} \approx 0.86
$$

---

## 🔍 تفاوت واحد

| تابع                 | مقدار | واحد  |
| -------------------- | ----- | ----- |
| `avg_over_time()`    | 26.1  | °C    |
| `stdvar_over_time()` | 0.74  | (°C)² |
| `stddev_over_time()` | 0.86  | °C    |

---

## ⏱ نکته درباره Range Vector

در Prometheus، این توابع فقط روی داده‌هایی که در بازه زمانی مشخصی جمع‌آوری شدن (`[5m]`، `[1h]`، ...) قابل استفاده هستن.

---


### `min` و `max`

عملگرهای `min` و `max` به ترتیب حداقل یا حداکثر مقدار درون یک گروه را به عنوان مقدار گروه برمی‌گردانند. قوانین گروه‌بندی مشابه سایر موارد اعمال می‌شود، بنابراین سری زمانی خروجی، برچسب‌های گروه را خواهد داشت.⁹ برای مثال:
`max without(device, fstype, mountpoint)(node_filesystem_size_bytes)`
اندازه بزرگترین فایل‌سیستم را در هر نمونه برمی‌گرداند که برای ما نتیجه زیر را دارد:
`{instance="localhost:9100",job="node"} 90131324928`
عملگرهای `max` و `min` تنها در صورتی `NaN` برمی‌گردانند که تمام مقادیر در یک گروه `NaN` باشند.



---

## ✅ تعریف  `topk` و `bottomk`

در PromQL، وقتی یه **بردار نمونه (instant vector)** داریم (یعنی چند سری زمانی که هرکدوم یک مقدار فعلی دارند)، ممکن است بخواهیم فقط **n تا از اون‌ها** رو ببینیم که **بیشترین یا کمترین مقدار را دارند**.

### `topk(k, vector)`

* خروجی: **k تا از سری‌های زمانی که بالاترین مقدار را دارند.**

### `bottomk(k, vector)`

* خروجی: **k تا از سری‌های زمانی که پایین‌ترین مقدار را دارند.**

---

## 📌 کاربردهای رایج

| کاربرد                                           | تابع      |
| ------------------------------------------------ | --------- |
| پیدا کردن سرویس‌هایی که بیشترین CPU مصرف می‌کنن  | `topk`    |
| پیدا کردن پادهایی که حافظه‌ی کمتری مصرف می‌کنن   | `bottomk` |
| یافتن منابعی که بیشترین خطا رو دارن              | `topk`    |
| مانیتور کردن منابعی که تقریباً بدون استفاده هستن | `bottomk` |

---

## 🔍 چند مثال واقعی

### ۱. بیشترین مصرف CPU توسط نودها

```promql
topk(3, rate(node_cpu_seconds_total{mode="user"}[1m]))
```

> سه نودی که در حالت "user" بیشترین مصرف CPU رو در یک دقیقه اخیر داشتن.

---

### ۲. کمترین مصرف حافظه توسط پادها

```promql
bottomk(5, container_memory_usage_bytes{job="kubelet", image!=""})
```

> ۵ تا از پادهایی که کمترین میزان حافظه رو مصرف می‌کنن (و image خالی ندارن).

---

### ۳. بیشترین خطای HTTP در سرویس‌ها

```promql
topk(5, rate(http_requests_total{status=~"5.."}[5m]))
```

> ۵ تا از سرویس‌هایی که بیشترین نرخ خطای ۵xx رو در ۵ دقیقه گذشته داشتن.

---

### ۴. پادهایی با کمترین ورودی شبکه

```promql
bottomk(10, rate(container_network_receive_bytes_total[1m]))
```

> ۱۰ پاد با کمترین نرخ دریافت داده از شبکه در یک دقیقه اخیر.

---

## ⚠️ نکات مهم

۱. ‏`topk` و `bottomk` فقط روی **مقادیر instance vector** کار می‌کنن، نه روی range vector (مثل `[5m]`). پس اول باید توابعی مثل `rate()`، `avg_over_time()`، یا `sum()` استفاده بشن تا مقدار فعلی از داده‌های تاریخی ساخته بشه.

۲. ‏`k` باید **عدد ثابت و صحیح** باشه، مثل `5` یا `10`.

۳. اگه سری‌های زمانی هم‌مقدار باشن، ممکنه Prometheus انتخاب‌های مختلفی برگردونه، چون این تابع‌ها تضمین نمی‌کنن که کدوم سری برگرده در صورت تساوی.

---

## 📊 ترکیب با `sum`, `by()`, `rate()`

مثلاً اگه بخواهیم پادهایی رو پیدا کنیم که بیشترین مصرف CPU رو دارند، باید اول مجموع مصرف CPU رو برای هر پاد محاسبه کنیم:

```promql
topk(5, sum(rate(container_cpu_usage_seconds_total[1m])) by (pod))
```

> این یعنی: مجموع نرخ مصرف CPU در ۱ دقیقه گذشته رو برای هر پاد حساب کن، بعد ۵ تای اول رو نشون بده.

---

## 🎯 جمع‌بندی

| تابع                 | کاربرد                                              |
| -------------------- | --------------------------------------------------- |
| `topk(k, vector)`    | نشون دادن k تا از سری‌های زمانی با بیشترین مقدار    |
| `bottomk(k, vector)` | نشون دادن k تا با کمترین مقدار                      |
| قابل ترکیب با        | `rate()`, `sum()`, `avg_over_time()`, `by()` و غیره |

### نکته:

- ‏`k` باید یک عدد صحیح مثبت باشه.
- مقدار ورودی باید **یک بردار فوری (instant vector)** باشه. مثلاً خروجی `rate(...)` یا `avg_over_time(...)` که در یک لحظه محاسبه شده.
### `topk` و `bottomk`

دو  مورد `topk` و `bottomk` از سه جهت با سایر عملگرهای تجمیعی که تاکنون بحث شده‌اند، متفاوت هستند. اول، برچسب‌های سری‌های زمانی که برای یک گروه برمی‌گردانند، برچسب‌های آن گروه نیستند؛ دوم، می‌توانند بیش از یک سری زمانی به ازای هر گروه برگردانند؛ و سوم، یک پارامتر اضافی می‌گیرند. `topk` تعداد k سری زمانی با بزرگترین مقادیر را برمی‌گرداند، بنابراین برای مثال:

`topk without(device, fstype, mountpoint)(2, node_filesystem_size_bytes)`

تا دو  سری زمانی به ازای هر گروه برمی‌گرداند، مانند:

```json
node_filesystem_size_bytes{device="/dev/sda5",fstype="ext4",
instance="localhost:9100",job="node",mountpoint="/"} 90131324928
node_filesystem_size_bytes{device="tmpfs",fstype="tmpfs",
instance="localhost:9100",job="node",mountpoint="/run"} 826961920
```

همانطور که می‌بینید، `topk` سری‌های زمانی ورودی را با تمام برچسب‌هایشان، از جمله برچسب `__name__` که نام متریک را در خود نگه می‌دارد، برمی‌گرداند. نتیجه همچنین مرتب شده است.

-
- اگر می‌خواهید سری‌های زمانی ورودی برگردانده شوند، از `topk` یا `bottomk` استفاده کنید.
- در محاسبات ممیز شناور، هرگونه مقایسه با `NaN` همیشه `false` برمی‌گرداند. جدا از ایجاد موارد عجیب مانند `NaN != NaN` که `false` برمی‌گرداند، یک پیاده‌سازی ساده‌انگارانه از `min` و `max` اگر `NaN` اولین مقدار بررسی شده بود، روی آن گیر می‌کرد (و زمانی اینطور بود).
- در این حالت k برابر ۲ است.

‏`bottomk` مشابه `topk` است، با این تفاوت که k سری زمانی با کوچکترین مقادیر را به جای k سری زمانی با بزرگترین مقادیر برمی‌گرداند. هر دو عملگر، در صورت امکان، از برگرداندن سری‌های زمانی با مقادیر `NaN` خودداری می‌کنند. یک نکته قابل توجه (gotcha) هنگام استفاده از این عملگرها با نقطه پایانی (endpoint) `query_range` در API HTTP وجود دارد. همانطور که در بخش «query_range» در گذشته بحث شد، ارزیابی هر مرحله مستقل است. اگر از `topk` استفاده کنید، ممکن است سری زمانی برتر از مرحله‌ای به مرحله دیگر تغییر کند. بنابراین یک `topk(5, some_gauge)` برای یک `query_range` با ۱۰۰۰ مرحله می‌تواند در بدترین حالت ۵۰۰۰ سری زمانی مختلف برگرداند. راه حل این مشکل استفاده از اصلاح‌گر at (`@`) است، همانطور که در بخش «اصلاح‌گر At» (At Modifier) در صفحه‌های گذشته بحث شد.



# `quantile`، `histogram_quantile` و `quantile_over_time` part 1

---

## 📌 مروری سریع:

| تابع                   | کاربرد اصلی                                                                            |
| ---------------------- | -------------------------------------------------------------------------------------- |
| `quantile()`           | محاسبه صدک از یک **بردار نمونه** (instant vector)                                      |
| `quantile_over_time()` | محاسبه صدک از یک **range vector** (مثلاً داده‌های ۵ دقیقه اخیر)                        |
| `histogram_quantile()` | محاسبه صدک از **مقادیر histogram bucket**ها (مثل داده‌های Prometheus histogram metric) |

---

# ✅ ۱. `quantile(scalar q, vector)`

### صدک از داده‌های لحظه‌ای

* ورودی: یک عدد صدک `q` (بین 0 و 1) و یک instant vector
* خروجی: مقدار صدک `q` از اون بردار

### مثال:

```promql
quantile(0.9, rate(http_request_duration_seconds_sum[1m]) / rate(http_request_duration_seconds_count[1m]))
```

> اینجا داریم `p90` زمان پاسخ درخواست‌ها رو محاسبه می‌کنیم با استفاده از میانگین‌ها.

البته این مثال برای داده‌های histogram بهتر با `histogram_quantile()` زده می‌شه (در ادامه توضیح می‌دم).

---

# ✅ ۲. `quantile_over_time(scalar q, range-vector)`

### صدک از یک بازه زمانی برای یک سری زمانی

* ورودی: یک صدک (مثل `0.95`) و یک range vector (مثلاً `[5m]`)
* خروجی: مقدار صدک `q` از تمام مقادیر موجود در آن بازه زمانی

### مثال:

```promql
quantile_over_time(0.95, http_request_duration_seconds_bucket{le="0.5"}[5m])
```

> صدک 95ام از bucketهایی که در ۵ دقیقه گذشته داده جمع‌آوری کردن.
> اما باز هم `histogram_quantile` برای داده‌های bucketی بهتره.

### مثال واضح‌تر با داده معمولی:

فرض کنیم یه متریک داریم:

```promql
quantile_over_time(0.75, node_load1[10m])
```

> صدک 75٪ از `node_load1` در ۱۰ دقیقه اخیر — یعنی بار پردازش CPU در بازه زمانی اخیر چطور بوده.

---

# ✅ ۳. `histogram_quantile(q, buckets)`

### محاسبه دقیق صدک از روی داده‌های histogram

این تابع برای داده‌هایی استفاده می‌شه که به شکل bucket هستند، مثل:

* ‏`http_request_duration_seconds_bucket{le="..."}` (جمع‌شون نشون می‌ده چند درخواست در کمتر از `le` ثانیه انجام شدن)

🔧 باید داده‌ها رو با `rate()` و `sum() by(le)` گروه‌بندی کنی تا `histogram_quantile()` بتونه روش کار کنه.

### مثال خیلی مهم:

```promql
histogram_quantile(0.95,
  sum(rate(http_request_duration_seconds_bucket[5m])) by (le)
)
```

> محاسبه صدک 95٪ از مدت‌زمان پاسخ درخواست‌ها در ۵ دقیقه اخیر.

### اگه بخوایم برای هر مسیر (`handler`) جدا حساب کنی:

```promql
histogram_quantile(
  0.95,
  sum(rate(http_request_duration_seconds_bucket[5m])) by (le, handler)
)
```

---

## 📘 تفاوت کلیدی بین این توابع

| تابع                   | نوع ورودی        | نوع کاربرد                   | دقیق‌ترین برای histogram            |
| ---------------------- | ---------------- | ---------------------------- | ----------------------------------- |
| `quantile()`           | بردار نمونه      | صدک از چند سری مختلف         | ❌ فقط روی مقادیر عددی کار می‌کنه    |
| `quantile_over_time()` | range vector     | صدک در طول زمان یک سری       | ❌ ساده اما نه برای bucket           |
| `histogram_quantile()` | bucketها با `le` | صدک دقیق از histogram metric | ✅ مناسب برای متریک‌هایی مثل latency |

---

## 🧪 مقایسه با هم روی یک سناریو

فرض کن یه متریک داریم از زمان پاسخ درخواست‌ها که به صورت histogram جمع می‌شه.

### `histogram_quantile`:

```promql
histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le))
```

> دقیق‌ترین راه برای محاسبه p95 از داده‌های bucketی.

### `quantile_over_time`:

```promql
quantile_over_time(0.95, http_request_duration_seconds_sum[5m])
```

> صدک 95٪ از مجموع زمان پاسخ‌ها در ۵ دقیقه – نه دقیق برای histogram.

### `quantile`:

```promql
quantile(0.95, rate(http_request_duration_seconds_sum[1m]) / rate(http_request_duration_seconds_count[1m]))
```

> محاسبه صدک بر اساس نرخ میانگین‌ها — گاهی گمراه‌کننده می‌شه.

---

## ✨ نتیجه‌گیری

| می‌خوای چکار کنی؟                             | تابع مناسب             |
| --------------------------------------------- | ---------------------- |
| صدک از داده‌ی histogram (مثل latency یا size) | `histogram_quantile()` |
| صدک از داده‌ی ساده در طول زمان                | `quantile_over_time()` |
| صدک از چند سری هم‌زمان در لحظه                | `quantile()`           |

---



### `quantile`

عملگر `quantile` چارک (quantile) مشخص شده از مقادیر گروه را به عنوان مقدار بازگشتی گروه برمی‌گرداند. مانند `topk`، `quantile` نیز یک پارامتر می‌گیرد. بنابراین، برای مثال، اگر می‌خواستیم بدانیم در میان CPUهای مختلف در هر یک از ماشین‌هایمان، صدک ۹۰ام (90th percentile) استفاده از CPU در حالت `system` چقدر است، می‌توانستیم از دستور زیر استفاده کنیم:

`quantile without(cpu)(0.9, rate(node_cpu_seconds_total{mode="system"}[5m]))`

که نتیجه‌ای مانند زیر تولید می‌کند:

`{instance="localhost:9100",job="node",mode="system"} 0.024558620689654007`

این بدان معناست که ۹۰٪ از CPUهای ما حداقل ۰.۰۲ ثانیه در هر ثانیه را در حالت `system` صرف می‌کنند. این کوئری اگر در ماشین خود ده‌ها CPU داشتیم، به جای چهار CPUیی که در حال حاضر دارد، مفیدتر بود. علاوه بر میانگین، می‌توانید از `quantile` برای نشان دادن میانه (median)، صدک ۲۵ام و ۷۵ام در نمودارهای خود استفاده کنید. برای مثال، برای استفاده CPU توسط فرآیند، عبارات به شرح زیر خواهند بود:

```promql
# میانگین، میانگین حسابی
avg without(instance)(rate(process_cpu_seconds_total[5m]))
# چارک ۰.۲۵، صدک ۲۵ام، چارک اول یا پایین‌تر
quantile without(instance)(0.25, rate(process_cpu_seconds_total[5m]))
# چارک ۰.۵، صدک ۵۰ام، چارک دوم، میانه
quantile without(instance)(0.5, rate(process_cpu_seconds_total[5m]))
# چارک ۰.۷۵، صدک ۷۵ام، چارک سوم یا بالاتر
quantile without(instance)(0.75, rate(process_cpu_seconds_total[5m]))
```

این به شما درکی از نحوه رفتار نمونه‌های مختلف یک `job` می‌دهد، بدون اینکه مجبور باشید هر نمونه را به صورت جداگانه رسم کنید. این به شما امکان می‌دهد با افزایش تعداد نمونه‌های زیربنایی، داشبوردهای خود را خوانا نگه دارید. شخصاً متوجه شده‌ایم که نمودارهای به تفکیک نمونه، در حدود سه تا پنج نمونه کارایی خود را از دست می‌دهند.

# `quantile`، `histogram_quantile` و `quantile_over_time` part2

همانطور که شاید تاکنون متوجه شده باشید، بیش از یک تابع یا عملگر PromQL با کلمه `quantile` در نام خود وجود دارد. عملگر تجمیع `quantile` روی یک بردار لحظه‌ای در یک گروه تجمیع عمل می‌کند. تابع `quantile_over_time` همزمان روی یک سری زمانی واحد در یک بردار بازه‌ای (range vector) عمل می‌کند. تابع `histogram_quantile` همزمان روی باکت‌های (buckets) یک فرزند متریک هیستوگرام در یک بردار لحظه‌ای عمل می‌کند.

### `count_values`

آخرین عملگر تجمیع `count_values` است. مانند `topk`، این عملگر یک پارامتر می‌گیرد و می‌تواند بیش از یک سری زمانی از یک گروه برگرداند. کاری که انجام می‌دهد این است که یک هیستوگرام فراوانی (frequency histogram) از مقادیر سری‌های زمانی در گروه ایجاد می‌کند، به طوری که تعداد هر مقدار به عنوان مقدار سری زمانی خروجی و مقدار اصلی به عنوان یک برچسب جدید در نظر گرفته می‌شود. این عبارت کمی طولانی و پیچیده است، بنابراین یک مثال برای شما می‌آوریم. فرض کنید یک سری زمانی به نام `software_version` با مقادیر زیر دارید:

```json
software_version{instance="a",job="j"} 7
software_version{instance="b",job="j"} 4
software_version{instance="c",job="j"} 8
software_version{instance="d",job="j"} 4
software_version{instance="e",job="j"} 7
software_version{instance="f",job="j"} 4
```

اگر کوئری زیر را روی این سری‌های زمانی ارزیابی کنید:

`count_values without(instance)("version", software_version)`

نتیجه زیر را دریافت خواهید کرد:

```
{job="j",version="7"} 2
{job="j",version="8"} 1
{job="j",version="4"} 3
```

دو سری زمانی در گروه با مقدار ۷ وجود داشت، بنابراین یک سری زمانی با `version="7"` به همراه برچسب‌های گروه با مقدار ۲ برگردانده شد. نتیجه برای سایر سری‌های زمانی مشابه است. هنگام ایجاد هیستوگرام فراوانی، هیچ باکت‌بندی (bucketing) انجام نمی‌شود؛ از مقادیر دقیق سری‌های زمانی استفاده می‌شود. بنابراین، این عملگر تنها با مقادیر صحیح و در جایی که تعداد مقادیر منحصربه‌فرد زیاد نباشد، واقعاً مفید است. این بیشتر با شماره‌های نسخه، یا با تعداد اشیاء از نوع خاصی که هر نمونه از برنامه شما مشاهده می‌کند، مفید است. اگر نسخه‌های زیادی را همزمان مستقر کرده باشید، یا برنامه‌های مختلف همچنان تعداد متفاوتی از اشیاء را مشاهده کنند، ممکن است چیزی در جایی گیر کرده باشد. `count_values` را می‌توان با `count` ترکیب کرد تا تعداد مقادیر منحصربه‌فرد را برای یک گروه تجمیع معین محاسبه کرد. برای مثال، تعداد نسخه‌های نرم‌افزاری که مستقر شده‌اند را می‌توان با دستور زیر محاسبه کرد:

`count without(version)( count_values without(instance)("version", software_version) )`

که در این مورد نتیجه زیر را برمی‌گرداند:

`{job="j"} 3`

همچنین می‌توانید `count_values` را با `count` در جهت دیگر ترکیب کنید؛ برای مثال، برای دیدن اینکه چه تعداد از ماشین‌های شما چه تعداد دستگاه دیسک دارند:

`count_values without(instance)( "devices", count without(device) (node_disk_io_now) )`

در مورد ما، یک ماشین با پنج دستگاه دیسک داریم:

`{devices="5",job="node"} 1`

اکنون که با عملگرهای تجمیع آشنا شدید، به عملگرهای دودویی (binary operators) مانند جمع و تفریق و نحوه عملکرد تطابق برداری (vector matching) خواهیم پرداخت.

---
**توضیحات پاورقی‌ها (footnotes) که در متن با شماره مشخص شده‌اند:**

۲. در مورد شمارنده‌ها (counters) صحبت می‌شود.
۳. منظور `count` داخلی در عبارت `count without(cpu)(count without (mode)(node_cpu_seconds_total))` است.
۴. منظور مقادیر عددی سری‌های زمانی است.
۵. به این دلیل که تقسیم بر صفر (0/1) نتیجه `NaN` (Not a Number) می‌دهد.
۶. منظور عدد ۱.۶۳۳ به عنوان انحراف معیار برای مثال [۲،۴،۶] است.
۷. این یک خاصیت آماری توزیع نرمال است.
۸. واریانس معیار برابر است با (انحراف معیار) به توان ۲.
۹. اگر می‌خواهید سری زمانی ورودی برگردانده شود، از `topk` یا `bottomk` استفاده کنید.
۱۰. در ریاضیات ممیز شناور، هر مقایسه‌ای با `NaN` همیشه `false` برمی‌گرداند. جدا از ایجاد موارد عجیب مانند `NaN != NaN` که `false` برمی‌گرداند، یک پیاده‌سازی ساده از `min` و `max` (که قبلاً هم اتفاق افتاده) اگر اولین مقدار بررسی شده `NaN` بود، روی آن گیر می‌کرد.
۱۱. در این مثال، k برابر ۲ است.
۱۲. صدک‌ها (Percentiles)
۱۳. مانند شماره نسخه‌های نرم‌افزار.