

شما احتمالاً می‌خواهید با متریک‌های خود کاری بیش از جمع‌آوری (aggregate) صرف انجام دهید، و اینجاست که عملگرهای دوتایی (binary operators) وارد می‌شوند. عملگرهای دوتایی، عملگرهایی هستند که دو عملوند (operand)  می‌گیرند، مانند عملگرهای جمع و تساوی. عملگرهای دوتایی در PromQL امکان چیزی بیش از محاسبات حسابی ساده روی بردارهای لحظه‌ای (instant vectors) را فراهم می‌کنند؛ شما همچنین می‌توانید یک عملگر دوتایی را با گروه‌بندی مبتنی بر برچسب‌ها (labels)، روی دو بردار لحظه‌ای اعمال کنید. اینجاست که قدرت واقعی PromQL آشکار می‌شود و امکان انجام دسته‌بندی‌هایی از تحلیل را فراهم می‌کند که تعداد کمی از سیستم‌های متریک دیگر ارائه می‌دهند. PromQL سه دسته عملگر دوتایی دارد: عملگرهای حسابی، عملگرهای مقایسه‌ای، و عملگرهای منطقی. این فصل نحوه‌ی استفاده از آن‌ها را به شما نشان خواهد داد.

### کار با اسکالرها (Scalars)

علاوه بر بردارهای لحظه‌ای و بردارهای بازه‌ای (range vectors)، نوع دیگری از مقدار وجود دارد که به عنوان اسکالر  شناخته می‌شود. اسکالرها اعداد منحصربه‌فردی بدون بُعد هستند. به عنوان مثال، `0` یک اسکالر با مقدار صفر است، در حالی که `{} 0` یک بردار لحظه‌ای حاوی یک نمونه‌ی واحد بدون برچسب و با مقدار صفر است.

## عملگرهای حسابی (Arithmetic operators)

شما می‌توانید از اسکالرها در محاسبات حسابی با یک بردار لحظه‌ای برای تغییر مقادیر موجود در آن بردار لحظه‌ای استفاده کنید. برای مثال:

`process_resident_memory_bytes / 1024`

نتیجه‌ی زیر را برمی‌گرداند:
`{instance="localhost:9090",job="prometheus"} 21376`
`{instance="localhost:9100",job="node"} 13316`

که این همان میزان استفاده از حافظه‌ی فرآیند، برحسب کیلوبایت<sup>۴</sup> است. توجه خواهید کرد که عملگر تقسیم روی تمام سری‌های زمانی (time series) در بردار لحظه‌ای بازگردانده شده توسط انتخابگر (selector) `process_resident_memory_bytes` اعمال شد، و نام متریک حذف شد زیرا دیگر متریک `process_resident_memory_bytes` نیست.

هر شش عملیات حسابی به طور مشابه، با همان معنایی که از سایر زبان‌های برنامه‌نویسی انتظار دارید، کار می‌کنند. آن‌ها عبارتند از:

• `+` جمع
• `-` تفریق
• `*` ضرب
• `/` تقسیم
• `%` باقیمانده (modulo)
• `^` توان

عملگر باقیمانده یک عملگر باقیمانده‌ی ممیز شناور (floating-point modulo) است و اگر ورودی غیرصحیح به آن بدهید، می‌تواند نتایج غیرصحیح برگرداند. برای مثال:

`5 % 1.5`

نتیجه‌ی زیر را برمی‌گرداند:

`0.5`

همانطور که این مثال نشان می‌دهد، شما همچنین می‌توانید از عملگرهای حسابی دوتایی زمانی که هر دو عملوند اسکالر هستند، استفاده کنید. نتیجه یک اسکالر خواهد بود. این بیشتر برای خوانایی مفید است، زیرا درک منظورِ `(1024 * 1024 * 1024)` بسیار آسان‌تر از `1073741824` است.

علاوه بر این، شما می‌توانید عملوند اسکالر را در سمت چپ عملگر و یک بردار لحظه‌ای را در سمت راست قرار دهید، بنابراین برای مثال: `1e9 - process_resident_memory_bytes` حافظه‌ی فرآیند را از یک میلیارد کم می‌کند. شما همچنین می‌توانید از عملگرهای حسابی با بردارهای لحظه‌ای در هر دو طرف استفاده کنید، که در بخش «تطبیق برداری» (Vector Matching) در ادامه پوشش داده شده است.

### عملگر مثلثاتی (Trigonometric Operator)
عملگر `atan2` آرک‌تانژانت تقسیم دو بردار را برمی‌گرداند، و از علامت‌های آن دو برای تعیین ربع (quadrant) مقدار بازگشتی استفاده می‌کند:
`x atan2 y`
این عملگر به شما امکان می‌دهد `atan2` را با استفاده از تطبیق برداری روی دو بردار اجرا کنید، چیزی که با توابع معمولی در دسترس نیست. این عملگر به شیوه‌ای مشابه عملگرهای حسابی (`+`, `-`, `*`, …) عمل می‌کند.

### عملگرهای مقایسه‌ای (Comparison Operators)
عملگرهای مقایسه‌ای با معانی معمول خود به شرح زیر هستند:

```
• == مساوی
• != نامساوی
• > بزرگتر از
• < کوچکتر از
• >= بزرگتر یا مساوی با
• <= کوچکتر یا مساوی با
```
چیزی که کمی متفاوت است، این است که عملگرهای مقایسه‌ای در PromQL فیلترکننده (filtering) هستند.
یعنی اگر شما نمونه‌های زیر را داشتید:
`process_open_fds{instance="localhost:9090",job="prometheus"} 14`
`process_open_fds{instance="localhost:9100",job="node"} 7`
و از یک بردار لحظه‌ای در مقایسه با یک اسکالر استفاده می‌کردید، مانند عبارت زیر:
`process_open_fds > 10`
آنگاه نتیجه‌ی زیر را دریافت می‌کردید:
`process_open_fds{instance="localhost:9090",job="prometheus"} 14`

چیزی که شما نیاز دارید، راهی برای انجام مقایسه است بدون اینکه فیلتر شود. این کاری است که اصلاحگر (modifier) `bool` انجام می‌دهد؛ برای هر مقایسه، برای نادرست بودن (false) عدد `0` و برای درست بودن (true) عدد `1` را برمی‌گرداند. برای مثال:

`process_open_fds > bool 10`

نتیجه‌ی زیر را برمی‌گرداند:
`{instance="localhost:9090",job="prometheus"} 1`
`{instance="localhost:9100",job="node"} 0`

که همانطور که انتظار می‌رود، به ازای هر نمونه در بردار لحظه‌ای ورودی، یک نمونه خروجی دارد.

از آنجا می‌توانید aggregate بزنید تا تعداد فرآیندهایی را برای هر `job` که بیش از ۱۰ توصیف‌گر فایل (file descriptor) باز دارند، بدست آورید:

`sum without(instance)(process_open_fds > bool 10)`

که نتیجه‌ای را که در ابتدا می‌خواستید تولید می‌کند:
```
{job="prometheus"} 1
{job="node"} 0
```

شما می‌توانید از رویکرد مشابهی برای یافتن نسبت ماشین‌هایی با بیش از چهار دستگاه دیسک استفاده کنید:

```
avg without(instance)(
  count without(device)(node_disk_io_now) > bool 4
)
```

این کار با استفاده از aggregate (تجمیع) `count` برای یافتن تعداد دیسک‌های گزارش‌شده توسط هر Node Exporter شروع می‌شود، سپس بررسی می‌کند که چه تعداد بیش از چهار دیسک دارند، و در نهایت میانگین را در بین ماشین‌ها برای بدست آوردن نسبت محاسبه می‌کند. ترفند اینجا این است که مقادیر بازگردانده شده توسط modifier یا اصلاحگر `bool` همگی `0` و `1` هستند، بنابراین `count` تعداد کل ماشین‌ها، و `sum` تعداد ماشین‌هایی است که معیارها را برآورده می‌کنند. `avg` همان `count` تقسیم بر `sum` است که به شما یک نسبت یا تناسب می‌دهد. اصلاحگر `bool` تنها راهی است که می‌توانید اسکالرها را مقایسه کنید، زیرا:

```
42 <= bool 13
```
نتیجه‌ی زیر را برمی‌گرداند:
`0`
که در اینجا `0` نشان‌دهنده‌ی نادرست بودن (false) است.

### تطبیق برداری (Vector Matching)

استفاده از عملگرها بین اسکالرها و بردارهای لحظه‌ای بسیاری از نیازهای شما را پوشش می‌دهد، اما استفاده از عملگرها بین دو بردار لحظه‌ای جایی است که قدرت PromQL واقعاً شروع به درخشش می‌کند.

وقتی یک اسکالر و یک بردار لحظه‌ای دارید، واضح است که اسکالر می‌تواند به هر نمونه در بردار اعمال شود. اما با دو بردار لحظه‌ای، کدام نمونه‌ها باید به کدام نمونه‌های دیگر اعمال شوند؟ این تطبیق بردارهای لحظه‌ای به عنوان تطبیق برداری (vector matching) شناخته می‌شود.

### یک-به-یک (One-to-One)

در ساده‌ترین حالت‌ها، یک نگاشت (mapping) یک-به-یک بین دو بردار شما وجود خواهد داشت. فرض کنید نمونه‌های زیر را داشتید:
```
process_open_fds{instance="localhost:9090",job="prometheus"} 14
process_open_fds{instance="localhost:9100",job="node"} 7
process_max_fds{instance="localhost:9090",job="prometheus"} 1024
process_max_fds{instance="localhost:9100",job="node"} 1024
```
سپس وقتی عبارت زیر را ارزیابی می‌کردید:
```
process_open_fds
/
process_max_fds
```
نتیجه‌ی زیر را دریافت می‌کردید:
```
{instance="localhost:9090",job="prometheus"} 0.013671875
{instance="localhost:9100",job="node"} 0.0068359375
```
آنچه در اینجا اتفاق افتاده این است که نمونه‌هایی با برچسب‌های دقیقاً یکسان، به جز نام متریک در برچسب `__name__`، با هم تطبیق داده شده‌اند. یعنی دو نمونه با برچسب‌های `{instance="localhost:9090",job="prometheus"}` با هم تطبیق داده شدند، و دو نمونه با برچسب‌های `{instance="localhost:9100",job="node"}` با هم تطبیق داده شدند.

در این حالت، یک تطابق کامل وجود داشت و هر نمونه در هر دو طرف عملگر تطبیق داده شد. اگر نمونه‌ای در یک طرف، مطابقتی در طرف دیگر نداشته باشد، در نتیجه وجود نخواهد داشت، زیرا عملگرهای دوتایی به دو عملوند نیاز دارند. اگر یک عملگر دوتایی در حالی که انتظار نتیجه‌ای را دارید، یک بردار لحظه‌ای خالی برگرداند، احتمالاً به این دلیل است که برچسب‌های نمونه‌ها در عملوندها با هم تطابق ندارند. این اغلب به دلیل برچسبی است که در یک طرف عملگر وجود دارد اما در طرف دیگر نه.

گاهی اوقات شما می‌خواهید دو بردار لحظه‌ای را تطبیق دهید که برچسب‌هایشان کاملاً با هم مطابقت ندارند. مشابه اینکه چگونه تجمیع به شما امکان می‌دهد مشخص کنید کدام برچسب‌ها اهمیت دارند (همانطور که در «گروه‌بندی» در درس قبل بحث شد)، تطبیق برداری نیز بندهایی (clauses) برای کنترل اینکه کدام برچسب‌ها در نظر گرفته شوند، دارد.

شما می‌توانید از بند `ignoring` برای نادیده گرفتن برچسب‌های خاص هنگام تطبیق استفاده کنید، مشابه کاری که `without` برای تجمیع انجام می‌دهد. فرض کنید با `node_cpu_seconds_total` کار می‌کنید که `cpu` و `mode` را به عنوان برچسب‌های ابزار دقیق (instrumentation labels) دارد، و می‌خواهید بدانید چه نسبتی از زمان در هر نمونه (instance) در حالت `idle` صرف می‌شود. می‌توانید از عبارت زیر استفاده کنید:
```
sum without(cpu)(rate(node_cpu_seconds_total{mode="idle"}[5m]))
/ ignoring(mode)
sum without(mode, cpu)(rate(node_cpu_seconds_total[5m]))
```
این به شما نتیجه‌ای مانند زیر می‌دهد:
`{instance="localhost:9100",job="node"} 0.8423353718871361`
در اینجا، اولین `sum` یک بردار لحظه‌ای با برچسب `mode="idle"` تولید می‌کند، در حالی که دومین `sum` یک بردار لحظه‌ای بدون برچسب `mode` تولید می‌کند. معمولاً تطبیق برداری در تطبیق نمونه‌ها شکست می‌خورد، اما با `ignoring(mode)` برچسب `mode` هنگام گروه‌بندی بردارها کنار گذاشته می‌شود و تطبیق موفقیت‌آمیز است. از آنجایی که برچسب `mode` در گروه تطبیق نبود، در خروجی نیز وجود ندارد.

شما می‌توانید صحت عبارت قبلی را از نظر تطبیق برداری با بررسی تشخیص دهید، بدون اینکه نیازی به دانستن چیزی در مورد سری‌های زمانی زیربنایی داشته باشید. حذف `cpu` در هر دو طرف متعادل است، و `ignoring(mode)` مسئله‌ی وجود `mode` در یک طرف و عدم وجود آن در طرف دیگر را مدیریت می‌کند. این می‌تواند زمانی که سری‌های زمانی مختلف با برچسب‌های مختلف درگیر هستند، پیچیده‌تر باشد، اما نگاه کردن به عبارات از نظر نحوه‌ی جریان برچسب‌ها، راهی مفید برای تشخیص خطاهاست.

بند `on` به شما امکان می‌دهد فقط برچسب‌هایی را که ارائه می‌دهید در نظر بگیرید، مشابه کاری که `by` برای تجمیع انجام می‌دهد. عبارت:
```
sum by(instance, job)(rate(node_cpu_seconds_total{mode="idle"}[5m]))
/ on(instance, job)
sum by(instance, job)(rate(node_cpu_seconds_total[5m]))
```
نتیجه‌ای مشابه عبارت قبلی تولید خواهد کرد، اما مانند `by`، بند `on` این عیب را دارد که شما باید تمام برچسب‌هایی را که در حال حاضر روی سری زمانی هستند یا ممکن است در آینده در زمینه‌های دیگر وجود داشته باشند، بشناسید.

مقداری که برای عملگرهای حسابی بازگردانده می‌شود، نتیجه‌ی محاسبه است، اما ممکن است بپرسید برای عملگرهای مقایسه‌ای وقتی دو بردار لحظه‌ای وجود دارد، چه اتفاقی می‌افتد. پاسخ این است که مقدار از سمت چپ بازگردانده می‌شود. برای مثال، عبارت:
```
process_open_fds
>
(process_max_fds * .5)
```
مقدار `process_open_fds` را برای تمام نمونه‌هایی که توصیف‌گرهای فایل باز آن‌ها بیش از نیمی از حداکثر است، برای شما برمی‌گرداند.

اگر به جای آن از عبارت زیر استفاده می‌کردید:
```
(process_max_fds * .5)
<
process_open_fds
```
نصف حداکثر توصیف‌گرهای فایل را به عنوان مقدار بازگشتی دریافت می‌کردید. در حالی که نتیجه دارای همان برچسب‌ها خواهد بود، این مقدار ممکن است از نظر معنایی هنگام هشداردهی یا هنگام استفاده در داشبورد کمتر مفید باشد! به طور کلی، یک مقدار فعلی آموزنده‌تر از حد است، بنابراین باید سعی کنید محاسبات خود را طوری ساختار دهید که جالب‌ترین عدد در سمت چپ یک مقایسه قرار گیرد.

### چند-به-یک (Many-to-One) و `group_left`

اگر تطبیق‌دهنده (matcher) روی `mode` را از بخش قبل حذف کرده و سعی کنید عبارت زیر را ارزیابی کنید:
```
sum without(cpu)(rate(node_cpu_seconds_total[5m]))
/ ignoring(mode)
sum without(mode, cpu)(rate(node_cpu_seconds_total[5m]))
```
خطای زیر را دریافت خواهید کرد:
```
multiple matches for labels:
many-to-one matching must be explicit (group_left/group_right)
```

(تطابق‌های چندگانه برای برچسب‌ها: تطبیق چند-به-یک باید صریح باشد (group_left/group_right))

این به این دلیل است که نمونه‌ها دیگر به صورت یک-به-یک تطابق ندارند، زیرا چندین نمونه با برچسب‌های `mode` مختلف در سمت چپ برای هر نمونه در سمت راست وجود دارد. این می‌تواند یک حالت شکست نامحسوس باشد، زیرا ممکن است یک سری زمانی بعداً ظاهر شود که عبارت شما را خراب کند. می‌توانید ببینید که این یک مشکل بالقوه است، زیرا با نگاه کردن به جریان برچسب، چیزی وجود ندارد که برچسب `mode` را به یک مقدار بالقوه در سمت چپ محدود کند.

خطاهایی مانند این معمولاً به دلیل عبارات نادرست نوشته شده‌اند، بنابراین PromQL به طور پیش‌فرض سعی نمی‌کند کار هوشمندانه‌ای انجام دهد. در عوض، شما باید به طور خاص درخواست کنید که می‌خواهید تطبیق چند-به-یک را با استفاده از اصلاحگر `group_left` انجام دهید. `group_left` به شما امکان می‌دهد مشخص کنید که می‌تواند چندین نمونه تطبیق در گروه عملوند سمت چپ وجود داشته باشد. برای مثال:

```
sum without(cpu)(rate(node_cpu_seconds_total[5m]))
/ ignoring(mode) group_left
sum without(mode, cpu)(rate(node_cpu_seconds_total[5m]))
```
به ازای هر برچسب `mode` متفاوت در هر گروه در سمت چپ، یک نمونه خروجی تولید می‌کند:
```
{instance="localhost:9100",job="node",mode="irq"} 0
{instance="localhost:9100",job="node",mode="nice"} 0
{instance="localhost:9100",job="node",mode="softirq"} 0.000052263897841
{instance="localhost:9100",job="node",mode="steal"} 0
{instance="localhost:9100",job="node",mode="system"} 0.0172035330394927
{instance="localhost:9100",job="node",mode="user"} 0.10345203045243238
{instance="localhost:9100",job="node",mode="idle"} 0.8608691486211044
{instance="localhost:9100",job="node",mode="iowait"} 0.0184230239891287
```

‏`group_left` همیشه تمام برچسب‌های خود را از نمونه‌های عملوند شما در سمت چپ می‌گیرد. این تضمین می‌کند که برچسب‌های اضافی که در سمت چپ هستند و نیاز به تطبیق برداری چند-به-یک دارند، حفظ شوند.

این بسیار آسان‌تر از اجرای یک عبارت یک-به-یک با یک تطبیق‌دهنده برای هر برچسب `mode` بالقوه است: `group_left` همه کارها را در یک عبارت برای شما انجام می‌دهد. شما می‌توانید از این رویکرد برای تعیین اینکه هر مقدار برچسب در یک متریک چه نسبتی از کل را نشان می‌دهد (همانطور که در مثال قبل نشان داده شد)، یا برای مقایسه یک متریک از رهبر (leader) یک کلاستر با کپی‌ها (replicas) استفاده کنید.

کاربرد دیگری برای `group_left` وجود دارد—اضافه کردن برچسب‌ها از متریک‌های اطلاعاتی (info metrics) به سایر متریک‌ها از یک هدف (target). ابزار دقیق با متریک‌های اطلاعاتی در «اطلاعات» (Info) در گذشته پوشش داده شد. نقش متریک‌های اطلاعاتی این است که به شما امکان می‌دهند برچسب‌هایی را ارائه دهید که برای یک هدف یا متریک مفید باشند اما اگر از آن به عنوان یک برچسب معمولی استفاده کنید، متریک را شلوغ می‌کنند. برای مثال، متریک `prometheus_build_info` اطلاعات ساخت Prometheus را به شما ارائه می‌دهد:

```
prometheus_build_info{branch="HEAD",goversion="go1.10",
instance="localhost:9090",job="prometheus",
revision="bc6058c81272a8d938c05e75607371284236aadc",version="2.2.1"}
```

شما می‌توانید این را با متریک‌هایی مانند `up` ترکیب کنید:

```
up
* on(instance) group_left(version)
prometheus_build_info
```
که نتیجه‌ای مانند زیر تولید می‌کند:
`{instance="localhost:9090",job="prometheus",version="2.2.1"} 1`
می‌توانید ببینید که برچسب `version` از عملوند سمت راست به عملوند سمت چپ کپی شده است، همانطور که توسط `group_left(version)` درخواست شده بود، علاوه بر بازگرداندن تمام برچسب‌ها از عملوند سمت چپ همانطور که `group_left` معمولاً انجام می‌دهد. شما می‌توانید هر تعداد برچسبی را که دوست دارید به `group_left` مشخص کنید، اما معمولاً فقط یک یا دو برچسب است. این رویکرد بدون توجه به اینکه سمت چپ چند برچسب ابزار دقیق دارد، کار می‌کند، زیرا تطبیق برداری چند-به-یک است.

عبارت قبلی از `on(instance)` استفاده می‌کرد، که متکی بر این است که هر برچسب `instance` فقط برای یک هدف در Prometheus شما استفاده می‌شود. در حالی که این اغلب صادق است، همیشه اینطور نیست، بنابراین ممکن است لازم باشد برچسب‌های دیگری مانند `job` را نیز به بند `on` اضافه کنید. `prometheus_build_info` برای کل یک هدف اعمال می‌شود. همچنین متریک‌هایی به سبک اطلاعاتی مانند `node_hwmon_sensor_label` که در «جمع‌آورنده‌ی Hwmon» در گذشته ذکر شد، وجود دارند که به فرزندان یک متریک دیگر اعمال می‌شوند:
```
node_hwmon_sensor_label{chip="platform_coretemp_0",instance="localhost:9100", job="node",label="core_0",sensor="temp2"} 1
node_hwmon_sensor_label{chip="platform_coretemp_0",instance="localhost:9100", job="node",label="core_1",sensor="temp3"} 1
node_hwmon_temp_celsius{chip="platform_coretemp_0",instance="localhost:9100", job="node",sensor="temp1"} 42
node_hwmon_temp_celsius{chip="platform_coretemp_0",instance="localhost:9100", job="node",sensor="temp2"} 42
node_hwmon_temp_celsius{chip="platform_coretemp_0",instance="localhost:9100", job="node",sensor="temp3"} 41
```
متریک `node_hwmon_sensor_label` فرزندانی دارد که با برخی (اما نه همه) از سری‌های زمانی در `node_hwmon_temp_celsius` تطابق دارند. در این حالت شما می‌دانید که تنها یک برچسب اضافی وجود دارد (که `label` نامیده می‌شود)، بنابراین می‌توانید از `ignoring` با `group_left` برای اضافه کردن این برچسب به نمونه‌های `node_hwmon_temp_celsius` استفاده کنید:
```
node_hwmon_temp_celsius
* ignoring(label) group_left(label)
node_hwmon_sensor_label
```
که نتایجی مانند زیر تولید می‌کند:
```
{chip="platform_coretemp_0",instance="localhost:9100", job="node",label="core_0",sensor="temp2"} 42
{chip="platform_coretemp_0",instance="localhost:9100", job="node",label="core_1",sensor="temp3"} 41
```

توجه داشته باشید که هیچ نمونه‌ای با `sensor="temp1"` وجود ندارد زیرا چنین نمونه‌ای در `node_hwmon_sensor_label` وجود نداشت (نحوه‌ی تطبیق بردارهای لحظه‌ای پراکنده (sparse) در «عملگر or» در آینده پوشش داده خواهد شد).

همچنین یک اصلاحگر `group_right` وجود دارد که به همان روش `group_left` کار می‌کند، با این تفاوت که طرف یک و طرف چند جابجا می‌شوند، و طرف چند اکنون عملوند شما در سمت راست است. هر برچسبی که در اصلاحگر `group_right` مشخص می‌کنید از چپ به راست کپی می‌شود. به خاطر سازگاری، باید `group_left` را ترجیح دهید.

### چند-به-چند (Many-to-Many) و عملگرهای منطقی (Logical Operators)

سه عملگر منطقی یا مجموعه‌ای (set operators) وجود دارد که می‌توانید استفاده کنید:
• `or` اجتماع (union)
• `and` اشتراک (intersection)
• `unless` تفاضل مجموعه (set subtraction)

![[logical_operand.png]]

https://iximiuz.com/en/posts/prometheus-vector-matching/

عملگر `not` وجود ندارد، اما تابع `absent` که در «سری‌های گمشده، absent، و absent_over_time» در گذشته بحث شد، نقش مشابهی ایفا می‌کند. تمام عملگرهای منطقی به صورت چند-به-چند عمل می‌کنند، و تنها عملگرهایی هستند که به این شیوه کار می‌کنند. آن‌ها با عملگرهای حسابی و مقایسه‌ای که قبلاً دیده‌اید متفاوت هستند، زیرا هیچ محاسبه‌ای انجام نمی‌شود؛ تمام چیزی که اهمیت دارد این است که آیا یک گروه حاوی نمونه است یا خیر.

### عملگر or

در بخش قبل، `node_hwmon_sensor_label` نمونه‌ای برای همراهی با هر `node_hwmon_temp_celsius` نداشت، بنابراین نتایج فقط برای نمونه‌هایی که در هر دو بردار لحظه‌ای حضور داشتند، بازگردانده شدند. کار با متریک‌هایی با فرزندان ناسازگار، یا متریک‌هایی که فرزندانشان همیشه حاضر نیستند، دشوار است، اما می‌توانید با استفاده از عملگر `or` با آن‌ها مقابله کنید.

نحوه‌ی کار عملگر `or` به این صورت است که برای هر گروهی که گروه سمت چپ در آن نمونه دارد، آن نمونه‌ها بازگردانده می‌شوند؛ در غیر این صورت، نمونه‌های موجود در گروه سمت راست بازگردانده می‌شوند. اگر با SQL آشنایی دارید، این عملگر می‌تواند به روشی مشابه تابع `COALESCE` در SQL، اما با برچسب‌ها، استفاده شود.

با ادامه‌ی مثال از بخش قبل، می‌توان از `or` برای جایگزینی سری‌های زمانی گمشده از `node_hwmon_sensor_label` استفاده کرد. تمام چیزی که نیاز دارید یک سری زمانی دیگر است که برچسب‌های مورد نیاز شما را داشته باشد، که در این مورد `node_hwmon_temp_celsius` است. `node_hwmon_temp_celsius` برچسب `label` را ندارد، اما تمام برچسب‌های دیگر مطابقت دارند، بنابراین می‌توانید با استفاده از `ignoring` این را نادیده بگیرید:
```
node_hwmon_sensor_label
or ignoring(label)
(node_hwmon_temp_celsius * 0 + 1)
```
تطبیق برداری سه گروه از برچسب‌ها را تولید کرد. دو گروه اول نمونه‌ای از `node_hwmon_sensor_label` داشتند، بنابراین همان چیزی بود که بازگردانده شد، از جمله نام متریک زیرا چیزی برای تغییر آن وجود نداشت. با این حال، برای گروه سوم، که شامل `sensor="temp1"` بود، هیچ نمونه‌ای در گروه برای سمت چپ وجود نداشت، بنابراین از مقادیر موجود در گروه از سمت راست استفاده شد. از آنجا که عملگرهای حسابی روی مقدار استفاده شدند، نام متریک حذف شد.

‏`x * 0 + 1` تمام مقادیر بردار لحظه‌ای `x` را به `1` تغییر می‌دهد. این همچنین زمانی مفید است که می‌خواهید از `group_left` برای کپی کردن برچسب‌ها استفاده کنید، زیرا `1` عنصر همانی (identity element) برای ضرب است، یعنی مقداری را که در آن ضرب می‌کنید تغییر نمی‌دهد.

اکنون می‌توان از این عبارت به جای `node_hwmon_sensor_label` استفاده کرد:
```
node_hwmon_temp_celsius
* ignoring(label) group_left(label)
(
  node_hwmon_sensor_label
  or ignoring(label)
  (node_hwmon_temp_celsius * 0 + 1)
)
```
که نتیجه‌ی زیر را تولید می‌کند:
```
{chip="platform_coretemp_0",instance="localhost:9100", job="node",sensor="temp1"} 42
{chip="platform_coretemp_0",instance="localhost:9100", job="node",label="core_0",sensor="temp2"} 42
{chip="platform_coretemp_0",instance="localhost:9100", job="node",label="core_1",sensor="temp3"} 41
```
نمونه با `sensor="temp1"` اکنون در نتیجه‌ی شما حاضر است. این نمونه برچسبی به نام `label` ندارد، که همانند این است که بگوییم برچسب `label` مقدار رشته‌ی خالی را دارد. در موارد ساده‌تر شما با متریک‌هایی بدون هیچ برچسب ابزار دقیق کار خواهید کرد. برای مثال، ممکن است از جمع‌آورنده‌ی textfile، همانطور که در «جمع‌آورنده‌ی Textfile» در گذشته پوشش داده شد، استفاده کنید و انتظار داشته باشید که متریکی به نام `node_custom_metric` را نمایش دهد. در صورتی که آن متریک وجود نداشته باشد، می‌خواهید به جای آن `0` را برگردانید. در مواردی مانند این، می‌توانید از متریک `up` که با هر هدف مرتبط است استفاده کنید:
```
node_custom_metric
or
up * 0
```
این یک مشکل کوچک دارد و آن این است که حتی برای یک scrape ناموفق نیز مقداری را برمی‌گرداند، که این نحوه‌ی کار متریک‌های scrape شده نیست. همچنین برای `job`های دیگر نیز نتایج را برمی‌گرداند. شما می‌توانید این را با یک تطبیق‌دهنده و مقداری فیلترینگ اصلاح کنید:
```
node_custom_metric
or
(up{job="node"} == 1) * 0
```
راه دیگری که می‌توانید از عملگر `or` استفاده کنید، برگرداندن سری بزرگتر از بین دو سری است:
```
(a >= b) or b
```
اگر `a` بزرگتر باشد، توسط مقایسه بازگردانده می‌شود، و سپس توسط عملگر `or` زیرا گروه سمت چپ خالی نبود. از طرف دیگر، اگر `b` بزرگتر باشد، مقایسه چیزی را برنمی‌گرداند، و `or` مقدار `b` را برمی‌گرداند زیرا گروه سمت چپ خالی بود.

### عملگر unless

عملگر `unless` تطبیق برداری را به همان روش عملگر `or` انجام می‌دهد، و بر اساس اینکه آیا گروه‌های عملوند راست و چپ خالی هستند یا نمونه دارند، کار می‌کند. عملگر `unless` گروه سمت چپ را برمی‌گرداند، مگر اینکه گروه سمت راست عضو داشته باشد، که در این صورت هیچ نمونه‌ای برای آن گروه برنمی‌گرداند. شما می‌توانید از `unless` برای محدود کردن سری‌های زمانی بازگردانده شده بر اساس یک عبارت استفاده کنید. برای مثال، اگر می‌خواستید میانگین استفاده از CPU فرآیندها را به جز آن‌هایی که کمتر از ۱۰۰ مگابایت حافظه‌ی مقیم (resident memory) استفاده می‌کنند، بدانید، می‌توانستید از عبارت زیر استفاده کنید:
```
rate(process_cpu_seconds_total[5m])
unless
process_resident_memory_bytes < 100 * 1024 * 1024
```
‏`unless` همچنین می‌تواند برای تشخیص زمانی که یک متریک از یک هدف  (missing) است، استفاده شود. برای مثال:
```
up{job="node"} == 1
unless
node_custom_metric
```
برای هر نمونه‌ای که متریک `node_custom_metric` را کم داشت، یک نمونه برمی‌گرداند، که می‌توانید از آن در هشداردهی استفاده کنید. به طور پیش‌فرض، مانند تمام عملگرهای دوتایی، `unless` هنگام گروه‌بندی به تمام برچسب‌ها نگاه می‌کند. اگر `node_custom_metric` برچسب‌های ابزار دقیق داشت، می‌توانستید از `on` یا `ignoring` برای بررسی اینکه حداقل یک سری زمانی مرتبط وجود دارد، بدون نیاز به دانستن مقادیر سایر برچسب‌ها استفاده کنید:
```
up == 1
unless on (job, instance)
node_custom_metric
```
حتی اگر چندین نمونه از عملوند سمت راست در یک گروه وجود داشته باشد، این مشکلی ندارد زیرا `unless` از تطبیق چند-به-چند استفاده می‌کند.

## عملگر and

عملگر `and` مخالف عملگر `unless` است. این عملگر یک گروه از عملوند سمت چپ را تنها در صورتی برمی‌گرداند که گروه تطبیق سمت راست نمونه داشته باشد؛ در غیر این صورت، هیچ نمونه‌ای برای آن گروه تطبیق برنمی‌گرداند. می‌توانید آن را به عنوان یک عملگر `if` در نظر بگیرید.<sup>۱۷</sup> شما بیشتر از عملگر `and` در هشداردهی برای مشخص کردن بیش از یک شرط استفاده خواهید کرد. برای مثال، ممکن است بخواهید زمانی را برگردانید که هم تأخیر (latency) بالا باشد و هم بیش از تعداد کمی درخواست کاربر وجود داشته باشد. برای انجام این کار برای Prometheus برای handlerهایی که به طور متوسط بیش از یک ثانیه طول می‌کشیدند و حداقل یک درخواست در ثانیه داشتند، می‌توانستید از عبارت زیر استفاده کنید:
```
(
  rate(http_request_duration_seconds_sum{job="prometheus"}[5m])
  /
  rate(http_request_duration_seconds_count{job="prometheus"}[5m])
) > 1
and
rate(http_request_duration_seconds_count{job="prometheus"}[5m]) > 1
```
این برای هر handler جداگانه در هر `job` مربوط به Prometheus یک نمونه برمی‌گرداند، بنابراین حتی با محدودیت یک درخواست در ثانیه، می‌تواند کمی پر سر و صدا (spammy) باشد. معمولاً هنگام هشداردهی، می‌خواهید در سطح یک `job` تجمیع کنید. شما می‌توانید از `on` و `ignoring` با عملگر `and` استفاده کنید، همانطور که با سایر عملگرهای دوتایی می‌توانید. به طور خاص، از `on()` می‌توان برای داشتن شرطی استفاده کرد که هیچ برچسب مشترکی بین دو عملوند نداشته باشد. برای مثال، می‌توانید از این برای محدود کردن زمان روزی که یک عبارت نتایج را برمی‌گرداند، استفاده کنید:
```
(
  rate(http_request_duration_microseconds_sum{job="prometheus"}[5m])
  /
  rate(http_request_duration_microseconds_count{job="prometheus"}[5m])
) > 1000000
and
rate(http_request_duration_microseconds_count{job="prometheus"}[5m]) > 1
and on()
hour() >= 9 < 17
```
تابع `hour` در «minute, hour, day_of_week, day_of_month, day_of_year, days_in_month, month, و year» در صفحه‌ی ۲۸۴ پوشش داده شده است؛ این تابع یک بردار لحظه‌ای با یک نمونه بدون برچسب و با مقدار ساعت روز UTC زمان ارزیابی کوئری برمی‌گرداند.

### اولویت عملگرها (Operator Precedence)

هنگام ارزیابی یک عبارت با چندین عملگر دوتایی، PromQL به سادگی از چپ به راست عمل نمی‌کند. در عوض، ترتیبی از عملگرها وجود دارد که عمدتاً مشابه ترتیب مورد استفاده در سایر زبان‌ها است:
۱. `^`
۲. `* / % atan2`
۳. `+ -`
۴. `== != > < >= <=`
۵. `unless and`
۶. `or`
برای مثال، `a or b * c + d` همانند `a or ((b * c) + d)` است.

تمام عملگرها به جز `^` چپ-انجمنی (left-associative) هستند. این بدان معناست که `a / b * c` همانند `(a / b) * c` است، اما `a ^ b ^ c` همانند `a ^ (b ^ c)` است.
شما می‌توانید از پرانتز برای تغییر ترتیب ارزیابی استفاده کنید. ما همچنین توصیه می‌کنیم در مواردی که ترتیب ارزیابی ممکن است فوراً برای یک عبارت واضح نباشد، از پرانتز استفاده کنید، زیرا همه اولویت عملگرها را حفظ نکرده‌اند.
اکنون که هم تجمیع‌کننده‌ها (aggregators) و هم عملگرها را درک کرده‌اید، بیایید به بخش نهایی PromQL نگاه کنیم: توابع.

---
