
در Prometheus چندین تابع داخلی ارائه می‌دهد که می‌توانید از آنها در عبارات پرس‌وجو (PromQL) استفاده کنید. این توابع به شما امکان می‌دهند محاسبات پیچیده‌تری انجام دهید و داده‌های متریک را بهتر تحلیل کنید.
## دسته‌بندی توابع در  Prometheus


بعضی توابع آرگومان‌های پیش‌فرض دارند، مثلاً `year(v=vector(time()) instant-vector)`. این بدان معناست که یک آرگومان `v` وجود دارد که یک «وکتور لحظه‌ای» (instant-vector) است و اگر ارائه نشود، مقدار پیش‌فرض آن عبارت `vector(time())` خواهد بود.

`abs()`
‏`abs(v instant-vector)`: وکتوری را برمی‌گرداند که حاوی تمام نمونه‌های float در وکتور ورودی است که به قدر مطلقشان تبدیل شده‌اند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.


----

`absent()`



‏`absent(v instant-vector)`: اگر وکتور ورودی دارای عنصری باشد (نمونه‌های float یا هیستوگرام)، یک وکتور خالی برمی‌گرداند و اگر وکتور ورودی هیچ عنصری نداشته باشد، یک وکتور تک‌عنصری با مقدار ۱ برمی‌گرداند.

این تابع برای هشدار دادن زمانی مفید است که هیچ سری زمانی برای ترکیب مشخصی از نام متریک و لیبل وجود نداشته باشد.
```
absent(nonexistent{job="myjob"})
# => {job="myjob"}

absent(nonexistent{job="myjob",instance=~".*"})
# => {job="myjob"}

absent(sum(nonexistent{job="myjob"}))
# => {}
```
در دو مثال اول، `absent()` سعی می‌کند هوشمندانه لیبل‌های وکتور خروجی تک‌عنصری را از وکتور ورودی استخراج کند.

---

`absent_over_time()`
‏`absent_over_time(v range-vector)`: اگر «وکتور بازه‌ای» (range-vector) ورودی دارای عنصری باشد (نمونه‌های float یا هیستوگرام)، یک وکتور خالی برمی‌گرداند و اگر وکتور بازه‌ای ورودی هیچ عنصری نداشته باشد، یک وکتور تک‌عنصری با مقدار ۱ برمی‌گرداند.

این تابع برای هشدار دادن زمانی مفید است که هیچ سری زمانی برای ترکیب مشخصی از نام متریک و لیبل برای مدت زمان معینی وجود نداشته باشد.
```
absent_over_time(nonexistent{job="myjob"}[1h])
# => {job="myjob"}

absent_over_time(nonexistent{job="myjob",instance=~".*"}[1h])
# => {job="myjob"}

absent_over_time(sum(nonexistent{job="myjob"})[1h:])
# => {}
```
در دو مثال اول، `absent_over_time()` سعی می‌کند هوشمندانه لیبل‌های وکتور خروجی تک‌عنصری را از وکتور ورودی استخراج کند.

----

`ceil()`
‏`ceil(v instant-vector)`: وکتوری را برمی‌گرداند که حاوی تمام نمونه‌های float در وکتور ورودی است که به نزدیک‌ترین عدد صحیح بزرگتر یا مساوی مقدار اصلی‌شان گرد شده‌اند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.
```
ceil(+Inf) = +Inf
ceil(±0) = ±0
ceil(1.49) = 2.0
ceil(1.78) = 2.0
```
`changes()`
‏`changes(v range-vector)`: برای هر سری زمانی ورودی، تعداد دفعاتی که مقدار آن در بازه زمانی ارائه شده تغییر کرده است را به عنوان یک وکتور لحظه‌ای برمی‌گرداند. یک نمونه float و به دنبال آن یک نمونه هیستوگرام، یا برعکس، به عنوان یک تغییر محسوب می‌شود. یک نمونه هیستوگرام شمارنده (counter) و به دنبال آن یک نمونه هیستوگرام گِیج (gauge) با مقادیر دقیقاً یکسان (به جز نوع)، یا برعکس، به عنوان تغییر محسوب نمی‌شود.

----


`clamp()`
‏`clamp(v instant-vector, min scalar, max scalar)`: مقادیر تمام نمونه‌های float در `v` را طوری محدود می‌کند که حد پایین `min` و حد بالای `max` داشته باشند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

----


موارد خاص:
*   اگر `min > max` باشد، یک وکتور خالی برمی‌گرداند.
*   اگر `min` یا `max` برابر `NaN` باشد، نمونه‌های float به `NaN` محدود می‌شوند.

`clamp_max()`
‏`clamp_max(v instant-vector, max scalar)`: مقادیر تمام نمونه‌های float در `v` را طوری محدود می‌کند که حد بالای `max` داشته باشند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`clamp_min()`
‏`clamp_min(v instant-vector, min scalar)`: مقادیر تمام نمونه‌های float در `v` را طوری محدود می‌کند که حد پایین `min` داشته باشند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`day_of_month()`
‏`day_of_month(v=vector(time()) instant-vector)`: نمونه‌های float در `v` را به عنوان مُهرهای زمانی (تعداد ثانیه‌ها از اول ژانویه ۱۹۷۰ UTC) تفسیر کرده و روزِ ماه (در UTC) را برای هر یک از آن مُهرهای زمانی برمی‌گرداند. مقادیر بازگشتی بین ۱ تا ۳۱ هستند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`day_of_week()`
‏`day_of_week(v=vector(time()) instant-vector)`: نمونه‌های float در `v` را به عنوان مُهرهای زمانی (تعداد ثانیه‌ها از اول ژانویه ۱۹۷۰ UTC) تفسیر کرده و روزِ هفته (در UTC) را برای هر یک از آن مُهرهای زمانی برمی‌گرداند. مقادیر بازگشتی بین ۰ تا ۶ هستند، که ۰ به معنای یکشنبه و الی آخر است. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`day_of_year()`
‏`day_of_year(v=vector(time()) instant-vector)`: نمونه‌های float در `v` را به عنوان مُهرهای زمانی (تعداد ثانیه‌ها از اول ژانویه ۱۹۷۰ UTC) تفسیر کرده و روزِ سال (در UTC) را برای هر یک از آن مُهرهای زمانی برمی‌گرداند. مقادیر بازگشتی برای سال‌های غیرکبیسه بین ۱ تا ۳۶۵ و برای سال‌های کبیسه بین ۱ تا ۳۶۶ هستند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`days_in_month()`
‏`days_in_month(v=vector(time()) instant-vector)`: نمونه‌های float در `v` را به عنوان مُهرهای زمانی (تعداد ثانیه‌ها از اول ژانویه ۱۹۷۰ UTC) تفسیر کرده و تعداد روزهای ماهِ هر یک از آن مُهرهای زمانی (در UTC) را برمی‌گرداند. مقادیر بازگشتی بین ۲۸ تا ۳۱ هستند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`delta()`
‏`delta(v range-vector)`: تفاوت بین مقدار اول و آخر هر عنصر سری زمانی در یک وکتور بازه‌ای `v` را محاسبه کرده و یک وکتور لحظه‌ای با دلتاهای داده شده و لیبل‌های معادل برمی‌گرداند. دلتا برای پوشش کامل بازه زمانی مشخص شده در انتخابگر وکتور بازه‌ای برونیابی (extrapolate) می‌شود، بنابراین حتی اگر مقادیر نمونه‌ها همگی صحیح باشند، ممکن است نتیجه‌ای غیرصحیح بدست آید.

مثال زیر تفاوت دمای CPU بین اکنون و ۲ ساعت پیش را برمی‌گرداند:
```
delta(cpu_temp_celsius{host="zeus"}[2h])
```
‏`delta` بر روی نمونه‌های هیستوگرام با محاسبه یک هیستوگرام جدید عمل می‌کند که در آن هر جزء (مجموع و تعداد مشاهدات، باکت‌ها) تفاوت بین جزء مربوطه در اولین و آخرین هیستوگرام بومی (native histogram) در `v` است. با این حال، هر عنصری در `v` که ترکیبی از نمونه‌های float و نمونه‌های هیستوگرام در بازه داشته باشد، از وکتور نتیجه حذف شده و با یک یادداشت (annotation) سطح هشدار (warn-level) مشخص می‌شود.

‏`delta` فقط باید با گِیج‌ها (هم برای float و هم برای هیستوگرام) استفاده شود.

`deriv()`
‏`deriv(v range-vector)`: مشتق بر حسب ثانیه هر سری زمانی float در وکتور بازه‌ای `v` را با استفاده از رگرسیون خطی ساده محاسبه می‌کند. وکتور بازه‌ای باید حداقل دو نمونه float برای انجام محاسبه داشته باشد. هنگامی که `+Inf` یا `-Inf` در وکتور بازه‌ای یافت شود، مقدار شیب و آفست محاسبه شده `NaN` خواهد بود.

‏`deriv` فقط باید با گِیج‌ها استفاده شود و فقط برای نمونه‌های float کار می‌کند. عناصری در وکتور بازه‌ای که فقط حاوی نمونه‌های هیستوگرام هستند، به طور کامل نادیده گرفته می‌شوند. برای عناصری که حاوی ترکیبی از نمونه‌های float و هیستوگرام هستند، فقط از نمونه‌های float به عنوان ورودی استفاده می‌شود که با یک یادداشت سطح اطلاعات (info-level) مشخص می‌شود.

### تا اینجا

### `double_exponential_smoothing()`

این تابع باید از طریق فلگ ویژگی `--enable-feature=promql-experimental-functions` فعال شود.

‏`double_exponential_smoothing(v range-vector, sf scalar, tf scalar)`: یک مقدار هموار شده برای هر سری زمانی float در بازه `v` تولید می‌کند. هرچه ضریب smoothing یا هموارسازی `sf` کمتر باشد، اهمیت بیشتری به داده‌های قدیمی داده می‌شود. هرچه ضریب روند `tf` بالاتر باشد، trendsهای بیشتری در داده‌ها در نظر گرفته می‌شود. هر دو `sf` و `tf` باید بین ۰ و ۱ باشند. برای جزئیات بیشتر، به کتاب راهنمای آمار مهندسی NIST مراجعه کنید. در Prometheus V2 این تابع `holt_winters` نامیده می‌شد. این امر باعث سردرگمی می‌شد زیرا روش هولت-وینترز معمولاً به هموارسازی نمایی سه‌گانه اشاره دارد. هموارسازی نمایی دوگانه همانطور که در اینجا پیاده‌سازی شده است، به عنوان "Holt Linear" نیز شناخته می‌شود.

‏`double_exponential_smoothing` فقط باید با گِیج‌ها استفاده شود و فقط برای نمونه‌های float کار می‌کند. عناصری در وکتور بازه‌ای که فقط حاوی نمونه‌های هیستوگرام هستند، به طور کامل نادیده گرفته می‌شوند. برای عناصری که حاوی ترکیبی از نمونه‌های float و هیستوگرام هستند، فقط از نمونه‌های float به عنوان ورودی استفاده می‌شود که با یک یادداشت سطح اطلاعات (info-level) مشخص می‌شود.

`exp()`
‏`exp(v instant-vector)`: تابع نمایی را برای تمام نمونه‌های float در `v` محاسبه می‌کند. نمونه‌های هیستوگرام بی‌صدا نادیده گرفته می‌شوند. موارد خاص عبارتند از:
```
Exp(+Inf) = +Inf
Exp(NaN) = NaN
```
`floor()`
‏`floor(v instant-vector)`: وکتوری را برمی‌گرداند که حاوی تمام نمونه‌های float در وکتور ورودی است که به نزدیک‌ترین عدد صحیح کوچکتر یا مساوی مقدار اصلی‌شان گرد شده‌اند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.
```
floor(+Inf) = +Inf
floor(±0) = ±0
floor(1.49) = 1.0
floor(1.78) = 1.0
```
`histogram_avg()`
‏`histogram_avg(v instant-vector)`: میانگین حسابی مقادیر مشاهده شده ذخیره شده در هر نمونه هیستوگرام در `v` را برمی‌گرداند. نمونه‌های float نادیده گرفته شده و در وکتور بازگشتی ظاهر نمی‌شوند.

برای محاسبه میانگین مدت زمان درخواست در یک پنجره ۵ دقیقه‌ای از یک هیستوگرام بومی، از `histogram_avg` به صورت زیر استفاده کنید:
```
histogram_avg(rate(http_request_duration_seconds[5m]))
```
که معادل کوئری زیر است:
```
  histogram_sum(rate(http_request_duration_seconds[5m]))
/
  histogram_count(rate(http_request_duration_seconds[5m]))
```
`histogram_count()` و `histogram_sum()`
‏`histogram_count(v instant-vector)`: تعداد مشاهدات ذخیره شده در هر نمونه هیستوگرام در `v` را برمی‌گرداند. نمونه‌های float نادیده گرفته شده و در وکتور بازگشتی ظاهر نمی‌شوند.

به طور مشابه، `histogram_sum(v instant-vector)` مجموع مشاهدات ذخیره شده در هر نمونه هیستوگرام را برمی‌گرداند.

برای محاسبه نرخ مشاهدات (در این مورد معادل "تعداد درخواست‌ها در ثانیه") از یک سری نمونه‌های هیستوگرام، از `histogram_count` به روش زیر استفاده کنید:
```
histogram_count(rate(http_request_duration_seconds[10m]))
```
`histogram_fraction()`
‏`histogram_fraction(lower scalar, upper scalar, b instant-vector)`: کسر تخمینی مشاهدات بین مقادیر پایین و بالای ارائه شده را برای هر هیستوگرام کلاسیک یا بومی موجود در `b` برمی‌گرداند. نمونه‌های float در `b` به عنوان تعداد مشاهدات در هر باکت از یک یا چند هیستوگرام کلاسیک در نظر گرفته می‌شوند، در حالی که نمونه‌های هیستوگرام بومی در `b` هر کدام به طور جداگانه به عنوان یک هیستوگرام مجزا در نظر گرفته می‌شوند. این به همان روشی عمل می‌کند که برای `histogram_quantile()` عمل می‌کند. (برای جزئیات بیشتر به آنجا مراجعه کنید.)

اگر مقادیر پایین و بالای ارائه شده با مرزهای باکت منطبق نباشند، کسر محاسبه شده یک تخمین است که از همان روش درون‌یابی `histogram_quantile()` استفاده می‌کند. (برای جزئیات بیشتر به آنجا مراجعه کنید.) به خصوص با هیستوگرام‌های کلاسیک، به راحتی می‌توان مقادیر پایین یا بالایی را انتخاب کرد که بسیار دور از هر مرز باکت باشند و منجر به حاشیه خطای زیادی شوند. به جای استفاده از `histogram_fraction()` با هیستوگرام‌های کلاسیک، اغلب رویکرد قوی‌تری این است که هنگام محاسبه کسرها مستقیماً روی سری‌های باکت عمل کنید. محاسبه امتیاز Apdex را به عنوان یک مثال معمول ببینید.

به عنوان مثال، عبارت زیر کسر درخواست‌های HTTP در طول یک ساعت گذشته را که ۲۰۰ میلی‌ثانیه یا کمتر طول کشیده‌اند، محاسبه می‌کند:
```
histogram_fraction(0, 0.2, rate(http_request_duration_seconds[1h]))
```
خطای تخمین به وضوح (resolution) هیستوگرام بومی زیربنایی و اینکه مرزهای ارائه شده چقدر با مرزهای باکت در هیستوگرام هم‌تراز هستند، بستگی دارد.

‏`+Inf` و `-Inf` مقادیر مرزی معتبری هستند. به عنوان مثال، اگر هیستوگرام در عبارت بالا شامل مشاهدات منفی باشد (که برای مدت زمان درخواست نباید اینطور باشد)، مرز پایین مناسب برای شامل کردن تمام مشاهدات کمتر یا مساوی ۰.۲، `-Inf` خواهد بود نه ۰.

اینکه مرزهای ارائه شده شامل یا غیرشامل (inclusive or exclusive) باشند، تنها در صورتی مرتبط است که مرزهای ارائه شده دقیقاً با مرزهای باکت در هیستوگرام بومی زیربنایی هم‌تراز باشند. در این حالت، رفتار به تعریف اسکیمای هیستوگرام بستگی دارد. (اسکیماهای نمایی استاندارد معمول همگی دارای مرزهای بالایی شامل و مرزهای پایینی غیرشامل برای مقادیر مثبت و برعکس برای مقادیر منفی هستند.) بدون هم‌ترازی دقیق مرزها، تابع از درون‌یابی برای تخمین کسر استفاده می‌کند. با عدم قطعیت حاصل، اینکه مرزها شامل یا غیرشامل باشند، بی‌ربط می‌شود.

`histogram_quantile()`
‏`histogram_quantile(φ scalar, b instant-vector)`: چندکِ φ-ام (φ بین ۰ و ۱) را از یک هیستوگرام کلاسیک یا یک هیستوگرام بومی محاسبه می‌کند. (برای توضیح دقیق چندک‌های φ-ام و استفاده از نوع متریک هیستوگرام (کلاسیک) به طور کلی، به بخش هیستوگرام‌ها و خلاصه‌ها مراجعه کنید.)

نمونه‌های float در `b` به عنوان تعداد مشاهدات در هر باکت از یک یا چند هیستوگرام کلاسیک در نظر گرفته می‌شوند. هر نمونه float باید دارای یک لیبل `le` باشد که مقدار لیبل، کران بالای شاملِ باکت را نشان می‌دهد. (نمونه‌های float بدون چنین لیبلی بی‌صدا نادیده گرفته می‌شوند.) سایر لیبل‌ها و نام متریک برای شناسایی باکت‌های متعلق به هر هیستوگرام کلاسیک استفاده می‌شوند. نوع متریک هیستوگرام به طور خودکار سری‌های زمانی با پسوند `_bucket` و لیبل‌های مناسب را ارائه می‌دهد.

نمونه‌های هیستوگرام (بومی) در `b` هر کدام به طور جداگانه به عنوان یک هیستوگرام مجزا برای محاسبه چندک از آن در نظر گرفته می‌شوند.

تا زمانی که تداخل نامی ایجاد نشود، `b` ممکن است حاوی ترکیبی از هیستوگرام‌های کلاسیک و بومی باشد.

از تابع `rate()` برای مشخص کردن پنجره زمانی برای محاسبه چندک استفاده کنید.

مثال: یک متریک هیستوگرام `http_request_duration_seconds` نامیده می‌شود (و بنابراین نام متریک برای باکت‌های یک هیستوگرام کلاسیک `http_request_duration_seconds_bucket` است). برای محاسبه صدک ۹۰ام مدت زمان درخواست در ۱۰ دقیقه گذشته، در صورتی که `http_request_duration_seconds` یک هیستوگرام کلاسیک باشد، از عبارت زیر استفاده کنید:
```
histogram_quantile(0.9, rate(http_request_duration_seconds_bucket[10m]))
```
برای یک هیستوگرام بومی، به جای آن از عبارت زیر استفاده کنید:
```
histogram_quantile(0.9, rate(http_request_duration_seconds[10m]))
```
چندک برای هر ترکیب لیبل در `http_request_duration_seconds` محاسبه می‌شود. برای تجمیع (aggregate)، از تجمیع‌کننده `sum()` در اطراف تابع `rate()` استفاده کنید. از آنجایی که لیبل `le` برای `histogram_quantile()` جهت مدیریت هیستوگرام‌های کلاسیک مورد نیاز است، باید در عبارت `by` گنجانده شود. عبارت زیر صدک ۹۰ام را بر اساس `job` برای هیستوگرام‌های کلاسیک تجمیع می‌کند:
```
histogram_quantile(0.9, sum by (job, le) (rate(http_request_duration_seconds_bucket[10m])))
```
هنگام تجمیع هیستوگرام‌های بومی، عبارت ساده‌تر می‌شود:
```
histogram_quantile(0.9, sum by (job) (rate(http_request_duration_seconds[10m])))
```
برای تجمیع تمام هیستوگرام‌های کلاسیک، فقط لیبل `le` را مشخص کنید:
```
histogram_quantile(0.9, sum by (le) (rate(http_request_duration_seconds_bucket[10m])))
```
با هیستوگرام‌های بومی، تجمیع همه چیز طبق معمول بدون هیچ عبارت `by` کار می‌کند:
```
histogram_quantile(0.9, sum(rate(http_request_duration_seconds[10m])))
```
در حالت (رایج) که مقدار چندک با مرز باکت منطبق نباشد، تابع `histogram_quantile()` مقدار چندک را درون باکتی که مقدار چندک در آن قرار می‌گیرد، درون‌یابی می‌کند. برای هیستوگرام‌های کلاسیک، برای هیستوگرام‌های بومی با مرزهای باکت سفارشی، و برای باکت صفرِ سایر هیستوگرام‌های بومی، توزیع یکنواخت مشاهدات درون باکت را فرض می‌کند (که به آن درون‌یابی خطی نیز گفته می‌شود). برای باکت‌های غیر صفرِ هیستوگرام‌های بومی با اسکیمای باکت‌بندی نمایی استاندارد، درون‌یابی با این فرض انجام می‌شود که نمونه‌های درون باکت به گونه‌ای توزیع شده‌اند که باکت‌ها را در یک هیستوگرام فرضی با وضوح بالاتر به طور یکنواخت پر می‌کنند. (این نیز درون‌یابی نمایی نامیده می‌شود. برای جزئیات بیشتر به مشخصات هیستوگرام بومی مراجعه کنید.)

اگر `b` صفر مشاهده داشته باشد، `NaN` برگردانده می‌شود. برای `φ < 0`، `-Inf` برگردانده می‌شود. برای `φ > 1`، `+Inf` برگردانده می‌شود. برای `φ = NaN`، `NaN` برگردانده می‌شود.

موارد خاص برای هیستوگرام‌های کلاسیک:
*   اگر `b` کمتر از دو باکت داشته باشد، `NaN` برگردانده می‌شود.
*   بالاترین باکت باید دارای کران بالای `+Inf` باشد. (در غیر این صورت، `NaN` برگردانده می‌شود.)
*   اگر یک چندک در بالاترین باکت قرار داشته باشد، کران بالای دومین باکتِ بالاتر برگردانده می‌شود.
*   حد پایین پایین‌ترین باکت، در صورتی که کران بالای آن باکت بزرگتر از ۰ باشد، ۰ فرض می‌شود. در این حالت، درون‌یابی خطی معمول درون آن باکت اعمال می‌شود. در غیر این صورت، کران بالای پایین‌ترین باکت برای چندک‌هایی که در پایین‌ترین باکت قرار دارند، برگردانده می‌شود.

موارد خاص برای هیستوگرام‌های بومی (مربوط به درون‌یابی دقیقی که در باکت صفر اتفاق می‌افتد):
*   یک باکت صفر با عرض محدود، در صورتی که هیستوگرام مشاهداتی در باکت‌های مثبت داشته باشد اما هیچ مشاهده‌ای در باکت‌های منفی نداشته باشد، فرض می‌شود هیچ مشاهده منفی ندارد.
*   یک باکت صفر با عرض محدود، در صورتی که هیستوگرام مشاهداتی در باکت‌های منفی داشته باشد اما هیچ مشاهده‌ای در باکت‌های مثبت نداشته باشد، فرض می‌شود هیچ مشاهده مثبتی ندارد.

می‌توانید از `histogram_quantile(0, v instant-vector)` برای بدست آوردن مقدار حداقل تخمینی ذخیره شده در یک هیستوگرام استفاده کنید.

می‌توانید از `histogram_quantile(1, v instant-vector)` برای بدست آوردن مقدار حداکثر تخمینی ذخیره شده در یک هیستوگرام استفاده کنید.

باکت‌های هیستوگرام‌های کلاسیک تجمعی هستند. بنابراین، موارد زیر همیشه باید صادق باشند:
*   تعداد در باکت‌ها به طور یکنواخت صعودی است (اکیداً غیر نزولی).
*   فقدان مشاهدات بین حدود بالایی دو باکت متوالی منجر به تعداد مساوی در آن دو باکت می‌شود.

با این حال، مسائل مربوط به دقت ممیز شناور (مانند اختلافات جزئی ناشی از محاسبه باکت‌ها با `sum(rate(...))`) یا داده‌های نامعتبر ممکن است این فرضیات را نقض کنند. در این حالت، `histogram_quantile` قادر به بازگرداندن نتایج معنی‌دار نخواهد بود. برای کاهش این مشکل، `histogram_quantile` فرض می‌کند که تفاوت‌های نسبی بسیار کوچک بین باکت‌های متوالی به دلیل خطاهای دقت ممیز شناور رخ می‌دهند و آنها را نادیده می‌گیرد. (آستانه نادیده گرفتن تفاوت بین دو باکت، یک تریلیونیم (1e-12) از مجموع هر دو باکت است.) علاوه بر این، اگر حتی پس از این تنظیم، تعداد باکت‌های غیریکنواخت وجود داشته باشد، آنها به مقدار باکت‌های قبلی افزایش می‌یابند تا یکنواختی اعمال شود. مورد دوم شاهدی بر وجود مشکل واقعی در داده‌های ورودی است و بنابراین با یک یادداشت سطح اطلاعات (info-level) با متن «ورودی به histogram_quantile برای یکنواختی نیاز به اصلاح داشت» مشخص می‌شود. اگر با این یادداشت مواجه شدید، باید منبع داده‌های نامعتبر را پیدا و حذف کنید.

`histogram_stddev()` و `histogram_stdvar()`
‏`histogram_stddev(v instant-vector)`: انحراف معیار تخمینی مشاهدات را برای هر نمونه هیستوگرام در `v` برمی‌گرداند. برای این تخمین، فرض می‌شود تمام مشاهدات در یک باکت مقدار میانگین مرزهای باکت را دارند. برای باکت صفر و برای باکت‌های با مرزهای سفارشی، از میانگین حسابی استفاده می‌شود. برای باکت‌های نمایی معمول، از میانگین هندسی استفاده می‌شود. نمونه‌های float نادیده گرفته شده و در وکتور بازگشتی ظاهر نمی‌شوند.

به طور مشابه، `histogram_stdvar(v instant-vector)` واریانس تخمینی مشاهدات را برای هر نمونه هیستوگرام در `v` برمی‌گرداند.

`hour()`
‏`hour(v=vector(time()) instant-vector)`: نمونه‌های float در `v` را به عنوان مُهرهای زمانی (تعداد ثانیه‌ها از اول ژانویه ۱۹۷۰ UTC) تفسیر کرده و ساعتِ روز (در UTC) را برای هر یک از آن مُهرهای زمانی برمی‌گرداند. مقادیر بازگشتی بین ۰ تا ۲۳ هستند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`idelta()`
‏`idelta(v range-vector)`: تفاوت بین دو نمونه آخر در وکتور بازه‌ای `v` را محاسبه کرده و یک وکتور لحظه‌ای با دلتاهای داده شده و لیبل‌های معادل برمی‌گرداند. هر دو نمونه باید یا نمونه float باشند یا نمونه هیستوگرام. عناصری در `v` که یکی از دو نمونه آخر آنها نمونه float و دیگری نمونه هیستوگرام باشد، از وکتور نتیجه حذف شده و با یک یادداشت سطح هشدار (warn-level) مشخص می‌شوند.

`idelta` فقط باید با گِیج‌ها (هم برای float و هم برای هیستوگرام) استفاده شود.

`increase()`
‏`increase(v range-vector)`: افزایش در سری زمانی در وکتور بازه‌ای را محاسبه می‌کند. وقفه‌ها در یکنواختی (مانند ریست شدن شمارنده‌ها به دلیل ری‌استارت شدن هدف‌ها) به طور خودکار تنظیم می‌شوند. افزایش برای پوشش کامل بازه زمانی مشخص شده در انتخابگر وکتور بازه‌ای برونیابی می‌شود، بنابراین حتی اگر یک شمارنده فقط با افزایش‌های صحیح افزایش یابد، ممکن است نتیجه‌ای غیرصحیح بدست آید.

مثال زیر تعداد درخواست‌های HTTP را که در ۵ دقیقه گذشته اندازه‌گیری شده‌اند، به ازای هر سری زمانی در وکتور بازه‌ای برمی‌گرداند:
```
increase(http_requests_total{job="api-server"}[5m])
```
‏`increase` بر روی نمونه‌های هیستوگرام با محاسبه یک هیستوگرام جدید عمل می‌کند که در آن هر جزء (مجموع و تعداد مشاهدات، باکت‌ها) افزایش بین جزء مربوطه در اولین و آخرین هیستوگرام بومی در `v` است. با این حال، هر عنصری در `v` که ترکیبی از نمونه‌های float و نمونه‌های هیستوگرام در بازه داشته باشد، از وکتور نتیجه حذف شده و با یک یادداشت سطح هشدار (warn-level) مشخص می‌شود.

‏`increase` فقط باید با شمارنده‌ها (هم برای float و هم برای هیستوگرام) استفاده شود. این یک «شکر نحوی» (syntactic sugar) برای `rate(v)` ضربدر تعداد ثانیه‌ها در پنجره زمانی مشخص شده است و باید در درجه اول برای خوانایی انسان استفاده شود. از `rate` در قوانین ضبط (recording rules) استفاده کنید تا افزایش‌ها به طور مداوم بر اساس ثانیه ردیابی شوند.

`info()`
تابع `info` یک آزمایش برای بهبود تجربه کاربری (UX) در مورد گنجاندن لیبل‌ها از متریک‌های `info` است. رفتار این تابع ممکن است در نسخه‌های آینده Prometheus تغییر کند، از جمله حذف آن از PromQL. تابع `info` باید از طریق فلگ ویژگی `--enable-feature=promql-experimental-functions` فعال شود.

‏`info(v instant-vector, [data-label-selector instant-vector])`: برای هر سری زمانی در `v`، تمام سری‌های `info` با لیبل‌های شناسایی منطبق را پیدا می‌کند (در ادامه بیشتر در این مورد توضیح داده خواهد شد)، و اجتماع لیبل‌های داده‌ای (یعنی غیر شناسایی) آنها را به سری زمانی اضافه می‌کند. آرگومان دوم `data-label-selector` اختیاری است. این یک وکتور لحظه‌ای واقعی نیست، اما از زیرمجموعه‌ای از نحو آن استفاده می‌کند. باید با آکولاد شروع و تمام شود (`{ ... }`) و فقط می‌تواند شامل تطبیق‌دهنده‌های لیبل باشد. تطبیق‌دهنده‌های لیبل برای محدود کردن اینکه کدام سری‌های `info` در نظر گرفته شوند و کدام لیبل‌های داده به `v` اضافه شوند، استفاده می‌شوند.

لیبل‌های شناسایی (identifying labels) یک سری `info` زیرمجموعه‌ای از لیبل‌ها هستند که به طور منحصربه‌فرد سری `info` را مشخص می‌کنند. لیبل‌های باقیمانده لیبل‌های داده (data labels) (همچنین غیر شناسایی نامیده می‌شوند) در نظر گرفته می‌شوند. (توجه داشته باشید که مفهوم هویت سری زمانی در Prometheus همیشه شامل تمام لیبل‌ها می‌شود. به خاطر تابع `info`، ما هویت سری `info` را «منطقاً» به روشی متفاوت از دیدگاه مرسوم Prometheus تعریف می‌کنیم.) لیبل‌های شناسایی یک سری `info` برای پیوستن (join) آن به سری‌های معمولی (غیر `info`) استفاده می‌شوند، یعنی آن سری‌هایی که لیبل‌های مشابه لیبل‌های شناسایی سری `info` را دارند. لیبل‌های داده، که آنهایی هستند که توسط تابع `info` به سری‌های معمولی اضافه می‌شوند، به طور موثر جفت‌های کلید-مقدار فراداده (metadata) را رمزگذاری می‌کنند. (این بدان معناست که تغییر در لیبل‌های داده در دیدگاه مرسوم Prometheus به معنای پایان یک سری `info` و آغاز یک سری `info` جدید است، در حالی که دیدگاه «منطقی» تابع `info` این است که همان سری `info` به وجود خود ادامه می‌دهد، فقط با «داده‌های» متفاوت.)

رویکرد مرسوم افزودن لیبل‌های داده گاهی اوقات «کوئری پیوندی» (join query) نامیده می‌شود، همانطور که در مثال زیر نشان داده شده است:
```
  rate(http_server_request_duration_seconds_count[2m])
* on (job, instance) group_left (k8s_cluster_name)
  target_info
```
هسته کوئری عبارت `rate(http_server_request_duration_seconds_count[2m])` است. اما برای افزودن لیبل‌های داده از یک متریک `info`، کاربر باید از نحو پیچیده (و نه چندان واضح) برای مشخص کردن اینکه از کدام متریک `info` استفاده کند (`target_info`)، لیبل‌های شناسایی چه هستند (`on (job, instance)`)، و کدام لیبل‌های داده اضافه شوند (`group_left (k8s_cluster_name)`) استفاده کند.

این کوئری نه تنها پرمطلب و نوشتن آن دشوار است، بلکه ممکن است با «بحران هویت» نیز مواجه شود: اگر هر یک از لیبل‌های داده `target_info` تغییر کند، Prometheus آن را به عنوان تغییر سری می‌بیند (همانطور که در بالا اشاره شد، Prometheus هیچ مفهوم بومی از لیبل‌های غیر شناسایی ندارد). اگر سری `target_info` قدیمی به درستی به عنوان منسوخ (stale) علامت‌گذاری نشود (که می‌تواند با برخی مسیرهای دریافت داده اتفاق بیفتد)، کوئری بالا تا ۵ دقیقه (دلتا بازبینی یا lookback delta) با شکست مواجه خواهد شد زیرا با هر دو نسخه قدیمی و جدید `target_info` یک تطابق متناقض پیدا می‌کند.

تابع `info` نه تنها این تضاد را به نفع سری جدیدتر حل می‌کند، بلکه نحو را نیز ساده می‌کند زیرا از سری‌های `info` موجود و اینکه لیبل‌های شناسایی آنها چیست، اطلاع دارد. کوئری مثال با تابع `info` به این صورت است:
```
info(
  rate(http_server_request_duration_seconds_count[2m]),
  {k8s_cluster_name=~".+"}
)
```
حالت رایج افزودن تمام لیبل‌های داده را می‌توان با حذف کامل آرگومان دوم تابع `info` به دست آورد، که مثال را حتی ساده‌تر می‌کند:
```
info(rate(http_server_request_duration_seconds_count[2m]))
```
در حالی که `info` معمولاً به طور خودکار تمام سری‌های `info` منطبق را پیدا می‌کند، می‌توان آنها را با ارائه یک تطبیق‌دهنده لیبل `__name__` محدود کرد، به عنوان مثال `{__name__="target_info"}`.

محدودیت‌ها
در تکرار فعلی، `info` به طور پیش‌فرض فقط سری‌های `info` با نام `target_info` را در نظر می‌گیرد. همچنین فرض می‌کند که لیبل‌های شناسایی سری `info`، `instance` و `job` هستند. با این حال، `info` از نام‌های دیگر سری `info` از طریق تطبیق‌دهنده‌های لیبل `__name__` پشتیبانی می‌کند. به عنوان مثال، می‌توان به صراحت گفت که هم `target_info` و هم `build_info` را به صورت زیر در نظر بگیرد: `{__name__=~"(target|build)_info"}`. با این حال، لیبل‌های شناسایی همیشه باید `instance` و `job` باشند.

این محدودیت‌ها تا حدی هدف تابع `info` را تضعیف می‌کنند. در مرحله فعلی، این یک آزمایش برای پی بردن به میزان مفید بودن این رویکرد در عمل است. نسخه نهایی تابع `info` در واقع تمام سری‌های `info` منطبق را با لیبل‌های شناسایی مناسب آنها در نظر خواهد گرفت.

`irate()`
‏`irate(v range-vector)`: نرخ لحظه‌ای افزایش بر حسب ثانیه سری زمانی در وکتور بازه‌ای را محاسبه می‌کند. این بر اساس دو نقطه داده آخر است. وقفه‌ها در یکنواختی (مانند ریست شدن شمارنده‌ها به دلیل ری‌استارت شدن هدف‌ها) به طور خودکار تنظیم می‌شوند. هر دو نمونه باید یا نمونه float باشند یا نمونه هیستوگرام. عناصری در `v` که یکی از دو نمونه آخر آنها نمونه float و دیگری نمونه هیستوگرام باشد، از وکتور نتیجه حذف شده و با یک یادداشت سطح هشدار (warn-level) مشخص می‌شوند.

‏`irate` فقط باید با شمارنده‌ها (هم برای float و هم برای هیستوگرام) استفاده شود.

مثال زیر نرخ بر حسب ثانیه درخواست‌های HTTP را با نگاه به ۵ دقیقه قبل برای دو نقطه داده اخیر، به ازای هر سری زمانی در وکتور بازه‌ای برمی‌گرداند:
```
irate(http_requests_total{job="api-server"}[5m])
```
‏`irate` فقط باید هنگام رسم نمودار شمارنده‌های فرار و سریع‌التغییر استفاده شود. از `rate` برای هشدارها و شمارنده‌های کند تغییر استفاده کنید، زیرا تغییرات مختصر در نرخ می‌تواند عبارت `FOR` را ریست کند و نمودارهایی که کاملاً از جهش‌های نادر تشکیل شده‌اند، خواندنشان دشوار است.

توجه داشته باشید که هنگام ترکیب `irate()` با یک عملگر تجمیع (مثلاً `sum()`) یا تابعی که در طول زمان تجمیع می‌کند (هر تابعی که به `_over_time` ختم می‌شود)، همیشه ابتدا `irate()` را بگیرید، سپس تجمیع کنید. در غیر این صورت `irate()` نمی‌تواند ریست شدن شمارنده‌ها را هنگام ری‌استارت شدن هدف شما تشخیص دهد.

`label_join()`
‏`label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)`: برای هر سری زمانی در `v`، تمام مقادیر تمام `src_labels` را با استفاده از `separator` به هم می‌پیوندد و سری زمانی را با لیبل `dst_label` حاوی مقدار پیوسته برمی‌گرداند. هر تعداد `src_labels` می‌تواند در این تابع وجود داشته باشد.

‏`label_join` بر روی نمونه‌های float و هیستوگرام به یک شکل عمل می‌کند.

این مثال یک وکتور را برمی‌گرداند که هر سری زمانی آن دارای یک لیبل `foo` با مقدار `a,b,c` است که به آن اضافه شده است:
```
label_join(up{job="api-server",src1="a",src2="b",src3="c"}, "foo", ",", "src1", "src2", "src3")
```
`label_replace()`
‏`label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)`: برای هر سری زمانی در `v`، عبارت منظم `regex` را با مقدار لیبل `src_label` مطابقت می‌دهد. اگر مطابقت داشته باشد، مقدار لیبل `dst_label` در سری زمانی بازگشتی، بسط `replacement` به همراه لیبل‌های اصلی در ورودی خواهد بود. به گروه‌های کپچر شده در عبارت منظم می‌توان با `$1`، `$2` و غیره ارجاع داد. به گروه‌های کپچر شده نام‌گذاری شده در عبارت منظم می‌توان با `$name` (که `name` نام گروه کپچر شده است) ارجاع داد. اگر عبارت منظم مطابقت نداشته باشد، سری زمانی بدون تغییر برگردانده می‌شود.

`label_replace` بر روی نمونه‌های float و هیستوگرام به یک شکل عمل می‌کند.

این مثال سری‌های زمانی با مقادیر `a:c` در لیبل `service` و `a` در لیبل `foo` را برمی‌گرداند:
```
label_replace(up{job="api-server",service="a:c"}, "foo", "$1", "service", "(.*):.*")
```
این مثال دوم همان تأثیر مثال اول را دارد و استفاده از گروه‌های کپچر شده نام‌گذاری شده را نشان می‌دهد:
```
label_replace(up{job="api-server",service="a:c"}, "foo", "$name", "service", "(?P<name>.*):(?P<version>.*)")
```
`ln()`
‏`ln(v instant-vector)`: لگاریتم طبیعی را برای تمام نمونه‌های float در `v` محاسبه می‌کند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند. موارد خاص عبارتند از:
```
ln(+Inf) = +Inf
ln(0) = -Inf
ln(x < 0) = NaN
ln(NaN) = NaN
```
`log2()`
‏`log2(v instant-vector)`: لگاریتم دودویی را برای تمام نمونه‌های float در `v` محاسبه می‌کند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند. موارد خاص معادل موارد موجود در `ln` هستند.

`log10()`
`log10(v instant-vector)`: لگاریتم اعشاری را برای تمام نمونه‌های float در `v` محاسبه می‌کند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند. موارد خاص معادل موارد موجود در `ln` هستند.

`minute()`
‏`minute(v=vector(time()) instant-vector)`: نمونه‌های float در `v` را به عنوان مُهرهای زمانی (تعداد ثانیه‌ها از اول ژانویه ۱۹۷۰ UTC) تفسیر کرده و دقیقه از ساعت (در UTC) را برای هر یک از آن مُهرهای زمانی برمی‌گرداند. مقادیر بازگشتی بین ۰ تا ۵۹ هستند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`month()`
‏`month(v=vector(time()) instant-vector)`: نمونه‌های float در `v` را به عنوان مُهرهای زمانی (تعداد ثانیه‌ها از اول ژانویه ۱۹۷۰ UTC) تفسیر کرده و ماهِ سال (در UTC) را برای هر یک از آن مُهرهای زمانی برمی‌گرداند. مقادیر بازگشتی بین ۱ تا ۱۲ هستند، که ۱ به معنای ژانویه و الی آخر است. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`predict_linear()`
‏`predict_linear(v range-vector, t scalar)`: مقدار سری زمانی را `t` ثانیه از اکنون، بر اساس وکتور بازه‌ای `v`، با استفاده از رگرسیون خطی ساده پیش‌بینی می‌کند. وکتور بازه‌ای باید حداقل دو نمونه float برای انجام محاسبه داشته باشد. هنگامی که `+Inf` یا `-Inf` در وکتور بازه‌ای یافت شود، مقدار پیش‌بینی شده `NaN` خواهد بود.

‏`predict_linear` فقط باید با گِیج‌ها استفاده شود و فقط برای نمونه‌های float کار می‌کند. عناصری در وکتور بازه‌ای که فقط حاوی نمونه‌های هیستوگرام هستند، به طور کامل نادیده گرفته می‌شوند. برای عناصری که حاوی ترکیبی از نمونه‌های float و هیستوگرام هستند، فقط از نمونه‌های float به عنوان ورودی استفاده می‌شود که با یک یادداشت سطح اطلاعات (info-level) مشخص می‌شود.

`rate()`
‏`rate(v range-vector)`: میانگین نرخ افزایش بر حسب ثانیه سری زمانی در وکتور بازه‌ای را محاسبه می‌کند. وقفه‌ها در یکنواختی (مانند ریست شدن شمارنده‌ها به دلیل ری‌استارت شدن هدف‌ها) به طور خودکار تنظیم می‌شوند. همچنین، محاسبه به انتهای بازه زمانی برونیابی می‌شود، که امکان از دست رفتن نمونه‌برداری‌ها (scrapes) یا عدم تطابق کامل چرخه‌های نمونه‌برداری با دوره زمانی بازه را فراهم می‌کند.

مثال زیر میانگین نرخ درخواست‌های HTTP بر حسب ثانیه را در ۵ دقیقه گذشته، به ازای هر سری زمانی در وکتور بازه‌ای برمی‌گرداند:
```
rate(http_requests_total{job="api-server"}[5m])
```
‏`rate` بر روی هیستوگرام‌های بومی با محاسبه یک هیستوگرام جدید عمل می‌کند که در آن هر جزء (مجموع و تعداد مشاهدات، باکت‌ها) نرخ افزایش بین جزء مربوطه در اولین و آخرین هیستوگرام بومی در `v` است. با این حال، هر عنصری در `v` که ترکیبی از نمونه‌های float و نمونه‌های هیستوگرام بومی در بازه داشته باشد، از وکتور نتیجه حذف شده و با یک یادداشت سطح هشدار (warn-level) مشخص می‌شود.

‏`rate` فقط باید با شمارنده‌ها (هم برای float و هم برای هیستوگرام) استفاده شود. برای هشدار دادن و برای رسم نمودار شمارنده‌های کند تغییر بهترین گزینه است.

توجه داشته باشید که هنگام ترکیب `rate()` با یک عملگر تجمیع (مثلاً `sum()`) یا تابعی که در طول زمان تجمیع می‌کند (هر تابعی که به `_over_time` ختم می‌شود)، همیشه ابتدا `rate()` را بگیرید، سپس تجمیع کنید. در غیر این صورت `rate()` نمی‌تواند ریست شدن شمارنده‌ها را هنگام ری‌استارت شدن هدف شما تشخیص دهد.

`resets()`
‏`resets(v range-vector)`: برای هر سری زمانی ورودی، تعداد ریست‌های شمارنده در بازه زمانی ارائه شده را به عنوان یک وکتور لحظه‌ای برمی‌گرداند. هرگونه کاهش در مقدار بین دو نمونه float متوالی به عنوان ریست شمارنده تفسیر می‌شود. ریست در یک هیستوگرام بومی به روش پیچیده‌تری تشخیص داده می‌شود: هرگونه کاهش در هر باکت، از جمله باکت صفر، یا در تعداد مشاهدات، یک ریست شمارنده محسوب می‌شود، اما همچنین ناپدید شدن هر باکت قبلاً پر شده، کاهش عرض باکت صفر، یا هرگونه تغییر اسکیما که کاهش وضوح سازگار نباشد نیز ریست محسوب می‌شود.

‏`resets` فقط باید با شمارنده‌ها (هم برای float و هم برای هیستوگرام) استفاده شود.‏

یک نمونه float و به دنبال آن یک نمونه هیستوگرام، یا برعکس، به عنوان ریست محسوب می‌شود. یک نمونه هیستوگرام شمارنده و به دنبال آن یک نمونه هیستوگرام گِیج، یا برعکس، نیز به عنوان ریست محسوب می‌شود (اما توجه داشته باشید که `resets` نباید در وهله اول روی گِیج‌ها استفاده شود، به بالا مراجعه کنید).

`round()`
‏`round(v instant-vector, to_nearest=1 scalar)`: مقادیر نمونه تمام عناصر در `v` را به نزدیک‌ترین عدد صحیح گرد می‌کند. در موارد مساوی (ties)، به سمت بالا گرد می‌شود. آرگومان اختیاری `to_nearest` امکان مشخص کردن نزدیک‌ترین مضربی را که مقادیر نمونه باید به آن گرد شوند، فراهم می‌کند. این مضرب همچنین می‌تواند یک کسر باشد. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`scalar()`
‏`scalar(v instant-vector)`: با فرض یک وکتور ورودی که فقط یک عنصر با نمونه float دارد، مقدار نمونه آن نمونه float را به عنوان یک اسکالر برمی‌گرداند. اگر وکتور ورودی دقیقاً یک عنصر با نمونه float نداشته باشد، `scalar` مقدار `NaN` را برمی‌گرداند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`sgn()`
‏`sgn(v instant-vector)`: وکتوری را برمی‌گرداند که تمام مقادیر نمونه float آن به علامتشان تبدیل شده‌اند، به این صورت تعریف می‌شود: ۱ اگر v مثبت باشد، -۱ اگر v منفی باشد و ۰ اگر v مساوی صفر باشد. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`sort()`
‏`sort(v ‏instant-vector)`: عناصر وکتور را بر اساس مقادیر نمونه float آنها، به ترتیب صعودی مرتب کرده و برمی‌گرداند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

لطفاً توجه داشته باشید که `sort` فقط بر نتایج کوئری‌های لحظه‌ای تأثیر می‌گذارد، زیرا نتایج کوئری بازه‌ای همیشه ترتیب خروجی ثابتی دارند.

`sort_desc()`
مانند `sort`، اما به ترتیب نزولی مرتب می‌کند.

`sort_by_label()`
این تابع باید از طریق فلگ ویژگی `--enable-feature=promql-experimental-functions` فعال شود.

‏`sort_by_label(v instant-vector, label string, ...)`: عناصر وکتور را بر اساس مقادیر لیبل‌های داده شده به ترتیب صعودی مرتب کرده و برمی‌گرداند. در صورتی که این مقادیر لیبل مساوی باشند، عناصر بر اساس مجموعه کامل لیبل‌هایشان مرتب می‌شوند. `sort_by_label` بر روی نمونه‌های float و هیستوگرام به یک شکل عمل می‌کند.

لطفاً توجه داشته باشید که `sort_by_label` فقط بر نتایج کوئری‌های لحظه‌ای تأثیر می‌گذارد، زیرا نتایج کوئری بازه‌ای همیشه ترتیب خروجی ثابتی دارند.

‏`sort_by_label` از ترتیب مرتب‌سازی طبیعی (natural sort order) استفاده می‌کند.

`sort_by_label_desc()`
این تابع باید از طریق فلگ ویژگی `--enable-feature=promql-experimental-functions` فعال شود.

مانند `sort_by_label`، اما به ترتیب نزولی مرتب می‌کند.

`sqrt()`
‏`sqrt(v instant-vector)`: ریشه دوم تمام نمونه‌های float در `v` را محاسبه می‌کند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`time()`
‏`time()`: تعداد ثانیه‌ها از اول ژانویه ۱۹۷۰ UTC را برمی‌گرداند. توجه داشته باشید که این تابع در واقع زمان فعلی را برنمی‌گرداند، بلکه زمانی را برمی‌گرداند که عبارت باید در آن ارزیابی شود.

`timestamp()`
‏`timestamp(v instant-vector)`: مُهر زمانی هر یک از نمونه‌های وکتور داده شده را به عنوان تعداد ثانیه‌ها از اول ژانویه ۱۹۷۰ UTC برمی‌گرداند. این تابع بر روی نمونه‌های float و هیستوگرام به یک شکل عمل می‌کند.

`vector()`
‏`vector(s scalar)`: اسکالر `s` را به یک نمونه float تبدیل کرده و آن را به عنوان یک وکتور لحظه‌ای تک‌عنصری بدون لیبل برمی‌گرداند.

`year()`
‏`year(v=vector(time()) instant-vector)`: سال را برای هر یک از زمان‌های داده شده در UTC برمی‌گرداند. نمونه‌های هیستوگرام در وکتور ورودی بی‌صدا نادیده گرفته می‌شوند.

`<aggregation>_over_time()`
توابع زیر امکان تجمیع هر سری از یک وکتور بازه‌ای داده شده در طول زمان را فراهم کرده و یک وکتور لحظه‌ای با نتایج تجمیع به ازای هر سری برمی‌گردانند:

* ‏  `avg_over_time(range-vector)`: مقدار میانگین تمام نمونه‌های float یا هیستوگرام در بازه مشخص شده (جزئیات زیر را ببینید).
* ‏  `min_over_time(range-vector)`: حداقل مقدار تمام نمونه‌های float در بازه مشخص شده.
* ‏  `max_over_time(range-vector)`: حداکثر مقدار تمام نمونه‌های float در بازه مشخص شده.
* ‏  `sum_over_time(range-vector)`: مجموع تمام نمونه‌های float یا هیستوگرام در بازه مشخص شده (جزئیات زیر را ببینید).
* ‏  `count_over_time(range-vector)`: تعداد تمام نمونه‌ها در بازه مشخص شده.
* ‏  `quantile_over_time(scalar, range-vector)`: چندکِ φ-ام (φ بین ۰ و ۱) تمام نمونه‌های float در بازه مشخص شده.
* ‏  `stddev_over_time(range-vector)`: انحراف معیار جامعه آماری تمام نمونه‌های float در بازه مشخص شده.
* ‏  `stdvar_over_time(range-vector)`: واریانس جامعه آماری تمام نمونه‌های float در بازه مشخص شده.
*‏   `last_over_time(range-vector)`: جدیدترین نمونه در بازه مشخص شده.
*   `present_over_time(range-vector)`: مقدار ۱ برای هر سری در بازه مشخص شده.

اگر فلگ ویژگی `--enable-feature=promql-experimental-functions` تنظیم شده باشد، توابع اضافی زیر در دسترس هستند:
* ‏  `mad_over_time(range-vector)`: انحراف مطلق میانه تمام نمونه‌های float در بازه مشخص شده.

توجه داشته باشید که تمام مقادیر در بازه مشخص شده وزن یکسانی در تجمیع دارند، حتی اگر مقادیر به طور مساوی در طول بازه توزیع نشده باشند.

این توابع بر روی هیستوگرام‌ها به روش زیر عمل می‌کنند:
* ‏  `count_over_time`، `last_over_time`، و `present_over_time()` بر روی نمونه‌های float و هیستوگرام به یک شکل عمل می‌کنند.
* ‏  `avg_over_time()` و `sum_over_time()` بر روی نمونه‌های هیستوگرام به روشی عمل می‌کنند که با عملگرهای تجمیع مربوطه مطابقت دارد. اگر یک سری حاوی ترکیبی از نمونه‌های float و نمونه‌های هیستوگرام در بازه باشد، نتیجه مربوطه به طور کامل از وکتور خروجی حذف می‌شود. چنین حذفی با یک یادداشت سطح هشدار (warn-level) مشخص می‌شود.
*   تمام توابع دیگر نمونه‌های هیستوگرام را به روش زیر نادیده می‌گیرند: بازه‌های ورودی که فقط حاوی نمونه‌های هیستوگرام هستند، بی‌صدا از خروجی حذف می‌شوند. برای بازه‌هایی با ترکیبی از نمونه‌های هیستوگرام و float، فقط نمونه‌های float پردازش می‌شوند و حذف نمونه‌های هیستوگرام با یک یادداشت سطح اطلاعات (info-level) مشخص می‌شود.

توابع مثلثاتی
توابع مثلثاتی بر حسب رادیان کار می‌کنند. آنها نمونه‌های هیستوگرام را در وکتور ورودی نادیده می‌گیرند.

* ‏  `acos(v instant-vector)`: آرک‌کسینوس تمام نمونه‌های float در `v` را محاسبه می‌کند (موارد خاص).
* ‏  `acosh(v instant-vector)`: کسینوس هیپربولیک معکوس تمام نمونه‌های float در `v` را محاسبه می‌کند (موارد خاص).
*‏   `asin(v instant-vector)`: آرک‌سینوس تمام نمونه‌های float در `v` را محاسبه می‌کند (موارد خاص).
* ‏  `asinh(v instant-vector)`: سینوس هیپربولیک معکوس تمام نمونه‌های float در `v` را محاسبه می‌کند (موارد خاص).
*‏   `atan(v instant-vector)`: آرک‌تانژانت تمام نمونه‌های float در `v` را محاسبه می‌کند (موارد خاص).
* ‏  `atanh(v instant-vector)`: تانژانت هیپربولیک معکوس تمام نمونه‌های float در `v` را محاسبه می‌کند (موارد خاص).
* ‏  `cos(v instant-vector)`: کسینوس تمام نمونه‌های float در `v` را محاسبه می‌کند (موارد خاص).
* ‏  `cosh(v instant-vector)`: کسینوس هیپربولیک تمام نمونه‌های float در `v` را محاسبه می‌کند (موارد خاص).
* ‏  `sin(v instant-vector)`: سینوس تمام نمونه‌های float در `v` را محاسبه می‌کند (موارد خاص).
* ‏  `sinh(v instant-vector)`: سینوس هیپربولیک تمام نمونه‌های float در `v` را محاسبه می‌کند (موارد خاص).
* ‏  `tan(v instant-vector)`: تانژانت تمام نمونه‌های float در `v` را محاسبه می‌کند (موارد خاص).
* ‏  `tanh(v instant-vector)`: تانژانت هیپربولیک تمام نمونه‌های float در `v` را محاسبه می‌کند (موارد خاص).

موارد زیر برای تبدیل بین درجه و رادیان مفید هستند:
* ‏  `deg(v instant-vector)`: رادیان را به درجه برای تمام نمونه‌های float در `v` تبدیل می‌کند.
* ‏  `pi()`: عدد پی را برمی‌گرداند.
* ‏  `rad(v instant-vector)`: درجه را به رادیان برای تمام نمونه‌های float در `v` تبدیل می‌کند.