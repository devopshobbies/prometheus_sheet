
# تابع `abs()` در Prometheus

تابع `abs()` یکی از توابع ریاضی در Prometheus است که برای محاسبه **مقدار مطلق** (Absolute Value) یک متریک استفاده می‌شود.

## کاربرد تابع `abs()`

تابع `abs()` مقدار مطلق یک سری زمانی یا یک بردار را محاسبه می‌کند، یعنی:
- اگر مقدار مثبت باشد، بدون تغییر باقی می‌ماند
- اگر مقدار منفی باشد، علامت آن به مثبت تغییر می‌کند

### فرمت کلی:
```promql
abs(v instant-vector)
```

## مثال‌های کاربردی:

### مثال ۱: محاسبه مقدار مطلق یک متریک
```promql
abs(temperature_celsius{instance="server01"})
```
اگر مقدار `temperature_celsius` برابر با `-15` باشد، نتیجه `15` خواهد بود.

### مثال ۲: استفاده با توابع دیگر
```promql
abs(delta(cpu_temp_celsius[2h]))
```
این پرس‌وجو تغییرات دمای CPU در 2 ساعت گذشته را محاسبه و سپس مقدار مطلق آن را برمی‌گرداند.

### مثال ۳: برای متریک‌هایی که ممکن است منفی باشند
```promql
abs(disk_free_bytes - disk_total_bytes)
```

## موارد استفاده رایج:

۱. **حذف جهت در تغییرات**: وقتی فقط اندازه تغییر مهم است نه جهت آن
۲. **محاسبات خطا**: وقتی می‌خواهید اختلاف بین مقادیر واقعی را بدون در نظر گرفتن علامت اندازه بگیرید
۳. **پردازش متریک‌هایی که ممکن است مقادیر منفی تولید کنند**

## نکات مهم:

- تابع `abs()` فقط روی instant vectorها کار می‌کند
- این تابع برچسب‌های متریک را حفظ می‌کند
- برای range vectorها باید ابتدا از توابعی مثل `delta()` یا `rate()` استفاده کنید

---


# تابع `absent()` در Prometheus

تابع `absent()` یک تابع مفید در PromQL است که برای تشخیص عدم وجود داده (missing metrics) استفاده می‌شود.

## کاربرد اصلی:

تابع `absent()` بررسی می‌کند که آیا یک متریک خاص یا مجموعه‌ای از متریک‌ها وجود دارند یا خیر. اگر متریک وجود نداشته باشد، مقدار ۱ برمی‌گرداند و اگر وجود داشته باشد، نتیجه خالی (no data) برمی‌گرداند.

## سناریوهای استفاده:

۱. **مانیتورینگ وجود متریک‌های حیاتی**:
   - بررسی کنید که آیا متریک‌های مهم مانند `up` یا متریک‌های سفارشی شما وجود دارند یا خیر.

۲. **تشخیص حذف یا غیرفعال شدن اکسپورترها**:
   - وقتی یک اکسپورتر از کار می‌افتد یا حذف می‌شود.

۳. **بررسی پیکربندی اشتباه**:
   - وقتی متریک‌ها به دلیل پیکربندی نادرست جمع‌آوری نمی‌شوند.

## مثال‌های کاربردی:

### مثال ۱: بررسی وجود متریک `up`
```promql
absent(up)
```
- اگر هیچ نمونه‌ای از `up` وجود نداشته باشد، خروجی یک سری زمانی با مقدار ۱ خواهد بود.
- اگر `up` وجود داشته باشد، نتیجه خالی است.

### مثال ۲: بررسی وجود متریک برای یک job خاص
```promql
absent(up{job="node-exporter"})
```
- این پرس‌وجو بررسی می‌کند که آیا متریک `up` برای job با نام `node-exporter` وجود دارد یا خیر.

### مثال ۳: ترکیب با سایر توابع
```promql
absent(sum by(job) (up))
```
- این پرس‌وجو بررسی می‌کند که آیا هر jobای وجود دارد که متریک `up` نداشته باشد.

## نکات مهم:

۱. تابع `absent()` فقط برای متریک‌های instant vector کار می‌کند.
۲. این تابع برای ایجاد آلارم‌ها زمانی که متریک‌ها ناپدید می‌شوند بسیار مفید است.
۳. معمولاً در سیستم‌های مانیتورینگ برای اطمینان از اینکه تمام اجزای مورد انتظار در حال گزارش دادن هستند استفاده می‌شود.

## مثال آلارم:
```promql
absent(up{job="node-exporter"}) == 1
```
این عبارت وقتی فعال می‌شود که اکسپورتر node-exporter هیچ داده‌ای ارسال نکرده باشد.


-------

# تابع `absent_over_time()` در Prometheus

 برای تشخیص عدم وجود داده (missing data) در یک بازه زمانی مشخص استفاده می‌شود.

## کاربرد اصلی

این تابع بررسی می‌کند که آیا یک متریک خاص در طول یک بازه زمانی کاملاً فعال است یا خیر.

## نحوه کار

- اگر متریک مورد نظر **در کل بازه زمانی مشخص شده وجود نداشته باشد**، مقدار 1 برمی‌گرداند
- اگر **حداقل یک نمونه از متریک در آن بازه زمانی وجود داشته باشد**، نتیجه خالی (no data) برمی‌گرداند

## فرمت کلی

```promql
absent_over_time(v range-vector)
```

## مثال‌های کاربردی

### مثال ۱: بررسی وجود متریک `up` در 5 دقیقه گذشته

```promql
absent_over_time(up[5m])
```

### مثال ۲: بررسی وجود متریک برای یک نمونه خاص

```promql
absent_over_time(up{instance="server01"}[1h])
```

### مثال ۳: ترکیب با توابع دیگر

```promql
absent_over_time(sum by(job) (up)[30m])
```

## تفاوت با `absent()`

۱. `absent()` فقط وضعیت فعلی را بررسی می‌کند (instant vector)
۲. `absent_over_time()` وضعیت را در یک بازه زمانی بررسی می‌کند (range vector)

## موارد استفاده معمول

۱. **تشخیص اکسپورترهای از کار افتاده**: وقتی یک اکسپورتر برای مدت طولانی داده ارسال نکرده باشد

۲. **مانیتورینگ سلامت متریک‌ها**: اطمینان از اینکه متریک‌های حیاتی به طور مداوم گزارش می‌شوند

۳. **تشخیص مشکلات شبکه**: وقتی ارتباط با اکسپورترها قطع شده باشد

## مثال برای ایجاد آلارم

```promql
absent_over_time(up{job="node-exporter"}[15m]) == 1
```

این آلارم زمانی فعال می‌شود که متریک `up` برای job مربوط به node-exporter به مدت 15 دقیقه وجود نداشته باشد.

## نکات مهم

- این تابع برای range vectorها کار می‌کند
- بازه زمانی ([5m], [1h] و...) باید مشخص شود
- معمولاً در سیستم‌های مانیتورینگ برای تشخیص مشکلات طولانی مدت استفاده می‌شود
---

# تابع `changes()` در Prometheus
 
  تعداد تغییرات مقدار یک متریک را در یک بازه زمانی مشخص محاسبه میکند.

## کاربرد اصلی

این تابع تعداد دفعاتی که مقدار یک متریک در بازه زمانی داده شده تغییر کرده است را می‌شمارد.

## نحوه عملکرد

- برای هر سری زمانی، تعداد تغییرات مقدار را در بازه مشخص شده می‌شمارد
- هر بار که مقدار متریک نسبت به نمونه قبلی تغییر کند، یک عدد به شمارنده اضافه می‌شود
- تغییرات بین `NaN` (داده وجود ندارد) و یک مقدار معتبر نیز به عنوان تغییر محسوب می‌شود

## فرمت کلی

```promql
changes(v range-vector)
```

## مثال‌های کاربردی

### مثال ۱: شمارش تغییرات یک متریک در ۵ دقیقه گذشته

```promql
changes(process_resident_memory_bytes[5m])
```

### مثال ۲: بررسی تغییرات وضعیت یک سرویس

```promql
changes(up{job="api-server"}[1h])
```

### مثال ۳: ترکیب با توابع دیگر

```promql
sum by(instance) (changes(process_cpu_seconds_total[5m]))
```

## موارد استفاده معمول

۱. **تشخیص نوسانات**: برای شناسایی متریک‌هایی که مقدارشان به طور غیرعادی در حال تغییر است
۲. **مانیتورینگ وضعیت**: برای بررسی تعداد دفعات تغییر وضعیت یک سرویس
۳. **تحلیل رفتار**: برای فهمیدن الگوهای تغییر در متریک‌ها

## مثال برای ایجاد آلارم

```promql
changes(up{job="mysql"}[15m]) > 3
```

این آلارم زمانی فعال می‌شود که سرویس MySQL بیش از ۳ بار در ۱۵ دقیقه تغییر وضعیت داده باشد.

## نکات مهم

- این تابع برای range vectorها کار می‌کند
- تغییرات بین `NaN` و یک مقدار معتبر نیز شمارش می‌شود
- برای متریک‌های counter، معمولاً از `rate()` یا `irate()` مناسب‌تر است
- مقدار بازگشتی همیشه یک عدد صحیح است

## تفاوت با `deriv()`

- `changes()` فقط تعداد تغییرات را می‌شمارد
- `deriv()` نرخ تغییر را در واحد زمان محاسبه می‌کند (مشتق)


---------

# تابع `clamp()` در Prometheus

رای محدود کردن مقادیر یک متریک در یک بازه مشخص استفاده میشود.

## کاربرد اصلی

این تابع مقادیر یک متریک را به محدوده تعریف شده شما محدود میکند:
- مقادیر کمتر از حداقل را به حداقل تنظیم میکند
- مقادیر بیشتر از حداکثر را به حداکثر تنظیم میکند
- مقادیر درون محدوده را بدون تغییر باقی میگذارد

## انواع توابع clamp

Prometheus دو نوع تابع clamp ارائه میدهد:

۱. `clamp_min(v instant-vector, min scalar)`
   - فقط یک حداقل تعیین میکند
   - مثال: `clamp_min(temperature, 10)`

۲. `clamp_max(v instant-vector, max scalar)`
   - فقط یک حداکثر تعیین میکند
   - مثال: `clamp_max(cpu_usage, 90)`

۳. ترکیب هر دو برای ایجاد محدوده کامل

## فرمت کلی

```promql
clamp(v instant-vector, min scalar, max scalar)
```

## مثال‌های کاربردی

### مثال ۱: محدود کردن دما بین 10 تا 30 درجه

```promql
clamp(temperature_celsius, 10, 30)
```

### مثال ۲: جلوگیری از مقادیر منفی

```promql
clamp_min(memory_usage_bytes, 0)
```

### مثال ۳: محدود کردن درصد CPU

```promql
clamp(cpu_usage_percent, 0, 100)
```

## موارد استفاده معمول

۱. **پاکسازی داده‌ها**: حذف مقادیر غیرمنطقی یا ناممکن
۲. **تهیه نمودارها**: محدود کردن مقادیر برای نمایش بهتر
۳. **محاسبات امن**: اطمینان از اینکه مقادیر در محدوده معتبر باقی میمانند

## نکات مهم

- تابع `clamp()` برچسب‌های متریک را حفظ میکند
- برای range vectorها باید ابتدا از توابعی مثل `rate()` استفاده کنید
- مقادیر NaN را تغییر نمیدهد
- حداقل و حداکثر میتوانند اعداد منفی باشند

## مثال پیشرفته

```promql
clamp(
  rate(http_requests_total[5m]),
  0,  # حداقل
  1000 # حداکثر
)
```

این مثال نرخ درخواست‌های HTTP را بین 0 تا 1000 درخواست بر ثانیه محدود میکند.

-----

# توابع `day_of_*` در Prometheus

در Prometheus چندین تابع مربوط به تاریخ و زمان ارائه می‌دهد که به شما امکان می‌دهد بخش‌های مختلف تاریخ را از تایم‌استمپ‌ها استخراج کنید. در اینجا به توابعی که با `day_of_` شروع می‌شوند می‌پردازیم:

## ۱. `day_of_month()`

**کاربرد**: استخراج روز ماه از یک تایم‌استمپ (عدد بین 1 تا 31)

**سینتکس**:
```promql
day_of_month(v instant-vector)
```

**مثال**:
```promql
day_of_month(timestamp(up))
```
این پرس‌وجو روز جاری ماه را برمی‌گرداند (مثلاً 15 برای پانزدهم ماه).

## ۲. `day_of_week()`

**کاربرد**: استخراج روز هفته (یکشنبه=0 تا شنبه=6)

**سینتکس**:
```promql
day_of_week(v instant-vector)
```

**مثال**:
```promql
day_of_week(timestamp(process_start_time_seconds))
```
مقدار 0 برای یکشنبه، 1 برای دوشنبه و الی آخر.

## ۳. `day_of_year()`

**کاربرد**: استخراج روز سال (عدد بین 1 تا 365 یا 366 در سال کبیسه)

**سینتکس**:
```promql
day_of_year(v instant-vector)
```

**مثال**:
```promql
day_of_year(timestamp(up))
```
مثلاً مقدار 1 برای اول فروردین و 365 برای آخر اسفند.

## کاربردهای عملی:

۱. **فیلتر کردن داده‌ها بر اساس روز**:
   ```promql
   up{job="api"} and day_of_week(timestamp(up)) < 5
   ```
   (فقط روزهای کاری هفته)

۲. **تجزیه و تحلیل الگوهای هفتگی**:
   ```promql
   avg by (day_of_week) (rate(http_requests_total[1d]))
   ```

۳. **گزارش‌دهی ماهانه**:
   ```promql
   sum by (day_of_month) (sales_events_total)
   ```

## نکات مهم:

- تمام این توابع روی instant vectorها کار می‌کنند
- ورودی باید تایم‌استمپ باشد (معمولاً با تابع `timestamp()` می‌گیریم)
- مقادیر برگشتی همیشه اعداد صحیح هستند
- برای range vectorها باید از توابع aggregation استفاده کنید

## مثال ترکیبی:

```promql
# تعداد درخواست‌ها در آخر هفته (شنبه و یکشنبه)
sum(rate(http_requests_total[1h])) by (service)
  * on() group_left()
(day_of_week(timestamp(up)) >= 5)
```

این پرس‌وجو فقط داده‌های مربوط به روزهای آخر هفته را محاسبه می‌کند.

-----------


# تابع `delta()` در Prometheus

برای محاسبه تغییرات مقدار یک متریک در یک بازه زمانی مشخص استفاده می‌شود.

## کاربرد اصلی

این تابع تفاوت بین اولین و آخرین مقدار یک متریک در بازه زمانی داده شده را محاسبه می‌کند:

```
delta = مقدار آخر - مقدار اول
```

## ویژگی‌های کلیدی:

۱. **مخصوص متریک‌های نوع Counter**: برای متریک‌هایی که فقط افزایش می‌یابند (مانند تعداد درخواست‌ها) مناسب است
۲. **مقابله با Reset**: اگر Counter ریست شود، محاسبه را به درستی انجام می‌دهد
۳. **بازه زمانی**: حتماً نیاز به تعیین بازه زمانی دارد (مثل [5m]، [1h])

## فرمت کلی:

```promql
delta(v range-vector)
```

## مثال‌های کاربردی:

### مثال ۱: محاسبه افزایش تعداد درخواست‌ها در ۵ دقیقه

```promql
delta(http_requests_total[5m])
```

### مثال ۲: محاسبه افزایش با گروه‌بندی

```promql
delta(http_requests_total{job="api"}[1h])
```

### مثال ۳: ترکیب با توابع دیگر

```promql
sum by (instance) (delta(process_cpu_seconds_total[1m]))
```

## تفاوت با `increase()`:

- ء`delta()` مقدار مطلق تغییر را برمی‌گرداند (ممکن است منفی باشد)
- ء`increase()` همیشه مقدار غیرمنفی برمی‌گرداند و برای Counterها مناسب‌تر است

## نکات مهم:

۱. فقط برای range vectorها کار می‌کند
۲. برای متریک‌های Gauge (که می‌توانند کاهش یابند) نیز کاربرد دارد
۳. ممکن است مقادیر منفی برگرداند (در صورت کاهش مقدار متریک)
۴. در صورت ریست شدن Counter، محاسبات را تصحیح می‌کند

## مثال پیشرفته:

```promql
delta(
  node_network_receive_bytes_total{device="eth0"}[1h]
) / 1024 / 1024
```
(محاسبه مگابایت دریافت شده در یک ساعت)


-----

# تابع `deriv()` در Prometheus

 برای محاسبه **نرخ تغییرات** یک متریک در یک بازه زمانی استفاده میشود.

## کاربرد اصلی

این تابع **مشتق** (نرخ تغییر) یک متریک Gauge را در بازه زمانی مشخص محاسبه میکند و نشان میدهد که مقدار متریک با چه سرعتی در حال تغییر است.

## فرمت کلی:
```promql
deriv(v range-vector)
```

## ویژگی‌های کلیدی:
۱. مناسب برای متریک‌های نوع **Gauge** (مقادیر متغیر)
۲. محاسبه **نرخ تغییر بر ثانیه**
۳. استفاده از رگرسیون خطی برای محاسبه دقیقتر
۴. نیاز به تعیین بازه زمانی (مثلاً [5m], [1h])

## مثال‌های کاربردی:

### مثال ۱: محاسبه نرخ تغییر دمای CPU
```promql
deriv(node_cpu_temp_celsius[10m])
```
> نتیجه: میزان تغییر دما بر حسب درجه سانتیگراد بر ثانیه

### مثال ۲: روند تغییرات استفاده از حافظه
```promql
deriv(process_resident_memory_bytes[1h])
```

### مثال ۳: ترکیب با توابع دیگر
```promql
avg(deriv(disk_usage_percent[30m]))
```

## تفاوت با `delta()` و `rate()`:
| تابع      | مناسب برای    | خروجی                          | روش محاسبه     |
| --------- | ------------- | ------------------------------ | -------------- |
| `deriv()` | Gauge         | نرخ تغییر (ممکن است منفی باشد) | رگرسیون خطی    |
| `delta()` | Gauge/Counter | تغییر مطلق                     | تفاوت ساده     |
| `rate()`  | Counter       | نرخ متوسط تغییر                | بر اساس افزایش |

## نکات مهم:
۱. برای متریک‌های Counter از `rate()` یا `irate()` استفاده کنید
۲. مقادیر منفی نشان دهنده کاهش متریک است
۳. دقت محاسبه به طول بازه زمانی بستگی دارد
۴. برای نمایش روندهای بلندمدت مفید است

## مثال پیشرفته:
```promql
# پیش‌بینی زمان رسیدن به حد مجاز حافظه
predict_linear(
  deriv(process_resident_memory_bytes[1h])[10m:],
  3600
)
```

این تابع برای تحلیل روندها و پیش‌بینی مشکلات احتمالی بسیار مفید است.


----------

### **Double Exponential Smoothing

روش **Double Exponential Smoothing (هموارسازی نمایی دوگانه)** یا به فارسی **هموارسازی نمایی دوگانه**، یکی از روش‌های پیش‌بینی سری‌های زمانی است که علاوه بر **میانگین‌گیری و هموارسازی داده‌ها**، **روند (Trend)** داده را نیز در نظر می‌گیرد.

---

### 🔹 مروری بر ایده اصلی

در **هموارسازی نمایی ساده (Simple Exponential Smoothing)** فرض می‌شود که داده‌ها روند خاصی ندارند و فقط نوسانات تصادفی دارند.
اما اگر داده‌ها روند افزایشی یا کاهشی داشته باشند (مثلاً فروش ماهانه که رو به افزایش است)، مدل ساده دیگر مناسب نیست.
در این حالت از **Double Exponential Smoothing** استفاده می‌شود که می‌تواند **سطح (Level)** و **روند (Trend)** را جداگانه مدل کند.

---

### 🔹 فرمول‌ها

این روش دو مؤلفه دارد:

۱. **سطح (Level):**
$$
   [
   L_t = \alpha Y_t + (1 - \alpha)(L_{t-1} + T_{t-1})
   ]$$
   که در آن:

‏   * ( Y_t ): مقدار مشاهده‌شده در زمان ( t )
   * ‏( L_t ): سطح (میانگین هموارشده) در زمان ( t )
   * ‏( T_{t-1} ): روند برآوردشده در زمان قبلی
   ‏* ( \alpha ): ضریب هموارسازی برای سطح (بین 0 و 1)

۲. **روند (Trend):**
  که در آن:
$$
   [
   T_t = \beta (L_t - L_{t-1}) + (1 - \beta) T_{t-1}
   ]
 
$$
   * ‏( T_t ): روند در زمان ( t )
   * ‏( \beta ): ضریب هموارسازی برای روند (بین 0 و 1)



۲. **پیش‌بینی (Forecast):**

$$
   [
   \hat{Y}_{t+m} = L_t + mT_t
   ]
$$
   که در آن:
   

   * ( m ): تعداد گام‌های پیش‌بینی به جلو است (مثلاً پیش‌بینی برای ماه بعد یعنی ( m = 1 ))

---

### 🔹 تفسیر شهودی

‏* ( L_t ): مقدار "سطح" فعلی داده (مثل میانگین هموارشده)
‏* ( T_t ): نرخ تغییر (شیب یا روند رشد/کاهش)
* ضرایب ( \alpha ) و ( \beta ): کنترل میزان واکنش مدل به تغییرات جدید داده‌ها
  (اگر نزدیک 1 باشند، مدل به تغییرات جدید سریع‌تر واکنش می‌دهد)

---

### 🔹 مثال ساده

فرض کنید داده‌های فروش ماهانه به صورت زیر باشند:

| ماه | فروش (Y) |
| --- | -------- |
| 1   | 100      |
| 2   | 120      |
| 3   | 130      |
| 4   | 150      |

می‌بینیم که روند صعودی دارد → پس Double Exponential Smoothing مناسب است.

مدل با محاسبه سطح و روند در هر مرحله، فروش ماه‌های آینده را پیش‌بینی می‌کند (مثلاً ماه 5 و 6).

---

### 🔹 انواع مدل‌ها

در واقع Double Exponential Smoothing نوع خاصی از مدل‌های **Holt’s Linear Trend** است، که بعدها با اضافه کردن مؤلفه‌ی فصلی (**Seasonality**) به مدل **Triple Exponential Smoothing (Holt-Winters)** تبدیل شد.

---

### 🔹 در پایتون (مثال کوتاه با statsmodels)

```python
from statsmodels.tsa.holtwinters import ExponentialSmoothing

model = ExponentialSmoothing(data, trend='add').fit()
forecast = model.forecast(5)
print(forecast)
```

در اینجا:

‏* `trend='add'` یعنی روند خطی افزایشی.
‏* `forecast(5)` یعنی پیش‌بینی ۵ گام آینده.

---


# تابع `holt_winters()` (Double Exponential Smoothing) در PromQL

 ءPrometheus از نسخه 2.0 به بعد تابع `holt_winters()` را ارائه کرده که پیاده‌سازی Double Exponential Smoothing (هموارسازی نمایی دوگانه) است.

## کاربرد اصلی

این تابع برای **پیش‌بینی مقادیر آینده** بر اساس روند تاریخی داده‌ها استفاده می‌شود و ترکیبی از:

۱. هموارسازی سطح داده (Level)
۲. هموارسازی روند (Trend)

## فرمت کلی:

```promql
holt_winters(v range-vector, sf scalar, tf scalar)
```

- `sf`: فاکتور هموارسازی (smoothing factor) برای سطح (0 < sf < 1)
- `tf`: فاکتور هموارسازی برای روند (0 < tf < 1)

## مثال کاربردی:

```promql
holt_winters(
  node_memory_MemFree_bytes[1h],  # متریک و بازه زمانی
  0.3,  # فاکتور هموارسازی سطح
  0.3   # فاکتور هموارسازی روند
)
```



```promql
holt_winters(node_memory_MemFree_bytes[1h],0.3,0.3)
```
## پارامترهای مهم:

۱. **فاکتورهای هموارسازی**:
   - مقادیر نزدیک به 0: وزن بیشتر به داده‌های تاریخی
   - مقادیر نزدیک به 1: وزن بیشتر به داده‌های اخیر

۲. **بازه زمانی**:
   - باید به اندازه‌ای باشد که الگوهای فصلی و روند را پوشش دهد

## تفاوت با `predict_linear()`:

| ویژگی | `holt_winters()` | `predict_linear()` |
|--------|------------------|--------------------|
| روش | هموارسازی دوگانه | رگرسیون خطی ساده |
| ملاحظات روند | دارد | دارد |
| ملاحظات فصلی | خیر | خیر |
| پیچیدگی | بیشتر | کمتر |

## نکات مهم:

۱. فقط برای **Gauge metrics** مناسب است
۲. نیاز به تنظیم دقیق پارامترها دارد
۳. برای پیش‌بینی‌های کوتاه‌مدت بهتر عمل می‌کند
۴. در نسخه‌های جدید Prometheus ممکن است تغییر کرده باشد

مثال پیشرفته برای مانیتورینگ:

```promql
# پیش‌بینی استفاده از CPU با هموارسازی دوگانه
holt_winters(
  instance:node_cpu_utilisation:rate5m[2h],
  0.5,
  0.2
) > 0.8
```

این کوئری زمانی آلارم می‌دهد که پیش‌بینی می‌شود استفاده از CPU از 80% عبور کند.


٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪

 
---

## 🧩 تعریف تابع histogram_fraction

```promql
histogram_fraction(φ, sum(rate(<histogram>_bucket[range])) by (labels))
```

یا به طور کلی:

```promql
histogram_fraction(quantile, histogram_metric)
```

---

## 🎯 هدف تابع

`histogram_fraction()` برای محاسبه **کسری از نمونه‌های histogram** که **کمتر یا مساوی یک مقدار خاص** هستند استفاده می‌شود.

> به زبان ساده: مشخص می‌کند چه سهمی از درخواست‌ها یا رویدادها، مقدارشان کمتر از یک حد معین است.

---

## 🧠 مفاهیم کلیدی

1. Histogram در Prometheus معمولاً شامل چند metric است:

| Metric    | توضیح                               |
| --------- | ----------------------------------- |
| `_bucket` | تعداد نمونه‌های ≤ هر حد بالایی (le) |
| `_count`  | تعداد کل نمونه‌ها                   |
| `_sum`    | جمع مقادیر نمونه‌ها                 |

2. `histogram_fraction(φ, ...)` کسری از نمونه‌ها که ≤ مقدار مورد نظر هستند را محاسبه می‌کند:

* φ: عدد بین 0 و 1
* φ = 0.9 → ۹۰٪ نمونه‌ها

---

## 📊 مثال کاربردی

فرض کن metric زیر داریم:

```
http_request_duration_seconds_bucket
```

و می‌خواهیم ببینیم **۹۰٪ درخواست‌ها چقدر سریع پاسخ داده شده‌اند**:

```promql
histogram_quantile(0.9, sum(rate(http_request_duration_seconds_bucket[5m])) by (le))
```

🔹 این مثال مشابه `histogram_fraction()` است.

* در واقع، `histogram_fraction()` معمولاً در محاسبات داخلی Prometheus برای بدست آوردن **percentile fractions** استفاده می‌شود.

---

### 🔹 تفاوت با `histogram_quantile()`

| تابع                   | خروجی                      | کاربرد                                             |
| ---------------------- | -------------------------- | -------------------------------------------------- |
| `histogram_fraction()` | کسری نمونه‌ها ≤ مقدار مشخص | معمولاً برای internal/low-level محاسبات percentile |
| `histogram_quantile()` | مقدار متناظر با percentile | محاسبه quantile مثل P90، P99                       |

> به عبارتی:
>
> * `histogram_fraction()` می‌گوید: "چه درصدی از نمونه‌ها ≤ مقدار X هستند"
> * `histogram_quantile()` می‌گوید: "مقدار Y که φ درصد نمونه‌ها ≤ Y هستند"

---

## ⚠️ نکات مهم

* این تابع **مستقیماً روی histogram_bucket** کار می‌کند.
* معمولاً برای **تحلیل دقیق توزیع داده‌ها** استفاده می‌شود.
* در بیشتر استفاده‌های معمول، **کاربر مستقیم از `histogram_fraction()` استفاده نمی‌کند** و از `histogram_quantile()` بهره می‌برد.

---

## 🧾 خلاصه

| ویژگی                       | توضیح                                                                            |
| --------------------------- | -------------------------------------------------------------------------------- |
| تابع                        | `histogram_fraction(φ, histogram_metric)`                                        |
| ورودی                       | histogram metric (_bucket)                                                       |
| خروجی                       | کسری نمونه‌ها ≤ مقدار مشخص                                                       |
| کاربرد                      | محاسبه درصد نمونه‌ها تحت مقدار خاص، تحلیل percentile                             |
| تفاوت با histogram_quantile | histogram_fraction → درصد نمونه‌ها، histogram_quantile → مقدار متناظر percentile |

---

اگر بخواهی، می‌توانم یک **مثال عملی با histogram HTTP request durations** بزنم که هم P90 را با `histogram_quantile()` و هم درصد نمونه‌ها ≤ یک مقدار را با `histogram_fraction()` نشان دهد، تا فرقشان واضح شود.

 ٪٪٪٪٪٪٪٪٪٪٪٪
-



--

##  تابع `histogram_quantile()`

تابع `histogram_quantile(φ, buckets)` برای محاسبه‌ی **صدک (quantile)** φ از داده‌های یک **هیستوگرام (histogram)** استفاده می‌شود.

به زبان ساده:

> این تابع می‌گوید "چند ثانیه طول کشید تا X٪ از درخواست‌ها پاسخ گرفتند؟"

---

## 🧩 ساختار histogram در Prometheus

وقتی یک متریک از نوع histogram بسازی، Prometheus به‌صورت خودکار سه نوع متریک تولید می‌کند:

| متریک                     | توضیح                                  |
| ------------------------- | -------------------------------------- |
| `<metric>_bucket{le="X"}` | تعداد کل رخدادهایی که مقدارشان ≤ X است |
| `<metric>_sum`            | مجموع تمام مقادیر                      |
| `<metric>_count`          | تعداد کل رخدادها                       |

مثلاً متریک زیر را در نظر بگیر:

```
http_request_duration_seconds
```

Prometheus داده‌هایی مثل این ذخیره می‌کند:

| le   | مقدار |
| ---- | ----- |
| 0.1  | 120   |
| 0.3  | 300   |
| 0.5  | 450   |
| 1.0  | 600   |
| +Inf | 700   |

یعنی:

* تا ۰.۱ ثانیه: ۱۲۰ درخواست
* تا ۰.۵ ثانیه: ۴۵۰ درخواست
* تا ۱ ثانیه: ۶۰۰ درخواست
* در مجموع: ۷۰۰ درخواست

---

## 🧮 فرمول مفهومی

تابع `histogram_quantile(φ, ...)` به صورت تقریبی مقدار **q-th quantile** (مثل p90، p95 یا p99) را از این bucketها محاسبه می‌کند.

یعنی برای φ = 0.9 (صدک ۹۰‌ام):

> آن مقداری از زمان پاسخ که ۹۰٪ از درخواست‌ها کمتر از آن بوده‌اند.

---

## 📜 نحوه استفاده

مثال استاندارد در PromQL:

```promql
histogram_quantile(
  0.9,
  sum(rate(http_request_duration_seconds_bucket[5m])) by (le)
)
```

توضیح:

* `rate(...[5m])`: نرخ افزایش هر bucket در ۵ دقیقه اخیر
* `sum(... by (le))`: مجموع bucketها از تمام instanceها (اما bucket `le` را نگه می‌دارد)
* `histogram_quantile(0.9, …)`: محاسبه صدک ۹۰ام از این توزیع

---

## 📊 مثال عددی

فرض کن توزیع bucketهای latency به شکل زیر است:

| Bucket (le) | Rate |
| ----------- | ---- |
| 0.1         | 50   |
| 0.3         | 200  |
| 0.5         | 400  |
| 1.0         | 500  |
| +Inf        | 550  |

می‌خواهیم φ = 0.9 یعنی p90 را حساب کنیم:

* جمع کل = 550
* ۹۰٪ از ۵۵۰ = ۴۹۵
* تا bucket 0.5 جمع = ۴۰۰ → هنوز کمتر از ۴۹۵
* تا bucket 1.0 جمع = ۵۰۰ → حالا از ۴۹۵ عبور کرد
  پس p90 بین 0.5 و 1.0 است.

با درون‌یابی خطی (interpolation):

```
p90 ≈ 0.5 + (1.0 - 0.5) * ((495 - 400) / (500 - 400))
    = 0.5 + 0.5 * 0.95
    = 0.975 seconds
```

یعنی p90 ≈ 0.975 ثانیه

---

## ⚠️ چند نکته مهم

1. تابع `histogram_quantile()` فقط با متریک‌هایی از نوع `_bucket` کار می‌کند.
   (نه با `_sum` یا `_count`)

2. معمولاً باید قبل از آن از `rate()` استفاده کنی تا نرخ تغییر را بگیری:

   ```promql
   rate(http_request_duration_seconds_bucket[10m])
   ```

3. و معمولاً با `sum()` گروه‌بندی می‌شود تا چندین سرور با هم ترکیب شوند:

   ```promql
   sum(rate(...)) by (le)
   ```

4. صدک‌های رایج:

   * 0.5 → p50 (میانگین)
   * 0.9 → p90
   * 0.95 → p95
   * 0.99 → p99

---

## 📈 خلاصه ساده

| پارامتر                   | معنی                                      |
| ------------------------- | ----------------------------------------- |
| `0.9`                     | درصد مورد نظر (۹۰٪)                       |
| `rate(..._bucket[10m])`   | نرخ تغییر bucketها در ۱۰ دقیقه اخیر       |
| `sum(... by (le))`        | جمع کل bucketها از همه instanceها         |
| `histogram_quantile(...)` | محاسبهٔ p90 latency از داده‌های histogram |

---

می‌خواهی برات یک نمودار تصویری از نحوهٔ کار `histogram_quantile()` (چطور بین bucketها درون‌یابی می‌کند) رسم کنم؟
با اون خیلی راحت می‌فهمی چطور p90 از داده‌ها استخراج می‌شود.


------------


---

## ⚙️ تعریف تابع

```promql
idelta(v range-vector)
```

---

## 🎯 هدف تابع

تابع `idelta()` اختلاف مقدار **آخرین نمونه (latest sample)** و **اولین نمونه (earliest sample)** را در بازه‌ی زمانی مشخص‌شده محاسبه می‌کند.
به زبان ساده:

> تغییر مقدار متریک بین شروع و پایان یک بازه‌ی زمانی کوتاه را برمی‌گرداند.

---

## 🔬 نحوه کار

فرض کن بازه‌ی `[5m]` را روی یک متریک قرار دهی:

```promql
idelta(metric_name[5m])
```

اگر در این ۵ دقیقه مقدار متریک از `100` به `130` تغییر کند، خروجی می‌شود:

```
130 - 100 = 30
```

---

## 🧮 مثال ساده

فرض کن داریم:

| زمان  | مقدار متریک |
| ----- | ----------- |
| 10:00 | 100         |
| 10:01 | 110         |
| 10:02 | 120         |
| 10:03 | 130         |

و عبارت زیر را اجرا می‌کنی:

```promql
idelta(metric_name[3m])
```

📤 نتیجه:

```
130 - 100 = 30
```

---

## 🧠 تفاوت `idelta()` با `delta()` و `rate()`

| تابع       | نوع داده ورودی | خروجی                         | کاربرد                                   |
| ---------- | -------------- | ----------------------------- | ---------------------------------------- |
| `idelta()` | range vector   | اختلاف لحظه‌ای (raw)          | برای متریک‌های *Gauge* یا تغییر لحظه‌ای  |
| `delta()`  | range vector   | اختلاف نرمال‌شده بر اساس زمان | برای متریک‌های *Gauge* در بازه طولانی‌تر |
| `rate()`   | range vector   | نرخ تغییر در واحد "در ثانیه"  | برای *Counter* (تجمعی)                   |
| `irate()`  | range vector   | نرخ لحظه‌ای بین دو نمونه آخر  | برای *Counter* در بازه کوتاه             |

---

## 🧩 پس یعنی:

* `idelta()` → اختلاف واقعی بین اولین و آخرین نمونه (بدون در نظر گرفتن زمان)
* `delta()` → اختلاف تقسیم بر مدت زمان بازه
* `rate()` → مخصوص متریک‌های *Counter*
* `irate()` → نرخ تغییر بین دو نقطه آخر (فوری‌تر)

---

## 📊 مثال کاربردی

فرض کن یک متریک داری به نام:

```
temperature_celsius
```

و می‌خواهی بدانی دمای سیستم در ۵ دقیقه‌ی گذشته چقدر تغییر کرده (مثلاً افزایش یا کاهش سریع دما):

```promql
idelta(temperature_celsius[5m])
```

📤 نتیجه:
اگر از 42.0 به 44.5 رسیده باشد → خروجی = 2.5°C

---

## ⚠️ نکته مهم

`idelta()` برای **Gauge**ها (مثل دما، حافظه، بار سیستم) مناسب است،
اما برای **Counter**ها (مثل تعداد درخواست‌ها) **غلط یا گمراه‌کننده** است.

چون Counter فقط افزایش می‌یابد (و ممکن است reset شود)،
و در این حالت باید از `irate()` یا `rate()` استفاده کنی.

---

## 📈 جمع‌بندی سریع

| ویژگی           | توضیح                                  |
| --------------- | -------------------------------------- |
| تابع            | `idelta(v range-vector)`               |
| ورودی           | range vector (مثلاً `[5m]`)            |
| خروجی           | اختلاف بین آخرین و اولین نمونه در بازه |
| مناسب برای      | متریک‌های Gauge                        |
| مناسب نیست برای | متریک‌های Counter                      |
| مشابه           | `delta()` ولی بدون تقسیم بر زمان       |

---

### ✳️ مثال نهایی برای فهم بهتر:

| زمان  | metric | Δ   | idelta        | delta                      |
| ----- | ------ | --- | ------------- | -------------------------- |
| 10:00 | 100    |     |               |                            |
| 10:05 | 150    | +50 | `idelta = 50` | `delta = 50 / 300 = 0.166` |

٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪

---

## ⚙️ تعریف تابع

```promql
increase(v range-vector)
```

---

## 🎯 هدف تابع

تابع `increase()` میزان **افزایش تجمعی (total increase)** یک متریک از نوع **Counter** را در بازه‌ی زمانی مشخص‌شده محاسبه می‌کند.

یعنی:

> از آخرین مقدار منهای اولین مقدار (با در نظر گرفتن نرخ نمونه‌برداری و reset احتمالی Counter).

---

## 🧩 درک ساده

فرض کن متریک زیر رو داری:

```
http_requests_total
```

و مقدارهاش در بازه ۵ دقیقه‌ای اینطوری بودن:

| زمان  | مقدار |
| ----- | ----- |
| 10:00 | 100   |
| 10:01 | 150   |
| 10:02 | 220   |
| 10:03 | 260   |

اگر بنویسی:

```promql
increase(http_requests_total[5m])
```

📤 نتیجه = `100 - 260 = 160`

یعنی در ۵ دقیقه گذشته، **۱۶۰ درخواست جدید** انجام شده.

---

## ⚠️ نکته مهم: مخصوص Counter است

`increase()` فقط برای **Counter**ها طراحی شده (متریک‌هایی که فقط زیاد می‌شن).
برای مثال:

✅ درست برای:

* `http_requests_total`
* `packets_sent_total`
* `errors_total`

❌ اشتباه برای:

* `temperature_celsius`
* `cpu_usage`
* `memory_free`

چون اونا Gauge هستن (کم و زیاد می‌شن).

---

## 🧠 نحوه محاسبه دقیق

`increase()` در واقع از `rate()` استفاده می‌کنه:

```promql
increase(X[5m]) ≈ rate(X[5m]) * 300
```

(عدد 300 یعنی ۵ دقیقه = ۳۰۰ ثانیه)

🔹 تفاوت: `increase()` مقدار کل افزایش در بازه را می‌دهد
🔹 اما `rate()` نرخ افزایش در ثانیه را.

---

### مثال عددی برای مقایسه

| تابع                                | خروجی   | معنی                                |
| ----------------------------------- | ------- | ----------------------------------- |
| `increase(http_requests_total[5m])` | `160`   | تعداد کل درخواست‌ها در ۵ دقیقه اخیر |
| `rate(http_requests_total[5m])`     | `0.533` | درخواست در ثانیه (≈160 ÷ 300s)      |

---

## 🧮 حالت Reset (بازنشانی Counter)

اگر مقدار Counter ریست شود (مثلاً سرور ری‌استارت شود)،
‏Prometheus این را تشخیص می‌دهد و محاسبه را اصلاح می‌کند.

مثلاً:

| زمان  | مقدار Counter |
| ----- | ------------- |
| 10:00 | 100           |
| 10:02 | 200           |
| 10:03 | 10 ← reset    |
| 10:04 | 60            |

در این حالت:

```promql
increase(metric[5m])
```

نتیجه = `(100 - 200) + (10 - 60) = 150`

Prometheus خودش تشخیص می‌دهد که بین 200 و 10 ریست اتفاق افتاده.

---

## 🧩 مثال واقعی

اگر بخواهی بدانی در ۱ ساعت گذشته چند درخواست موفق HTTP (`code="200"`) داشتیم:

```promql
increase(http_requests_total{code="200"}[1h])
```

📤 نتیجه: تعداد کل درخواست‌های موفق در ۱ ساعت اخیر

---

## 📈 مثال ترکیبی با `sum()`

اگر چند سرور یا پاد داری و می‌خواهی مجموع کل افزایش رو حساب کنی:

```promql
sum(increase(http_requests_total[5m])) by (job)
```

📤 نتیجه: مجموع درخواست‌ها در ۵ دقیقه گذشته برای هر job

---

## ✅ خلاصه

| ویژگی             | توضیح                             |
| ----------------- | --------------------------------- |
| تابع              | `increase(v range-vector)`        |
| ورودی             | متریک از نوع Counter              |
| خروجی             | مقدار افزایش در بازه‌ی زمانی      |
| کاربرد            | شمارش رخدادها در یک بازه          |
| رفتار با reset    | خودش اصلاح می‌کند                 |
| رابطه با `rate()` | `increase() = rate() * زمان_بازه` |

---

### 🧾 مثال نهایی برای یادگیری سریع

| متریک               | زمان  | مقدار | increase                  |
| ------------------- | ----- | ----- | ------------------------- |
| http_requests_total | 10:00 | 100   |                           |
| http_requests_total | 10:05 | 250   | `increase(...[5m]) = 150` |

---


٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪


## 🧩 تعریف تابع

```promql
info(v instant-vector)
```

---

## 🎯 هدف تابع

تابع `info()` برای **تولید یک نسخه‌ی "informational" (اطلاعاتی)** از یک متریک استفاده می‌شود.
به عبارت ساده:

> `info()` همه‌ی برچسب‌ها (labels) و مقادیر نمونه‌ها را حفظ می‌کند،
> ولی مقدار عددی همه‌ی آن‌ها را به `1` تغییر می‌دهد.

---

## 📊 یعنی چی؟

فرض کن داری:

```promql
up
```

📤 خروجی:

| instance     | job  | value |
| ------------ | ---- | ----- |
| server1:9100 | node | 1     |
| server2:9100 | node | 0     |

اگر بنویسی:

```promql
info(up)
```

📤 خروجی:

| instance     | job  | value |
| ------------ | ---- | ----- |
| server1:9100 | node | 1     |
| server2:9100 | node | 1     |

یعنی همه‌ی مقادیر `1` شدن (صرف‌نظر از مقدار اصلی).

---

## 🧠 هدف واقعی استفاده از `info()`

تابع `info()` در Prometheus 2.40 به بعد معرفی شد تا کمک کنه:

* داده‌های **اطلاعاتی / متادیتا** را از متریک‌ها استخراج کنی؛
* یا از **metricهای gauge یا counter** فقط برای نگه‌داشتن *labelها* استفاده کنی، نه مقدارشان.

---

## 📍 کاربردهای واقعی

### ✅ ۱. شمارش تعداد سری داده‌ها

می‌خواهی بدونی چند سری داده برای یک متریک وجود دارد:

```promql
count(info(http_requests_total))
```

📤 مثلاً:

```
20
```

(یعنی ۲۰ سری مختلف از `http_requests_total` موجود است.)

---

### ✅ ۲. بررسی لیست labelهای موجود

اگر بنویسی:

```promql
info(node_exporter_build_info)
```

خروجی چیزی مثل این می‌شود:

| version | instance     | job  | value |
| ------- | ------------ | ---- | ----- |
| 1.7.0   | server1:9100 | node | 1     |
| 1.8.0   | server2:9100 | node | 1     |

🔹 اینجا از `node_exporter_build_info` فقط اطلاعات نسخه و برچسب‌ها نگه داشته شده.

---

### ✅ ۳. فیلتر داده‌ها بدون درگیر شدن با مقدار

گاهی متریک‌هایی داری که فقط label مهم است، نه مقدار.
مثلاً می‌خواهی فهرست تمام containerهای موجود را ببینی، فارغ از state:

```promql
info(container_last_seen)
```

---

## ⚙️ نکته فنی

* تابع `info()` مقدار عددی هر sample را به 1 تغییر می‌دهد.
* تمام labelها و timestampها را حفظ می‌کند.
* این تابع فقط روی **instant vector** کار می‌کند (نه range vector).
* مقدار خروجی برای **aggregation** یا **counting** مناسب است، نه محاسبات ریاضی.

---

## 🧾 خلاصه نهایی

| ویژگی            | توضیح                                           |
| ---------------- | ----------------------------------------------- |
| تابع             | `info(v instant-vector)`                        |
| ورودی            | هر متریک لحظه‌ای                                |
| خروجی            | همان متریک با مقدار ۱ برای همه‌ی نمونه‌ها       |
| هدف              | استخراج اطلاعات، شمارش یا فهرست labelها         |
| مناسب برای       | metadata metrics مثل `*_info` یا `*_build_info` |
| پشتیبانی از نسخه | Prometheus 2.40+                                |

---

## 💡 مثال ترکیبی

```promql
count by (version) (info(node_exporter_build_info))
```

📤 نتیجه:

| version | count |
| ------- | ----- |
| 1.7.0   | 3     |
| 1.8.0   | 5     |

> یعنی ۳ نود با نسخه‌ی 1.7.0 و ۵ نود با نسخه‌ی 1.8.0 کار می‌کنند.


٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪




---

## 🧩 تعریف تابع irate

```promql
irate(v range-vector)
```

---

## 🎯 هدف

تابع `irate()` (مخفف **instant rate**)
برای محاسبه‌ی **نرخ لحظه‌ای (تقریباً لحظه‌به‌لحظه)** تغییرات یک **Counter** در Prometheus استفاده می‌شود.

به زبان ساده:

> `irate()` مقدار **سرعت تغییر** متریک را در **آخرین بازه‌ی زمانی** داده‌شده محاسبه می‌کند.
> یعنی از *آخرین دو نمونه* در بازه استفاده می‌کند.

---

## ⚙️ نحوه‌ی کارکرد

فرض کن متریک زیر داری:

| زمان  | مقدار `http_requests_total` |
| ----- | --------------------------- |
| 12:00 | 100                         |
| 12:10 | 120                         |
| 12:20 | 180                         |

اگر بنویسی:

```promql
irate(http_requests_total[20m])
```

🔹 Prometheus فقط **آخرین دو نقطه** را نگاه می‌کند:

* 12:10 → 120
* 12:20 → 180

و نرخ را محاسبه می‌کند:

```
(180 - 120) / (12:20 - 12:10) = 60 / 600 = 0.1 req/sec
```

📤 خروجی:

```
0.1
```

---

## 🆚 تفاوت `irate()` و `rate()`

| ویژگی                        | `rate()`                   | `irate()`                                       |
| ---------------------------- | -------------------------- | ----------------------------------------------- |
| نوع نرخ                      | **میانگین نرخ** در کل بازه | **نرخ لحظه‌ای** از آخرین دو نمونه               |
| حساسیت به تغییرات ناگهانی    | کمتر (smooth)              | زیاد (تغییرات سریع را نشان می‌دهد)              |
| مناسب برای                   | نمودارهای کلی و Alertها    | مانیتور لحظه‌ای (مثلاً داشبورد زنده در Grafana) |
| نمونه‌هایی که استفاده می‌کند | تمام نقاط بازه             | فقط دو نمونه آخر                                |

---

### 🔹 مثال مقایسه‌ای

فرض کن در ۵ دقیقه اخیر، `http_requests_total` از 100 → 200 → 400 → 800 رفته.

```promql
rate(http_requests_total[5m])
```

→ مقدار میانگین رشد در ۵ دقیقه اخیر را می‌دهد.
(نرم‌تر و پایدارتر است)

```promql
irate(http_requests_total[5m])
```

→ فقط از دو نقطه‌ی آخر استفاده می‌کند (سریع‌تر و نوسانی‌تر است).

---

## ⚠️ نکته مهم

‏* `irate()` فقط روی **Counter metrics** (مثل `_total` یا `_count`) معنی دارد.
* اگر روی `Gauge` استفاده شود (مثل `temperature`)، نتیجه اشتباه است.
* اگر داده‌ها با فاصله زیاد جمع شوند (مثلاً هر 1 دقیقه)، `irate()` ممکن است **پرت** شود چون فقط دو نقطه دارد.

---

## 💡 کاربردهای واقعی

### ✅ ۱. نرخ لحظه‌ای درخواست‌ها در وب‌سرور

```promql
irate(http_requests_total[1m])
```

> نشان می‌دهد در همین لحظه، چند درخواست بر ثانیه در حال انجام است.

---

### ✅ ۲. نرخ خطاها (Error rate)

```promql
irate(http_requests_total{status=~"5.."}[1m])
```

> نرخ لحظه‌ای خطاهای 5xx در ۱ دقیقه اخیر.

---

### ✅ ۳. نرخ ارسال داده در شبکه

```promql
irate(node_network_transmit_bytes_total[30s])
```

> سرعت ارسال داده (بایت بر ثانیه) در آخرین ۳۰ ثانیه.

---

## 🧾 خلاصه نهایی

| ویژگی             | توضیح                                           |
| ----------------- | ----------------------------------------------- |
| تابع              | `irate(v range-vector)`                         |
| ورودی             | متریک از نوع Counter                            |
| خروجی             | نرخ لحظه‌ای افزایش در واحد زمان                 |
| بازه مورد استفاده | فقط دو نمونه‌ی آخر بازه                         |
| استفاده معمول     | مانیتور زنده (real-time)                        |
| تفاوت با rate()   | `rate` نرم‌تر است، `irate` سریع‌تر واکنش می‌دهد |


٪٪٪٪٪٪٪٪٪٪٪٪٪٪

---

## 🧩 تعریف تابع label_join()

```promql
label_join(vector, dst_label, separator, src_label1, src_label2, ...)
```

---

## 🎯 هدف تابع

تابع `label_join()` برای **ترکیب چند label در یک label جدید** استفاده می‌شود.

> به زبان ساده: می‌توان چند برچسب متریک را با یک جداکننده (`separator`) به یک label جدید وصل کرد.

---

## ⚙️ پارامترها

| پارامتر                       | توضیح                                   |
| ----------------------------- | --------------------------------------- |
| `vector`                      | instant vector یا range vector مورد نظر |
| `dst_label`                   | نام label جدیدی که می‌خواهی بسازی       |
| `separator`                   | رشته‌ای که بین labelها قرار می‌گیرد     |
| `src_label1, src_label2, ...` | labelهایی که می‌خواهی ترکیب شوند        |

---

## 🧠 مثال ساده

فرض کن متریک زیر داریم:

| instance | job | value |
| -------- | --- | ----- |
| 10.0.0.1 | web | 1     |
| 10.0.0.2 | web | 2     |

می‌خواهیم یک label جدید بسازیم که ترکیب `job` و `instance` باشد:

```promql
label_join(up, "job_instance", "-", "job", "instance")
```

📤 خروجی:

| instance | job | job_instance | value |
| -------- | --- | ------------ | ----- |
| 10.0.0.1 | web | web-10.0.0.1 | 1     |
| 10.0.0.2 | web | web-10.0.0.2 | 2     |

---

## ⚡ کاربردهای عملی

1. **ساخت label جدید برای grouping در Grafana**

   * مثلاً بخواهی بر اساس ترکیب `namespace` و `pod` در داشبورد گروه‌بندی کنی:

   ```promql
   label_join(container_cpu_usage_seconds_total, "ns_pod", "/", "namespace", "pod")
   ```

2. **آماده‌سازی label برای vector matching**

   * وقتی می‌خواهی دو متریک را بر اساس label جدید match کنی، می‌توانی با `label_join()` label جدید بسازی و سپس `on()` یا `group_left()` استفاده کنی.

3. **سادگی در alerting**

   * به جای اینکه چند label را جداگانه در alert rule بررسی کنی، همه را با یک label ترکیب می‌کنی.

---

## ⚠️ نکات مهم

* اگر یکی از labelهای منبع وجود نداشته باشد، `dst_label` ساخته نمی‌شود.
* مقدار `separator` می‌تواند هر رشته‌ای باشد، حتی خالی (`""`).
* `label_join()` تغییر **مقدار metric** نمی‌دهد، فقط labelها را دستکاری می‌کند.

---

## 🧾 خلاصه

| ویژگی              | توضیح                                                 |
| ------------------ | ----------------------------------------------------- |
| تابع               | `label_join(vector, dst_label, sep, src_label1, ...)` |
| ورودی              | instant یا range vector                               |
| خروجی              | همان vector با label جدید ترکیبی                      |
| کاربرد             | گروه‌بندی، alerting، آماده‌سازی label برای join       |
| تغییر مقدار metric | ندارد، فقط labelها را اضافه می‌کند                    |

---


٪٪٪٪٪٪٪٪٪٪٪٪٪٪


---

## 🧩 تعریف تابع label_replace

```promql
label_replace(vector, dst_label, replacement, src_label, regex)
```

---

## 🎯 هدف تابع

تابع `label_replace()` برای **ساخت یا جایگزینی labelها بر اساس الگوی regex** استفاده می‌شود.

> به زبان ساده: می‌توان مقدار یک label را استخراج یا تغییر داد و در یک label جدید قرار داد.

---

## ⚙️ پارامترها

| پارامتر       | توضیح                                                                                        |
| ------------- | -------------------------------------------------------------------------------------------- |
| `vector`      | instant vector یا range vector مورد نظر                                                      |
| `dst_label`   | نام label جدید یا موجود که می‌خواهی مقدار آن را تغییر دهی                                    |
| `replacement` | مقداری که می‌خواهی با regex جایگزین شود (می‌تواند `$1` و `$2` داشته باشد برای capture group) |
| `src_label`   | label مبدا که مقدارش برای regex بررسی می‌شود                                                 |
| `regex`       | الگوی regex برای استخراج بخش مورد نظر                                                        |

---

## 🧠 مثال ساده

فرض کن متریک زیر داریم:

| instance    | job | value |
| ----------- | --- | ----- |
| web-01.prod | web | 1     |
| web-02.prod | web | 2     |

می‌خواهیم فقط شماره سرور (01، 02) را استخراج کنیم و در label جدید `server_id` قرار دهیم:

```promql
label_replace(up, "server_id", "$1", "instance", "web-(\\d+)\\.prod")
```

📤 خروجی:

| instance    | job | server_id | value |
| ----------- | --- | --------- | ----- |
| web-01.prod | web | 01        | 1     |
| web-02.prod | web | 02        | 2     |

> توضیح:
>
> * `(\\d+)` → یک یا چند رقم را در instance پیدا می‌کند
> * `$1` → مقدار capture group اول را در label جدید `server_id` قرار می‌دهد

---

## ⚡ کاربردهای عملی

1. **استخراج بخشی از label برای alert یا grouping**

   * مثلاً namespace یا pod name را از instance یا container name جدا می‌کنیم.

2. **ساخت label جدید برای vector matching**

   * وقتی می‌خواهی دو متریک را بر اساس label جدید join کنی.

3. **تبدیل یا پاک‌سازی labelها**

   * حذف پسوند، پیشوند، یا بخش اضافی در labelها.

---

## ⚠️ نکات مهم

* اگر regex match نشود، `dst_label` ساخته نمی‌شود.
* می‌توان از capture groups (`$1`, `$2`, ...) در replacement استفاده کرد.
* این تابع مقدار metric را تغییر نمی‌دهد، فقط labelها را دستکاری می‌کند.

---

## 🧾 خلاصه

| ویژگی              | توضیح                                                             |
| ------------------ | ----------------------------------------------------------------- |
| تابع               | `label_replace(vector, dst_label, replacement, src_label, regex)` |
| ورودی              | instant یا range vector                                           |
| خروجی              | همان vector با label جدید یا اصلاح‌شده                            |
| کاربرد             | استخراج یا تغییر label بر اساس regex                              |
| تغییر مقدار metric | ندارد                                                             |

---




٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪



---

## 🧩 تعریف تابع

```promql
month(v instant-vector)
```

یا اگر بدون آرگومان استفاده شود:

```promql
month()
```

---

## 🎯 هدف تابع

تابع `month()` مقدار **ماه جاری (از 1 تا 12)** را از timestamp هر نمونه داده برمی‌گرداند.

> یعنی اگر timestamp نمونه مربوط به مهرماه باشد، خروجی `7` خواهد بود (ماه هفتم سال میلادی).

---

## 🧠 کاربردها

* تحلیل داده‌ها بر اساس **ماه سال**
* ساخت **report ماهانه** در Prometheus یا Grafana
* ترکیب با توابع aggregate برای گروه‌بندی داده‌ها بر اساس ماه

---

## 🕒 مثال ساده

فرض کن متریک زیر داریم:

```promql
up
```

اگر بنویسی:

```promql
month(up)
```

* هر نمونه مقدار ۱ تا ۱۲ خواهد داشت، بسته به اینکه مربوط به کدام ماه باشد.

مثلاً اگر الان مهرماه (October / ماه 10 میلادی) باشد:

```
10
```

---

## 📊 مثال کاربردی با aggregate

می‌خواهی میانگین متریک `http_requests_total` را **برای هر ماه** ببینی:

```promql
avg(http_requests_total) by (month())
```

> اینجا ماه هر نمونه جدا شده و میانگین برای هر ماه محاسبه می‌شود.

---

## 🔹 تفاوت با سایر توابع زمانی

| تابع             | خروجی     | محدوده           |
| ---------------- | --------- | ---------------- |
| `hour()`         | ساعت روز  | 0–23             |
| `day_of_month()` | روز ماه   | 1–31             |
| `day_of_week()`  | روز هفته  | 0–6 (0 = یکشنبه) |
| `month()`        | شماره ماه | 1–12             |
| `year()`         | سال       | مثلا 2025        |

---

## ⚠️ نکات مهم

* `month()` بر اساس **timestamp هر نمونه** عمل می‌کند، نه زمان فعلی سیستم.
* معمولاً همراه با `by()` یا aggregate استفاده می‌شود تا گزارش ماهانه ایجاد شود.

---

## 🧾 خلاصه

| ویژگی      | توضیح                                   |
| ---------- | --------------------------------------- |
| تابع       | `month(v instant-vector)`               |
| ورودی      | vector (instant) یا بدون ورودی          |
| خروجی      | عدد ماه (1–12)                          |
| کاربرد     | تحلیل داده‌ها بر اساس ماه، گزارش ماهانه |
| نمونه ساده | `month(up)` → 10                        |

---

اگر بخواهی، می‌توانم یک مثال عملی با **Grafana** نشان بدهم که چطور `month()` را برای **heatmap یا گزارش ماهانه** استفاده می‌کنند تا الگوهای ترافیک یا درخواست‌ها را بر اساس ماه ببینی.


٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪



---

## 🧩 تعریف تابع predict_linear

```promql
predict_linear(range-vector, seconds)
```

---

## 🎯 هدف تابع

‏* `predict_linear()` مقدار آینده یک **metric** را پیش‌بینی می‌کند.
* پیش‌بینی بر اساس **روند خطی داده‌های گذشته** در **بازه‌ی زمانی مشخص شده** انجام می‌شود.

> به زبان ساده: اگر متریک شما با همان روند ادامه پیدا کند، مقدار آن بعد از `seconds` ثانیه آینده چقدر خواهد بود؟

---

## ⚙️ پارامترها

| پارامتر        | توضیح                                                                         |
| -------------- | ----------------------------------------------------------------------------- |
| `range-vector` | بازه‌ی زمانی که داده‌ها برای محاسبه‌ی روند در آن بررسی می‌شوند (مثلاً `[5m]`) |
| `seconds`      | مدت زمان پیش‌بینی به ثانیه (مثلاً `60` → ۱ دقیقه آینده)                       |

---

## 🧠 مثال ساده

فرض کن متریک زیر داریم (مثلاً تعداد درخواست‌های HTTP در هر ثانیه):

```promql
http_requests_total
```

می‌خواهیم مقدار پیش‌بینی‌شده در ۱ دقیقه آینده را ببینیم، بر اساس روند ۵ دقیقه اخیر:

```promql
predict_linear(http_requests_total[5m], 60)
```

‏🔹 Prometheus از **رگرسیون خطی** استفاده می‌کند تا خط روند گذشته را پیدا کند و مقدار **60 ثانیه بعد** را پیش‌بینی کند.

---

## 🧮 نحوه کارکرد (مفهومی)

1. داده‌های گذشته در بازه‌ی `[5m]` جمع‌آوری می‌شوند.
2. **رگرسیون خطی** روی داده‌ها اجرا می‌شود تا **شیب خط روند** (slope) و مقدار اولیه (intercept) محاسبه شود.
3. مقدار پیش‌بینی شده:

[
\text{predicted value} = \text{current value} + (\text{slope} \times \text{seconds})
]

> یعنی اگر روند فعلی ادامه پیدا کند، مقدار متریک بعد از `seconds` ثانیه چقدر خواهد بود.

---

## ⚡ کاربردهای عملی

‏1. **Alerting پیش‌بینی‌شده**

   * می‌توان پیش‌بینی کرد که آیا متریک در آینده به حد بحرانی می‌رسد یا نه:

   ```promql
   predict_linear(node_memory_Active_bytes[10m], 300) > 0.9 * node_memory_MemTotal_bytes
   ```

   > پیش‌بینی می‌کند که در ۵ دقیقه آینده، استفاده از حافظه بیش از ۹۰٪ خواهد شد یا نه.

2. **پیش‌بینی ترافیک**

   * برای HTTP requests یا CPU usage می‌توان trend آینده را پیش‌بینی کرد و alert گرفت.

3. **نمودارهای آینده‌نگر در Grafana**

   * نمایش روند پیش‌بینی‌شده بر اساس داده‌های گذشته برای planning یا ظرفیت‌سنجی.

---

## ⚠️ نکات مهم

‏* `predict_linear()` فقط روی **متریک‌های cumulative یا gauge** کاربرد دارد.
* پیش‌بینی دقیق نیست و صرفاً **تخمین خطی** است؛ اگر رفتار متریک ناگهانی تغییر کند، پیش‌بینی اشتباه خواهد بود.
* بازه‌ی `[range-vector]` باید حداقل دو نمونه داشته باشد تا slope قابل محاسبه باشد.

---

## 🧾 خلاصه

| ویژگی  | توضیح                                                      |
| ------ | ---------------------------------------------------------- |
| تابع   | `predict_linear(range-vector, seconds)`                    |
| ورودی  | range vector از داده‌های گذشته                             |
| خروجی  | مقدار پیش‌بینی‌شده متریک بعد از `seconds` ثانیه            |
| هدف    | تخمین آینده متریک بر اساس روند خطی گذشته                   |
| کاربرد | Alerting پیش‌بینی‌شده، نمودارهای آینده‌نگر، trend analysis |

---

٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪٪



