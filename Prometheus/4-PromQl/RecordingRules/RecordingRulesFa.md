خواهش می‌کنم. متن شما را بررسی کردم و تغییرات جزئی برای طبیعی‌تر شدن آن برای یک فارسی‌زبان اعمال کردم، ضمن اینکه لحن متن حفظ شده است.

***

دسترسی به PromQL تنها از طریق HTTP API امکان‌پذیر نیست. شما همچنین می‌توانید از «قوانین ضبط» (recording rules) استفاده کنید تا پرومتئوس عبارات PromQL را به‌طور منظم ارزیابی کرده و نتایج آن‌ها را دریافت (ingest) نماید. این کار برای سرعت بخشیدن به داشبوردهای شما، ارائه نتایج تجمیع‌شده برای استفاده در جاهای دیگر، و ترکیب «توابع وکتور بازه‌ای» (range vector functions) مفید است. سایر سیستم‌های مانیتورینگ ممکن است قابلیت معادل خود را «کوئری‌های ایستا» (standing queries) یا «کوئری‌های پیوسته» (continuous queries) بنامند. «قوانین هشداردهی» (Alerting rules) (که در فصل ۱۸ پوشش داده شده‌اند) نیز نوعی از قوانین ضبط هستند. این فصل به شما نشان می‌دهد که چگونه و چه زمانی از قوانین ضبط استفاده کنید.

## استفاده از قوانین ضبط (Using Recording Rules)

قوانین ضبط در فایل‌هایی جدا از `prometheus.yml` شما قرار می‌گیرند که به عنوان «فایل‌های قوانین» (rule files) شناخته می‌شوند. همانند `prometheus.yml`، فایل‌های قوانین نیز از فرمت YAML استفاده می‌کنند. شما می‌توانید محل قرارگیری فایل‌های قوانین خود را با استفاده از فیلد سطح بالای `rule_files` در `prometheus.yml` خود مشخص کنید. به عنوان مثال، مثال ۱۷-۱ یک فایل قانون به نام `rules.yml` را بارگذاری می‌کند، علاوه بر اینکه دو هدف (target) را نیز جمع‌آوری (scrape) می‌کند.

مثال ۱۷-۱. `prometheus.yml` که دو هدف را جمع‌آوری و یک فایل قانون را بارگذاری می‌کند.
```yaml
global:
  scrape_interval: 10s
  evaluation_interval: 10s
rule_files:
  - rules.yml
scrape_configs:
  - job_name: prometheus
    static_configs:
      - targets:
          - localhost:9090
  - job_name: node
    static_configs:
      - targets:
          - localhost:9100
```

مشابه فیلد `files` در `file_sd_configs`، همانطور که در بخش «فایل» در صفحه ۱۴۲ پوشش داده شد، `rule_files` لیستی از مسیرها را می‌پذیرد و شما می‌توانید از الگوهای عام (globs) در نام فایل استفاده کنید. برخلاف «کشف سرویس از طریق فایل» (file service discovery)، `rule_files` از inotify استفاده نمی‌کند و تغییراتی را که در فایل‌های قوانین ایجاد می‌کنید، به‌طور خودکار تشخیص نمی‌دهد. در عوض، باید پرومتئوس را مجدداً راه‌اندازی (restart) کرده یا پیکربندی آن را مجدداً بارگذاری (reload) کنید. برای اینکه از پرومتئوس بخواهید پیکربندی خود را مجدداً بارگذاری کند، می‌توانید سیگنال SIGHUP را با استفاده از دستوری مانند زیر برای آن ارسال کنید:

`kill -HUP <pid>`

که در آن `pid` شناسه فرآیند (process ID) پرومتئوس است. همچنین می‌توانید یک درخواست HTTP POST به نقطه پایانی (endpoint) `/-/reload` پرومتئوس ارسال کنید، اما به دلایل امنیتی، این کار مستلزم مشخص شدن فلگ `--web.enable-lifecycle` است. اگر بارگذاری مجدد ناموفق باشد، پرومتئوس این موضوع را لاگ می‌کند و شما مشاهده خواهید کرد که متریک `prometheus_config_last_reload_successful` به 0 تغییر می‌کند. برای تشخیص فایل‌های پیکربندی یا قوانین نامعتبر از قبل، می‌توانید از دستور `promtool check config` برای بررسی `prometheus.yml` خود استفاده کنید. این دستور همچنین تمام فایل‌های قوانین ارجاع داده شده توسط `prometheus.yml` را بررسی می‌کند. ممکن است این را به عنوان یک «بررسی پیش از ارسال» (pre-submit check) یا «تست واحد» (unit test) داشته باشید که قبل از اعمال فایل پیکربندی اجرا می‌شود. اگر می‌خواهید نحو (syntax) فایل‌های قوانین منفرد را بررسی کنید، می‌توانید از `promtool check rules` استفاده کنید. خودِ فایل‌های قوانین شامل صفر¹ یا چند «گروه از قوانین» (groups of rules) هستند. مثال ۱۷-۲ یک فایل قانون را نشان می‌دهد.

مثال ۱۷-۲. `rules.yml` با یک گروه شامل دو قانون
```yaml
groups:
  - name: example
    rules:
      - record: job:process_cpu_seconds:rate5m
        expr: sum without(instance)(rate(process_cpu_seconds_total[5m]))
      - record: job:process_open_fds:max
        expr: max without(instance)(process_open_fds)
```

متوجه خواهید شد که گروه یک نام دارد. این نام باید در یک فایل قانون منحصر به فرد باشد و در رابط کاربری (UI) پرومتئوس و متریک‌ها استفاده می‌شود. `expr` عبارت PromQL است که باید ارزیابی شده و خروجی آن در نام متریکی که توسط `record` مشخص شده، قرار گیرد.

امکان مشخص کردن `evaluation_interval` برای یک گروه وجود دارد، اما همانند `scrape_interval`، برای حفظ سلامت و سادگی، باید تنها یک بازه زمانی (interval) در یک پرومتئوس داشته باشید. همچنین می‌توانید مجموعه‌ای از برچسب‌ها (labels) را در فیلد `labels` برای اضافه شدن به خروجی مشخص کنید، اما این کار به ندرت برای قوانین ضبط مناسب است.² هر قانون در یک گروه به نوبت ارزیابی می‌شود و خروجی قانون اول شما قبل از اجرای قانون دوم شما در پایگاه داده سری زمانی (time series database) دریافت (ingest) می‌شود. در حالی که قوانین درون یک گروه به صورت متوالی اجرا می‌شوند، گروه‌های مختلف در زمان‌های متفاوتی اجرا خواهند شد، همانطور که اهداف مختلف در زمان‌های متفاوتی جمع‌آوری (scrape) می‌شوند. این کار برای پخش کردن بار کاری (load) روی پرومتئوس شما انجام می‌شود. هنگامی که قوانین شما بارگذاری و اجرا شدند، می‌توانید آن‌ها را در صفحه وضعیت قوانین (Rules status page) در آدرس `http://localhost:9090/rules` مشاهده کنید، همانطور که در شکل ۱۷-۱ نشان داده شده است.

### شکل

شکل ۱۷-۱. صفحه وضعیت قوانین پرومتئوس

علاوه بر لیست کردن قوانین شما، مدت زمانی که کل گروه برای آخرین ارزیابی صرف کرده و مدت زمانی که هر قانون برای اجرا صرف کرده نیز نمایش داده می‌شود. می‌توانید از این اطلاعات برای یافتن قوانین پرهزینه که ممکن است نیاز به تنظیم یا بازنگری داشته باشند، استفاده کنید. متریک `prometheus_rule_group_last_duration_seconds` نیز به شما می‌گوید که آخرین ارزیابی هر گروه چقدر طول کشیده است، که می‌توانید از آن برای تعیین اینکه آیا اخیراً تغییراتی در هزینه قوانین شما رخ داده است یا خیر، استفاده کنید. هیچ متریکی برای مدت زمان قوانین منفرد وجود ندارد، زیرا این امر می‌تواند باعث مشکلات کاردینالیتی (cardinality issues) شود. در این مورد، قوانین کمتر از یک میلی‌ثانیه زمان می‌برند، که بسیار کمتر از بازه ارزیابی است، بنابراین جای نگرانی نیست.

هیچ API برای بارگذاری یا تغییر قوانین وجود ندارد. همانند پیکربندی پرومتئوس به‌طور کلی، فایل‌ها به عنوان پایه‌ای در نظر گرفته شده‌اند که در صورت تمایل می‌توانید چنین سیستمی را بر روی آن بنا کنید.

### چه زمانی از قوانین ضبط استفاده کنیم (When to Use Recording Rules)

موارد متعددی وجود دارد که ممکن است بخواهید از قوانین ضبط استفاده کنید. قوانین ضبط عمدتاً برای تجمیع (aggregate) متریک‌ها به منظور کارآمدتر کردن کوئری‌های شما استفاده می‌شوند. این امر برای داشبوردها، فدراسیون (federation)، و قبل از ذخیره متریک‌ها در ذخیره‌سازی بلندمدت (long-term storage) رایج است. همچنین ممکن است از قوانین ضبط برای ترکیب توابع وکتور بازه‌ای، و گاهی اوقات برای ارائه APIهایی از متریک‌ها به تیم‌های دیگر استفاده کنید.

### کاهش کاردینالیتی (Reducing Cardinality)

اگر عبارتی مانند زیر در یک داشبورد داشته باشید:

`sum without(instance)(rate(process_cpu_seconds_total{job="node"}[5m]))`

در صورتی که تعداد کمی هدف (target) داشته باشید، پاسخ سریعی از پرومتئوس دریافت خواهید کرد. با افزایش تعداد اهداف به صدها و هزاران، متوجه خواهید شد که زمان پاسخ برای یک `query_range` دیگر به آن سرعت نیست. به جای اینکه از PromQL بخواهید به هزاران سری زمانی برای کل بازه هر نمودار در داشبورد شما دسترسی پیدا کرده و آن‌ها را پردازش کند، می‌توانید این مقدار را با استفاده از یک گروه قانون، مانند زیر، از پیش محاسبه کنید:

```yaml
groups:
  - name: node
    rules:
      - record: job:process_cpu_seconds:rate5m
        expr: >
          sum without(instance)(
            rate(process_cpu_seconds_total{job="node"}[5m])
          )
```

که خروجی آن به متریکی به نام `job:process_cpu_seconds:rate5m` خواهد بود. اکنون فقط کافی است آن یک سری زمانی را هنگام رندر شدن داشبورد خود واکشی کنید. همین امر حتی اگر برچسب‌های ابزار دقیق‌سازی (instrumentation labels) در کار باشند نیز صادق است، زیرا شما تعداد سری‌های زمانی قابل پردازش را به اندازه تعداد نمونه‌های (instances) خود کاهش می‌دهید. در واقع، شما در حال معامله یک هزینه منابع مداوم در برابر تأخیر (latency) و هزینه منابع بسیار کمتر برای کوئری‌های خود هستید. به دلیل این بده‌بستان (trade-off)، معمولاً عاقلانه نیست که قوانینی داشته باشید که از بازه‌های وکتوری طولانی استفاده می‌کنند، زیرا چنین کوئری‌هایی معمولاً پرهزینه هستند و اجرای منظم آنها می‌تواند باعث مشکلات عملکردی شود. باید سعی کنید تمام قوانین مربوط به یک کار (job) را در یک گروه قرار دهید. به این ترتیب، آن‌ها دارای مُهر زمانی (timestamp) یکسانی خواهند بود و هنگام انجام محاسبات بیشتر روی آن‌ها، از ایجاد مصنوعات (artifacts) جلوگیری می‌شود. تمام قوانین ضبط در یک گروه، زمان ارزیابی کوئری یکسانی برای یک اجرا دارند و تمام نمونه‌های خروجی نیز آن مُهر زمانی را خواهند داشت.

متوجه خواهید شد که قوانین تجمیعی مانند این‌ها، فراتر از سریع‌تر کردن داشبوردهای شما مفید هستند. هنگام استفاده از فدراسیون، همانطور که در بخش «جهانی شدن با فدراسیون» در صفحه ۳۶۰ بحث شد، همیشه می‌خواهید متریک‌های تجمیع‌شده را بکشید (pull)، زیرا در غیر این صورت، بخش‌های بزرگی از متریک‌های سطح نمونه (instance-level) را وارد می‌کنید. در آن نقطه، از دیدگاه عملکردی، برای پرومتئوسی که از فدراسیون استفاده می‌کند بهتر است که خود اهداف را مستقیماً جمع‌آوری کند.⁴ منطق مشابهی در صورتی که بخواهید برخی متریک‌ها را به صورت بلندمدت ذخیره کنید نیز اعمال می‌شود. هنگام انجام «برنامه‌ریزی ظرفیت» (capacity planning) بر روی داده‌های ماه‌ها یا سال‌ها، جزئیات نمونه‌های منفرد مرتبط نیستند. با نگهداری عمدتاً متریک‌های تجمیع‌شده به صورت بلندمدت، می‌توانید با از دست دادن اندکی اطلاعات مفید، منابع زیادی را ذخیره کنید.⁵

اغلب قوانین تجمیعی بر اساس همان متریک اما با مجموعه‌های متفاوتی از برچسب‌ها خواهید داشت. به جای محاسبه هر تجمیع به صورت جداگانه، می‌توانید با داشتن یک قانون که از خروجی قانون دیگری استفاده می‌کند، کارآمد عمل کنید. مثلا:

```yaml
groups:
  - name: node
    rules:
      - record: job_device:node_disk_read_bytes:rate5m
        expr: >
          sum without(instance)(
            rate(node_disk_read_bytes_total{job="node"}[5m])
          )
      - record: job:node_disk_read_bytes:rate5m
        expr: >
          sum without(device)(
            job_device:node_disk_read_bytes:rate5m{job="node"}
          )
```

برای اینکه این به درستی کار کند، قوانین در یک سلسله مراتب معین باید به ترتیب در یک گروه قانون واحد باشند.⁶ به طور کلی بهتر است به صراحت کاری (job) را که قوانین شما برای آن اعمال می‌شوند در انتخابگرهای (selectors) خود مشخص کنید، تا گروه‌های شما در کار یکدیگر دخالت نکنند.

### ترکیب توابع وکتور بازه‌ای (Composing Range Vector Functions)

همانطور که در «تجمیع در طول زمان» در صفحه ۲۹۵ ذکر شد، نمی‌توانید از توابع وکتور بازه‌ای بر روی خروجی توابعی که وکتورهای لحظه‌ای (instant vectors) تولید می‌کنند، استفاده کنید. به عنوان مثال، `max_over_time(sum without(instance)(rate(x_total[5m]))[1h])` امکان‌پذیر نیست و یک خطای تجزیه (parse error) ایجاد می‌کند. در حالی که PromQL دارای «زیرکوئری‌ها» (subqueries) است، می‌توانید از قوانین ضبط برای رسیدن به همین نتیجه استفاده کنید:

```yaml
groups:
  - name: j_job_rules
    rules:
      - record: job:x:rate5m
        expr: >
          sum without(instance)(
            rate(x_total{job="j"}[5m])
          )
      - record: job:x:max_over_time1h_rate5m
        expr: max_over_time(job:x:rate5m{job="j"}[1h])
```

این رویکرد را می‌توان با هر تابع وکتور بازه‌ای استفاده کرد، از جمله نه تنها توابع `_over_time` بلکه `predict_linear`، `deriv` و `holt_winters`. با این حال، این تکنیک نباید با `rate`، `irate` یا `increase` استفاده شود، زیرا یک عبارت مؤثر از `rate(sum(x_total)[5m])` هر بار که یکی از شمارنده‌های تشکیل‌دهنده آن بازنشانی (reset) یا ناپدید شود، جهش‌های عظیمی خواهد داشت.

**همیشه ابتدا `rate` و سپس `sum` کنید، هرگز ابتدا `sum` و سپس `rate` نکنید.**

لازم نیست تابع بیرونی را در یک قانون ضبط داشته باشید. در مثال قبلی، ممکن است منطقی‌تر باشد که `max_over_time` را زمانی که به آن نیاز دارید، انجام دهید. به عنوان مثال، کاربرد اصلی این مثال خاص، برنامه‌ریزی ظرفیت خواهد بود، زیرا شما باید برای ترافیک اوج (peak) به جای میانگین برنامه‌ریزی کنید. از آنجایی که برنامه‌ریزی ظرفیت اغلب یک بار در ماه یا یک بار در فصل انجام می‌شود، ارزیابی `max_over_time` حداقل یک بار در دقیقه، به جای اجرای کوئری فقط زمانی که به آن نیاز دارید، چندان منطقی نیست. توابع روی بازه‌های زمانی طولانی‌تر نیز به دلیل مقدار داده‌ای که باید پردازش کنند، می‌توانند پرهزینه شوند. مراقب بازه‌های بیش از یک ساعت و به‌ویژه در تعداد زیادی سری زمانی باشید.

### قوانین برای APIها (Rules for APIs)

معمولاً سرورهای پرومتئوسی که شما اجرا می‌کنید، کاملاً توسط شما و تیمتان استفاده خواهند شد. اما ممکن است با موقعیت‌هایی مواجه شوید که تیم‌های دیگر مایل به دریافت متریک‌ها از پرومتئوس شما باشند. اگر استفاده آن‌ها صرفاً اطلاعاتی باشد یا به متریک‌هایی بستگی داشته باشد که بعید است تغییر کنند، معمولاً مشکلی نیست، زیرا اگر چیزی را برای آن‌ها خراب کنید، آخر دنیا نیست. اما اگر متریک‌ها به عنوان بخشی از سیستم‌ها یا فرآیندهای خودکار خارج از کنترل شما استفاده می‌شوند، ایده خوبی است که متریک‌هایی را فقط برای مصرف تیم‌های دیگر به عنوان نوعی API عمومی ایجاد کنید. سپس اگر نیاز به تغییر برچسب‌ها یا قوانین در داخل پرومتئوس خود داشتید، می‌توانید این کار را انجام دهید، در حالی که همچنان اطمینان حاصل می‌کنید که متریک‌هایی که تیم دیگر به آن‌ها وابسته است، همان معناشناسی (semantics) را حفظ می‌کنند. نام‌گذاری چنین متریک‌هایی معمولاً از قراردادهای نام‌گذاری عادی پیروی نمی‌کند و شما معمولاً نام تیم مصرف‌کننده را یا در نام متریک یا در یک برچسب قرار می‌دهید. چنین استفاده‌هایی از قوانین بسیار نادر است. اگر استفاده تیم دیگری از پرومتئوس شما به مرحله‌ای برسد که بار نگهداری غیرقابل اغماضی را بر دوش شما قرار دهد، ممکن است بخواهید از آن‌ها بخواهید که پرومتئوس خود را برای متریک‌هایی که نیاز دارند، اجرا کنند.

### چگونه از قوانین استفاده نکنیم (How Not to Use Rules)

ما متوجه چند «ضدالگو» (antipattern) رایج در مورد قوانین ضبط شده‌ایم که می‌خواهیم به شما در اجتناب از آن‌ها کمک کنیم. اولین مورد، قوانینی است که مزایای برچسب‌ها را از بین می‌برد. مثلا:

```yaml
- record: job_device:node_disk_read_bytes_sda:rate5m
  expr: >
    sum without(instance)(
      rate(node_disk_read_bytes_total{job="node",device="sda"}[5m])
    )
- record: job_device:node_disk_read_bytes_sdb:rate5m
  expr: >
    sum without(instance)(
      rate(node_disk_read_bytes_total{job="node",device="sdb"}[5m])
    )
```

این کار مستلزم آن است که به ازای هر برچسب `device` بالقوه، یک قانون داشته باشید و نمی‌توانید به راحتی این متریک‌ها را تجمیع کنید. این اساساً کل هدف برچسب‌ها، یکی از قدرتمندترین ویژگی‌های پرومتئوس، را از بین می‌برد. باید از انتقال مقادیر برچسب به نام متریک‌ها خودداری کنید، و اگر می‌خواهید بر اساس مقدار یک برچسب، سری‌های زمانی بازگشتی را محدود کنید، از یک «تطبیق‌دهنده» (matcher) در زمان کوئری استفاده کنید. به طور مشابه، برچسب `job` را به نام متریک منتقل نکنید.

یک ضدالگوی دیگر، پیش‌تجمیع (preaggregating) تمام متریک‌هایی است که یک برنامه ارائه می‌دهد. در حالی که درست است که تجمیع ایده خوبی برای کاهش کاردینالیتی به منظور بهبود عملکرد است، اما زیاده‌روی در آن نتیجه معکوس دارد. در یک سیستم مانیتورینگ مبتنی بر متریک، غیرمعمول نیست که هرگز بیش از ۹۰٪ از متریک‌های خود را استفاده نکنید،⁷ بنابراین تجمیع همه چیز به طور پیش‌فرض، اتلاف منابع است و با اضافه و حذف شدن متریک‌ها در طول زمان، نیاز به نگهداری غیرضروری خواهد داشت. در عوض، باید تجمیع را در صورت نیاز اضافه کنید. آن ۹۰٪ دیگر از متریک‌ها هنوز برای زمانی که در حال اشکال‌زدایی (debugging) یک مشکل عجیب در اعماق سیستم خود هستید، قابل دسترسی هستند و تنها هزینه عدم تجمیع آن‌ها این است که کوئری‌های شما روی آن‌ها کمی بیشتر طول می‌کشد.

هدف اصلی قوانین ضبط، کاهش کاردینالیتی است، بنابراین اغلب دلیلی ندارد قوانینی داشته باشید که هنوز برچسب `instance` را در خروجی خود دارند. کوئری گرفتن از ده سری زمانی در زمان کوئری، به طور قابل توجهی پرهزینه‌تر از کوئری گرفتن از یک سری زمانی نیست. اگر متریک‌هایی با کاردینالیتی بالا در یک هدف دارید، قوانین ضبط با برچسب `instance` می‌توانند منطقی باشند، اگرچه باید در نظر بگیرید که آیا آن برچسب‌های ابزار دقیق‌سازی (instrumentation labels) باید به دلایل کاردینالیتی حذف شوند یا خیر.

با قوانینی مانند:
```yaml
- record: job:x:max_over_time1h_rate5m
  expr: max_over_time(job:x:rate5m{job="j"}[1h])
```
از بخش قبلی، ممکن است وسوسه شوید که `evaluation_interval` آنها را به یک ساعت تغییر دهید تا در منابع صرفه‌جویی کنید. این ایده خوبی نیست به سه دلیل. اول، از آنجایی که متریک ورودی از یک قانون ضبط آمده که قبلاً کاردینالیتی را کاهش داده است، هرگونه صرفه‌جویی در منابع احتمالاً در مقیاس بزرگ ناچیز خواهد بود. دوم، پرومتئوس فقط تضمین می‌کند که قانون یک بار در ساعت اجرا می‌شود، نه اینکه چه زمانی در آن ساعت اجرا خواهد شد. از آنجایی که شما احتمالاً نتایج را در حدود ابتدای ساعت می‌خواهید، این، همراه با «مدیریت داده‌های کهنه/منقضی شده» (staleness handling)، کارساز نخواهد بود. سوم، برای حفظ سلامت روانی خود، باید تنها یک بازه زمانی (interval) در سرورهای پرومتئوس خود داشته باشید.

آخرین الگویی که توصیه می‌کنیم از آن اجتناب کنید، استفاده از قوانین ضبط برای اصلاح نام‌ها و برچسب‌های نامناسب متریک‌ها است. این الگو مُهرهای زمانی اصلی داده‌ها را از دست می‌دهد و تشخیص اینکه یک متریک از کجا آمده و چه معنایی دارد را دشوارتر می‌کند. ابتدا، باید سعی کنید متریک‌ها را در مبدأ خود بهبود بخشید، و اگر به دلایل فنی یا سیاسی این امکان‌پذیر نیست، در نظر بگیرید که آیا استفاده از `metric_relabel_configs`، همانطور که در «`metric_relabel_configs`» در صفحه ۱۶۴ توضیح داده شده است، برای بهبود آن‌ها ارزش معایب متفاوت بودنشان از آنچه دیگران انتظار دارند نامگذاری شوند را دارد یا خیر. متأسفانه، همیشه مواردی وجود خواهد داشت که سیستم‌ها متریک‌هایی را ارائه می‌دهند که بیش از حد از روش انجام کارها در پرومتئوس فاصله دارند و شما چاره‌ای جز اصلاح آن‌ها به هر شکلی که می‌توانید ندارید.

### نام‌گذاری قوانین ضبط (Naming of Recording Rules)

با استفاده از یک «قرارداد» (convention) خوب برای نام‌گذاری قوانین ضبط، نه تنها می‌توانید با یک نگاه بفهمید که نام یک متریک قانون ضبط معین چه معنایی دارد، بلکه به دلیل داشتن یک واژگان مشترک، اشتراک‌گذاری قوانین خود با دیگران نیز آسان‌تر خواهد بود. همانطور که در «چه نامی برای متریک‌هایم انتخاب کنم؟» در صفحه ۶۰ ذکر شد، کاراکترهای دو نقطه (:) در نام متریک‌ها معتبر هستند اما باید در «ابزار دقیق‌سازی» (instrumentation) از آن‌ها اجتناب شود. دلیل این امر آن است که کاربر بتواند از آن‌ها برای افزودن ساختار خود در قوانین ضبط استفاده کند. قراردادی که ما در اینجا استفاده می‌کنیم، تعادلی بین دقت و ایجاز (succinctness) برقرار می‌کند و حاصل سال‌ها تجربه است.

روش کار این قرارداد به این صورت است که نام متریک‌های شما شامل برچسب‌هایی است که درگیر هستند، سپس نام متریک، و سپس عملیاتی که بر روی متریک انجام شده است. این سه بخش با دو نقطه از هم جدا می‌شوند، بنابراین شما همیشه یا صفر یا دو دو نقطه در نام یک متریک خواهید داشت. به عنوان مثال، با توجه به نام متریک:

`job_device:node_disk_read_bytes:rate5m`

می‌توانیم بگوییم که دارای برچسب‌های `job` و `device` است، متریکی که بر اساس آن ساخته شده `node_disk_read_bytes` است، و یک شمارنده (counter) است که `rate(node_disk_read_bytes_total[5m])` روی آن اعمال شده است. این بخش‌ها عبارتند از: سطح (level)، متریک (metric) و عملیات (operations):

*   **سطح (level)**
    سطح، میزان تجمیع متریک را بر اساس برچسب‌هایی که دارد، نشان می‌دهد. این همیشه شامل برچسب‌های ابزار دقیق‌سازی (اگر هنوز تجمیع نشده باشند)، برچسب `job` که باید وجود داشته باشد، و هر برچسب هدف (target label) دیگری که مرتبط است، خواهد بود. اینکه کدام برچسب‌های هدف را شامل شود، به زمینه بستگی دارد. اگر یک برچسب `env` در تمام اهداف خود دارید که بر قوانین شما تأثیر نمی‌گذارد، نیازی به حجیم کردن نام متریک‌های خود با آن نیست. اما اگر یک کار (job) با یک برچسب `shard` تقسیم شده باشد، احتمالاً باید آن را شامل کنید.

*   **متریک (metric)**
    متریک همان نام متریک یا سری زمانی است. معمولاً برای ایجاز بیشتر، `_total` از شمارنده‌ها حذف می‌شود، اما در غیر این صورت این باید دقیقاً نام متریک باشد. مزیت حفظ نام متریک این است که جستجوی کدبیس خود برای آن نام متریک آسان می‌شود، و برعکس اگر در حال بررسی کد برای یافتن اینکه آیا متریک تجمیع شده است یا خیر، نیز مفید است. برای نسبت‌ها از `foo_per_bar` استفاده می‌کنید، اما یک قانون خاص برای برخورد با نسبت‌های `_sum` و `_count` وجود دارد.

*   **عملیات (operations)**
    عملیات، لیستی از توابع و تجمیع‌کننده‌ها (aggregators) هستند که بر روی متریک اعمال شده‌اند، که آخرین مورد اول می‌آید. اگر دو عملیات `sum` یا `max` دارید، فقط باید یکی را لیست کنید، زیرا جمع یک جمع هنوز هم یک جمع است. از آنجایی که `sum` تجمیع پیش‌فرض است، معمولاً نیازی به ذکر آن نیست. اما اگر عملیات دیگری برای استفاده ندارید، یا هنوز هیچ عملیاتی اعمال نکرده‌اید، `sum` یک پیش‌فرض خوب است. بسته به اینکه چه عملیاتی را در سطوح دیگر اعمال می‌کنید، `min` و `max` می‌توانند برای نام متریک پایه منطقی باشند. عملیاتی که باید برای تقسیم استفاده کنید `ratio` است.

برای مثال، اگر یک شمارنده `foo_total` با برچسب ابزار دقیق‌سازی `bar` داشتید، تجمیع برچسب `instance` به این شکل خواهد بود:
```yaml
- record: job_bar:foo:rate5m
  expr: sum without(instance)(rate(foo_total{job="j"}[5m]))
```

از آنجا، برای تجمیع برچسب `bar` به این شکل خواهد بود:
```yaml
- record: job:foo:rate5m
  expr: sum without(bar)(job_bar:foo:rate5m{job="j"})
```

می‌توانید برخی از مزایای این رویکرد را مشاهده کنید. از بررسی ظاهری مشخص است که مدیریت برچسب در اینجا همانطور که انتظار می‌رود انجام شده است، زیرا سری زمانی ورودی `job_bar` را به عنوان سطح داشت، `bar` با استفاده از عبارت `without` حذف شد و خروجی `job` را به عنوان سطح داشت. در قوانین و سلسله مراتب پیچیده‌تر، این می‌تواند برای تشخیص اشتباهات مفید باشد. به عنوان مثال، قانون:

```yaml
- record: job:foo_per_bar:ratio_rate5m
  expr: >
    (
      job:foo:rate5m{job="j"}
      /
      job:bar:rate10m{job="j"}
    )
```
به نظر می‌رسد از طرح نام‌گذاری برای نسبت‌ها پیروی می‌کند، اما بین `rate5m` و `rate10m` عدم تطابق وجود دارد، که باید متوجه آن شوید و بفهمید که این عبارت و قانون ضبط حاصل از آن منطقی نیست. یک نسبت صحیح ممکن است به این شکل باشد:

```yaml
- record: job_mountpoint:node_filesystem_avail_bytes_per_node_filesystem_size_bytes:ratio
  expr: >
    (
      job_mountpoint:node_filesystem_avail_bytes:sum{job="node"}
      /
      job_mountpoint:node_filesystem_size_bytes:sum{job="node"}
    )
```

در اینجا می‌توانید ببینید که صورت (numerator) و مخرج (denominator) دارای سطح و عملیات یکسانی هستند که به نام متریک خروجی منتقل می‌شوند.⁸ در اینجا `sum` حذف شده است، زیرا چیزی به شما نمی‌گوید. اگر عملیات `rate5m` در متریک‌های ورودی وجود داشت، اینطور نبود.

استفاده از نمادگذاری قبلی برای میانگین اندازه رویدادها کمی پرحرفی خواهد بود، بنابراین به جای آن نام متریک حفظ شده و `mean5m` به عنوان عملیات خروجی استفاده می‌شود زیرا بر اساس `rate5m` است و بنابراین میانگینی در طول ۵ دقیقه است:

```yaml
- record: job_instance:go_gc_duration_seconds:mean5m
  expr: >
    (
      job_instance:go_gc_duration_seconds_sum:rate5m{job="prometheus"}
      /
      job_instance:go_gc_duration_seconds_count:rate5m{job="prometheus"}
    )
```

اگر بعداً قانون زیر را مشاهده کردید:
```yaml
- record: job:go_gc_duration_seconds:mean5m
  expr:
    avg without(instance)(
      job_instance:go_gc_duration_seconds:mean5m{job="prometheus"}
    )
```
بلافاصله مشخص خواهد شد که این در تلاش است تا میانگینی از یک میانگین بگیرد، که منطقی نیست. تجمیع صحیح به این صورت خواهد بود:

```yaml
- record: job:go_gc_duration_seconds:mean5m
  expr: >
    (
      sum without(instance)(
        job_instance:go_gc_duration_seconds_sum:rate5m{job="prometheus"}
      )
      /
      sum without(instance)(
        job_instance:go_gc_duration_seconds_count:rate5m{job="prometheus"}
      )
    )
```
باید برای تجمیع `sum` کنید و تقسیم برای میانگین‌گیری را تنها در آخرین مرحله محاسبه خود انجام دهید.

در حالی که موارد قبلی ساده هستند، مانند نام‌گذاری متریک به‌طور کلی، هنگامی که از مسیر معمول و شناخته‌شده خارج می‌شوید، نام‌گذاری قوانین ضبط می‌تواند بیشتر هنر باشد تا علم. باید تلاش کنید تا اطمینان حاصل کنید که نام‌های قوانین ضبط شما از نظر معناشناسی و برچسب‌ها واضح هستند، در حالی که همزمان سعی می‌کنید ارتباط نام‌های قوانین ضبط با کدی که متریک‌های اصلی را تولید کرده است، آسان باشد.

به جز موارد بسیار نادر (به «قوانین برای APIها» در صفحه ۳۰۲ مراجعه کنید)، نام‌های متریک باید هویت یک نام متریک را نشان دهند تا بتوانید بدانید چیست. نام‌های متریک نباید به عنوان راهی برای ذخیره حاشیه‌نویسی‌ها (annotations) برای خط‌مشی (policy) استفاده شوند. به عنوان مثال، نباید وسوسه شوید که `:federate` یا `:longterm` یا موارد مشابه را به نام متریک‌ها اضافه کنید تا نشان دهید که می‌خواهید فلان متریک به سیستم دیگری منتقل شود. این کار باعث حجیم شدن نام متریک‌ها می‌شود و هنگامی که خط‌مشی شما تغییر کند، مشکلاتی ایجاد خواهد کرد. در عوض، خط‌مشی خود را از طریق تطبیق‌دهنده‌ها (matchers) هنگام استخراج داده‌ها تعریف و پیاده‌سازی کنید، مثلاً، تمام نام‌های متریکی را که با `job:.*` مطابقت دارند، واکشی کنید، به جای اینکه سعی کنید روی اینکه دقیقاً کدام متریک‌ها واکشی شوند یا نشوند، بهینه‌سازی جزئی (micro-optimize) انجام دهید. تا زمانی که یک متریک از یک قانون ضبط عبور کرده باشد، احتمالاً به اندازه کافی تجمیع شده است که کاردینالیتی آن ناچیز باشد، و بنابراین احتمالاً ارزش وقت شما را ندارد که نگران هزینه‌های منابع در مراحل بعدی باشید.

اکنون که می‌دانید چگونه از قوانین ضبط استفاده کنید، فصل بعدی به قوانین هشداردهی خواهد پرداخت. قوانین هشداردهی نیز در گروه‌های قوانین قرار می‌گیرند و نحو مشابهی دارند.

---
¹ در متن اصلی "zero1" آمده که احتمالاً به یک پاورقی یا یادداشت اشاره دارد. در ترجمه، "صفر یا چند" مفهوم را می‌رساند.
² در متن اصلی "rules.2" آمده که احتمالاً به یک پاورقی یا یادداشت اشاره دارد.
³ اعداد صفحات مانند ۱۴۲، ۳۶۰، ۱۶۴، ۶۰، ۳۰۲ به صفحات کتاب اصلی اشاره دارند و در ترجمه حفظ شده‌اند.
⁴ عدد 4 در متن اصلی احتمالاً به یک پاورقی یا یادداشت اشاره دارد.
⁵ عدد 5 در متن اصلی احتمالاً به یک پاورقی یا یادداشت اشاره دارد.
⁶ عدد 6 در متن اصلی احتمالاً به یک پاورقی یا یادداشت اشاره دارد.
⁷ عدد 7 در متن اصلی احتمالاً به یک پاورقی یا یادداشت اشاره دارد.
⁸ عدد 8 در متن اصلی احتمالاً به یک پاورقی یا یادداشت اشاره دارد.